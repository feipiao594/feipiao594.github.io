<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2048</title>
    <url>/posts/cc2541cf.html</url>
    <content><![CDATA[<h1 id="2048"><a href="#2048" class="headerlink" title="2048"></a>2048</h1><p>小游戏，测试流畅性，同时学习 vibe coding</p>
<span id="more"></span>
<p>唉唉，我是对 2048 有一些执念的，vibe coding 做这个真的快</p>
<h2 id="游戏说明"><a href="#游戏说明" class="headerlink" title="游戏说明"></a>游戏说明</h2><p>这是一个经典的 2048 数字拼图游戏。</p>
<h3 id="玩法："><a href="#玩法：" class="headerlink" title="玩法："></a>玩法：</h3><ul>
<li>对于 PC 端，使用键盘方向键或 WASD 键(需点击一下棋盘让焦点位于游戏内)</li>
<li>对于手机端，点击屏幕上的方向按钮来移动所有方块。</li>
<li>相同数字的方块相撞时会合并为更大的数字。</li>
<li>每次移动，都会在棋盘上任意一个格子生成 2(90%) 或 4(10%)</li>
<li>目标是得到 2048 方块，但你可以继续玩更高分数。</li>
<li>当格子填满且无法移动时游戏结束。</li>
</ul>
<h3 id="特色："><a href="#特色：" class="headerlink" title="特色："></a>特色：</h3><ul>
<li>支持在第一次移动后进行缓存，刷新页面后可继续上次游戏。</li>
<li>达到 2048 后可继续挑战更高分数。</li>
<li>支持 PC 和移动端。</li>
</ul>
<h3 id="分数计算公式"><a href="#分数计算公式" class="headerlink" title="分数计算公式"></a>分数计算公式</h3><p>每次合并两个相同数字的方块时，分数会增加合并后的数值。例如：</p>
<ul>
<li>两个 2 合并为 4，得 4 分</li>
<li>两个 4 合并为 8，得 8 分</li>
<li>两个 8 合并为 16，得 16 分</li>
</ul>
<p>以此类推。</p>
<h2 id="游戏本体"><a href="#游戏本体" class="headerlink" title="游戏本体"></a>游戏本体</h2><div id="game-container" tabindex="0">
  <div id="game-section">
    <div id="score">分数: <span id="score-value">0</span> <span id="status"></span></div>
    <div id="grid"></div>
  </div>
  <div id="controls">
    <div id="direction-buttons">
      <button id="up">↑</button>
      <button id="left">←</button>
      <button id="right">→</button>
      <button id="down">↓</button>
    </div>
    <button id="restart">重新开始</button>
  </div>
</div>

<style>
#game-container {
  max-width: 600px;
  margin: 0 auto;
  font-family: Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}

#game-section {
  display: flex;
  flex-direction: column;
  align-items: center;
}

#score {
  text-align: center;
  font-size: min(24px, 6vw);
  margin-bottom: 10px;
}

#status {
  font-size: min(16px, 4vw);
  color: #776e65;
  margin-left: 20px;
}

#grid {
  position: relative;
  width: min(400px, 90vw);
  height: min(400px, 90vw);
  background-color: #bbada0;
  border-radius: 6px;
}

.cell {
  position: absolute;
  width: 22%;
  height: 22%;
  background-color: #cdc1b4;
  border-radius: 3px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: min(36px, 9vw);
  font-weight: bold;
  color: #776e65;
  transition: left 0.2s ease, top 0.2s ease, transform 0.1s ease;
}

.cell[data-value="128"], .cell[data-value="256"], .cell[data-value="512"] { font-size: min(28px, 7vw); }
.cell[data-value="1024"], .cell[data-value="2048"] { font-size: min(24px, 6vw); }
.cell[data-value="4096"], .cell[data-value="8192"] { font-size: min(24px, 5vw); }
.cell[data-value="16384"], .cell[data-value="32768"] { font-size: min(22px, 4vw); }
.cell[data-value="65536"], .cell[data-value="131072"] { font-size: min(20px, 3.5vw); }

.cell[data-value="2"] { background-color: #eee4da; }
.cell[data-value="4"] { background-color: #ede0c8; }
.cell[data-value="8"] { background-color: #f2b179; color: #f9f6f2; }
.cell[data-value="16"] { background-color: #f59563; color: #f9f6f2; }
.cell[data-value="32"] { background-color: #f67c5f; color: #f9f6f2; }
.cell[data-value="64"] { background-color: #f65e3b; color: #f9f6f2; }
.cell[data-value="128"] { background-color: #edcf72; color: #f9f6f2; }
.cell[data-value="256"] { background-color: #edcc61; color: #f9f6f2; }
.cell[data-value="512"] { background-color: #edc850; color: #f9f6f2; }
.cell[data-value="1024"] { background-color: #edc53f; color: #f9f6f2; }
.cell[data-value="2048"] { background-color: #edc22e; color: #f9f6f2; }
.cell[data-value="4096"] { background-color: #3c3a32; color: #f9f6f2; }
.cell[data-value="8192"] { background-color: #2e2b24; color: #f9f6f2; }
.cell[data-value="16384"] { background-color: #1e1c16; color: #f9f6f2; }
.cell[data-value="32768"] { background-color: #0f0e0a; color: #f9f6f2; }
.cell[data-value="65536"] { background-color: #000000; color: #f9f6f2; }
.cell[data-value="131072"] { background-color: #000000; color: #f9f6f2; }

#controls {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin: 20px 0;
}

#direction-buttons {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-rows: 1fr 1fr 1fr;
  gap: min(10px, 2.5vw);
  width: min(150px, 37.5vw);
  height: min(150px, 37.5vw);
}

#up { grid-column: 2; grid-row: 1; }
#left { grid-column: 1; grid-row: 2; }
#right { grid-column: 3; grid-row: 2; }
#down { grid-column: 2; grid-row: 3; }

button {
  font-size: min(24px, 6vw);
  padding: min(10px, 2.5vw);
  border: none;
  border-radius: 5px;
  background-color: #8f7a66;
  color: white;
  cursor: pointer;
}

button:hover {
  background-color: #9f8a76;
}

#restart {
  margin-top: 20px;
}

/* PC端：横向布局，controls在右侧 */
@media (min-width: 768px) {
  #game-container {
    flex-direction: row;
    justify-content: center;
    align-items: center;
  }

  #controls {
    margin: 0 0 0 50px;
  }
}

.cell.new {
  animation: appear 0.2s ease-out;
}

@keyframes appear {
  0% { transform: scale(0); }
  100% { transform: scale(1); }
}
</style>

<script>
let grid = [];
let score = 0;
let newTiles = [];
let mergedTiles = [];
let animating = false;
let hasWon = false;

function saveGame() {
  const gameState = {
    grid: grid,
    score: score,
    hasWon: hasWon
  };
  localStorage.setItem('game2048', JSON.stringify(gameState));
}

function loadGame() {
  const saved = localStorage.getItem('game2048');
  if (saved) {
    const gameState = JSON.parse(saved);
    grid = gameState.grid;
    score = gameState.score;
    hasWon = gameState.hasWon;
    return true;
  }
  return false;
}

function initGrid() {
  document.getElementById('grid').innerHTML = '';
  let loaded = loadGame();
  if (!loaded) {
    grid = Array(4).fill().map(() => Array(4).fill(0));
    score = 0;
    hasWon = false;
    addRandomTile();
    addRandomTile();
  }
  updateScore();
  if (loaded) {
    if (hasWon) {
      updateStatus('已获胜，可继续');
    } else if (isGameOver()) {
      updateStatus('游戏结束，请重新开始');
    } else {
      updateStatus('');
    }
  } else {
    updateStatus('');
  }
  renderGrid();
}

function addRandomTile() {
  let emptyCells = [];
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 0) {
        emptyCells.push({x: i, y: j});
      }
    }
  }
  if (emptyCells.length > 0) {
    let randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
    grid[randomCell.x][randomCell.y] = Math.random() < 0.9 ? 2 : 4;
    newTiles.push({x: randomCell.x, y: randomCell.y});
  }
}

function renderGrid() {
  const gridElement = document.getElementById('grid');
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      let id = 'cell-' + i + '-' + j;
      let cell = document.getElementById(id);
      if (!cell) {
        cell = document.createElement('div');
        cell.id = id;
        cell.className = 'cell';
        gridElement.appendChild(cell);
      }
      cell.style.left = (j * 25 + 1.5) + '%';
      cell.style.top = (i * 25 + 1.5) + '%';
      cell.setAttribute('data-value', grid[i][j]);
      cell.textContent = grid[i][j] !== 0 ? grid[i][j] : '';
      cell.classList.remove('new', 'merged');
      // 检查是否是新出现的块
      if (newTiles.some(tile => tile.x === i && tile.y === j)) {
        cell.classList.add('new');
      }
      // 检查是否是合并的块
      if (mergedTiles.some(tile => tile.x === i && tile.y === j)) {
        cell.classList.add('merged');
      }
    }
  }
  // 清空动画标记
  setTimeout(() => {
    newTiles = [];
    mergedTiles = [];
  }, 200);
}

function updateScore() {
  document.getElementById('score-value').textContent = score;
}

function updateStatus(message) {
  document.getElementById('status').innerHTML = message;
}

function slideAndMerge(array, rowIndex, direction) {
  let filtered = array.filter(val => val !== 0);
  let newArray = [];
  let merged = false;
  for (let val of filtered) {
    if (newArray.length > 0 && newArray[newArray.length - 1] === val && !merged) {
      newArray[newArray.length - 1] *= 2;
      score += newArray[newArray.length - 1];
      let pos;
      if (direction === 'left') {
        pos = {x: rowIndex, y: newArray.length - 1};
      } else if (direction === 'right') {
        pos = {x: rowIndex, y: 3 - (newArray.length - 1)};
      } else if (direction === 'up') {
        pos = {x: newArray.length - 1, y: rowIndex};
      } else if (direction === 'down') {
        pos = {x: 3 - (newArray.length - 1), y: rowIndex};
      }
      mergedTiles.push(pos);
      merged = true;
    } else {
      newArray.push(val);
      merged = false;
    }
  }
  while (newArray.length < 4) newArray.push(0);
  return newArray;
}

function move(direction) {
  // 停止之前的动画
  document.querySelectorAll('.cell.new, .cell.merged').forEach(cell => {
    cell.classList.remove('new', 'merged');
  });
  newTiles = [];
  mergedTiles = [];
  let originalGrid = JSON.parse(JSON.stringify(grid));
  let newGrid = JSON.parse(JSON.stringify(grid));
  let moved = false;

  switch(direction) {
    case 'left':
      for (let i = 0; i < 4; i++) {
        newGrid[i] = slideAndMerge(newGrid[i], i, 'left');
      }
      break;
    case 'right':
      for (let i = 0; i < 4; i++) {
        newGrid[i].reverse();
        newGrid[i] = slideAndMerge(newGrid[i], i, 'right');
        newGrid[i].reverse();
      }
      break;
    case 'up':
      for (let j = 0; j < 4; j++) {
        let col = [];
        for (let i = 0; i < 4; i++) col.push(newGrid[i][j]);
        col = slideAndMerge(col, j, 'up');
        for (let i = 0; i < 4; i++) newGrid[i][j] = col[i];
      }
      break;
    case 'down':
      for (let j = 0; j < 4; j++) {
        let col = [];
        for (let i = 0; i < 4; i++) col.push(newGrid[i][j]);
        col.reverse();
        col = slideAndMerge(col, j, 'down');
        col.reverse();
        for (let i = 0; i < 4; i++) newGrid[i][j] = col[i];
      }
      break;
  }

  if (JSON.stringify(originalGrid) !== JSON.stringify(newGrid)) {
    moved = true;
  }

  if (moved) {
    grid = newGrid;
    addRandomTile();
    renderGrid();
    updateScore();
    saveGame();
    if (checkWin() && !hasWon) {
      hasWon = true;
      animating = true;
      setTimeout(() => {
        updateStatus('已获胜，可继续');
        alert('恭喜！你达到了2048！分数：' + score);
        animating = false;
      }, 200);
    } else if (isGameOver()) {
      animating = true;
      setTimeout(() => {
        updateStatus('游戏结束，请重新开始');
        alert('游戏结束！分数：' + score);
        animating = false;
      }, 200);
    }

  }
}

function checkWin() {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 2048) return true;
    }
  }
  return false;
}

function isGameOver() {
  for (let i = 0; i < 4; i++) {
    for (let j = 0; j < 4; j++) {
      if (grid[i][j] === 0) return false;
      if (j < 3 && grid[i][j] === grid[i][j + 1]) return false;
      if (i < 3 && grid[i][j] === grid[i + 1][j]) return false;
    }
  }
  return true;
}

document.getElementById('up').addEventListener('click', () => move('up'));
document.getElementById('left').addEventListener('click', () => move('left'));
document.getElementById('right').addEventListener('click', () => move('right'));
document.getElementById('down').addEventListener('click', () => move('down'));
document.getElementById('restart').addEventListener('click', () => {
  localStorage.removeItem('game2048');
  initGrid();
});

// 键盘控制
const gameContainer = document.getElementById('game-container');
gameContainer.addEventListener('keydown', (e) => {
  const keyMap = {
    'ArrowUp': 'up',
    'ArrowLeft': 'left',
    'ArrowRight': 'right',
    'ArrowDown': 'down',
    'KeyW': 'up',
    'KeyA': 'left',
    'KeyS': 'down',
    'KeyD': 'right'
  };
  if (keyMap[e.code]) {
    e.preventDefault();
    move(keyMap[e.code]);
  }
});

initGrid();
</script>
]]></content>
      <categories>
        <category>Life_生活</category>
      </categories>
  </entry>
  <entry>
    <title>C++引用</title>
    <url>/posts/101de459.html</url>
    <content><![CDATA[<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本篇介绍C++相比于C语言特有的引用语法，包含c++11特性。<br><span id="more"></span></p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>在C++11前，只有一种引用，那就是左值引用。在C++11中新加入了右值引用并且添加了许多实用的新特性。</p>
<ul>
<li>在该小标题下指的引用均为左值引用</li>
</ul>
<hr>
<p>引用变量是一个别名，也就是说，它是某个已存在变量的<strong>另一个名字</strong>。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">321.0</span>;</span><br><span class="line"><span class="type">int</span>&amp;  r = i;</span><br><span class="line"><span class="type">double</span>&amp; s = d;</span><br><span class="line"><span class="comment">//创建了两个引用，即别名</span></span><br></pre></td></tr></table></figure>
<p>引用其实本身的类型等价于<code>const typename *</code><br>这就导致了它有如下的特点：</p>
<ul>
<li>一个变量可取多个别名。</li>
<li>引用必须初始化。</li>
<li>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量。</li>
</ul>
<p>每次调用左值引用其实都<strong>暗含了一步取地址</strong>的过程<br>因为左值引用本质上<strong>存储的是地址</strong>，着意味着可以把<strong>引用当成是一种特殊的指针</strong>，但并不是说其本质就是指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 经典例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 x 赋值给 y  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回左值引用的函数可以作为左值</strong>，但引用可以看作指针，故而要<strong>当心引用空悬</strong>的问题，例子如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">       <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//返回左值引用的函数作为左值</span></span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="值传递和引用传递的差别"><a href="#值传递和引用传递的差别" class="headerlink" title="值传递和引用传递的差别"></a>值传递和引用传递的差别</h2><p>值传递是指参数列表里的类型不是引用的，在这种情况下，如果类型是类的话，其实在传递参数时是会调用拷贝构造，而引用在传递参数的时候则不会。</p>
<p>因而拷贝构造函数不能使用值传递，若拷贝构造函数采用传值传参，用<code>date1</code>去初始化<code>date2</code>，会调用<code>Date (Date d)</code>，当<code>Date d = date1</code>时，相当于<code>Date d (d1)</code>，此时又会调用拷贝构造函数，如此循环导致无穷递归。</p>
<hr>
<h2 id="左值-amp-右值"><a href="#左值-amp-右值" class="headerlink" title="左值&amp;右值"></a>左值&amp;右值</h2><p>也许上面的左值引用完全不怎么需要在意左值右值的差别，但要想进一步区分左值引用和右值引用之间的差别，必须先了解C++11中左右值，将亡值的区分</p>
<ul>
<li>C++11中将右值拓展为 <strong>纯右值 <em>(prvalue)</em></strong> 和 <strong>将亡值 <em>(xvalue)</em></strong><ul>
<li><strong>纯右值</strong>：非引用返回的临时变量，运算表达式的结果，字面常量</li>
<li><strong>字符串字面量</strong>是左值，而且是不可被更改的左值。字符串字面量并不具名，但是可以用&amp;取地址所以也是左值。<br><strong>(a+1)，a为int[10]</strong>，这种状态下也是左值<br><strong>返回左值引用的函数</strong>可以作为左值</li>
<li><strong>将亡值</strong>：与右值引用相关的表达式 如：将要被移动的对象，<code>T&amp;&amp;</code>函数返回的值，<code>std::move()</code>的返回值，转换成<code>T&amp;&amp;</code>的类型的转换函数的返回值</li>
</ul>
</li>
</ul>
<p>左值右值判断方法精简：</p>
<ul>
<li>如果你可以对一个表达式取地址，那这个表达式就是个左值。</li>
<li>如果一个表达式的类型是一个左值引用 (例如, <code>T&amp;</code> 或 <code>const T&amp;</code>, 等.)，那这个表达式就是一个左值。如:返回左值引用的函数</li>
<li>其它情况，这个表达式就是一个右值。从概念上来讲(通常实际上也是这样)，右值对应于临时对象，例如函数返回值或者通过隐式类型转换得到的对象，大部分字面值(e.g.<code>10</code>和<code>5.3</code>)也是右值。</li>
</ul>
<hr>
<h2 id="右值引用-rvalue-reference"><a href="#右值引用-rvalue-reference" class="headerlink" title="右值引用 (rvalue reference)"></a>右值引用 <em>(rvalue reference)</em></h2><p>C++11中增加右值引用，在C++98中的引用都称为<strong>左值引用 (lvalue reference)</strong><br>右值引用就是给右值取别名，新名字就是左值。如果一个prvalue被绑定到一个引用上，它的<strong>生命周期则会延长到跟这个引用变量一样长</strong>。也正因为如此，右值引用不用担心引用空悬的问题。(反正你也解绑不了，寿命延长了我也杀不掉你)<br>右值引用本身是不可修改绑定的左值，但<strong>可以通过它修改右值</strong><br>右值引用本身也仍然是一个指针，只是指向的值是匿名的罢了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov   dword ptr [rbp+0A4h],0Ah</span><br><span class="line">lea   rax,[rbp+0A4h]</span><br><span class="line">mov   qword ptr [c],rax</span><br></pre></td></tr></table></figure><br>这里在语法中所谓不能寻址的右值，它的位置其实也是栈上(rbp+0A4h)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">10</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = num;<span class="comment">//错误，左值不能赋给右值引用</span></span><br><span class="line">c+=<span class="number">1</span>; <span class="comment">//正确，右值10变为11</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="常量左值引用-const-lvalue-reference"><a href="#常量左值引用-const-lvalue-reference" class="headerlink" title="常量左值引用 (const lvalue reference)"></a>常量左值引用 <em>(const lvalue reference)</em></h2><ul>
<li>常量左值引用，可以绑定左值和右值，但不能更改引用的值，<strong>常量左值引用</strong>绑定右值时如同右值引用，也可以<strong>延长右值的生命周期</strong>与自身相同。可以把绑定右值的常量左值引用看作不可修改<code>其绑定的右值</code>的右值引用。(注意一下语序)</li>
<li>非常量左值引用只能绑定左值，右值引用只能绑定右值。</li>
<li>常量右值引用目前暂无作用。据我测试就是个只能传入右值的常量左值引用。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;              <span class="comment">//非常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a1=<span class="number">10</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a2=<span class="number">20</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="comment">//非常量左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;b1=a;            <span class="comment">//正确，a是一个非常量左值，可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b2=a1;           <span class="comment">//错误,a1是一个常量左值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b3=<span class="number">10</span>;           <span class="comment">//错误，10是一个非常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b4=a1+a2;        <span class="comment">//错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="comment">//常量左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c1=a;      <span class="comment">//正确，a是一个非常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c2=a1;     <span class="comment">//正确,a1是一个常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c3=a+a1;   <span class="comment">//正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c4=a1+a2;  <span class="comment">//正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="当函数和引用打架的时候-误"><a href="#当函数和引用打架的时候-误" class="headerlink" title="当函数和引用打架的时候(误)"></a>当函数和引用打架的时候(误)</h2><p>引用之所以难，因为其与许多东西扯上了关系，模板，传参等等。<br>直接开始把<em>移动语义</em>，<em>完美转发</em>，<em>万能引用</em>分开来看比较分立，我也是看的头疼，如果从函数角度入手，叙述这些概念会更清晰些。</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>返回一般简单类型或者返回类类型的函数，如<code>int fun1(int a)</code>或者<code>char* fun2()</code>这种函数，返回值为纯右值</li>
<li>返回值为左值引用的函数，上方讨论过，返回值为左值。</li>
<li>返回值为右值引用的函数，返回值为将亡值</li>
</ul>
<p>对于<strong>底层</strong>来说，无论是用右值引用还是普通变量保存返回值，最终在函数返回时都是通过eax寄存器保存的。区别在于：</p>
<ul>
<li>普通变量：就直接将eax赋值给普通变量</li>
<li>右值引用：就将eax的值放到另一个位置（临时变量），然后再将这个位置的地址赋值到右值引用上。</li>
<li>常量左值引用： 和右值引用是一样的效果，只是常量左值引用就不可以修改这个临时变量而已<br>（所以函数返回值的临时变量不是一直存在的，要看返回时用什么类型的变量来接收）</li>
</ul>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>正如正常的函数一般，函数可以被重载为如参数分别为<code>int&amp; a</code> <code>int&amp;&amp; a</code>,那样将会对左右值属性不同的参数编译器调用不同的函数。</p>
<h2 id="移动语义-std-move"><a href="#移动语义-std-move" class="headerlink" title="移动语义 std::move()"></a>移动语义 <code>std::move()</code></h2><p>首先来讲讲我们为什么需要移动语义，很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。<br>这时候会出现的情况是，我们首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。<br>如果我们可以直接把这个右值变量移动到这个成员变量而不需要做一个额外的复制行为，程序性能就这样提高了。<br>而这些操作正是通过右值引用这个类型的诞生，才使得拷贝和移动语义的分离。<br>可以说引入右值引用的目的就是为了引入移动语义。</p>
<ul>
<li>拷贝堆区对象需要重写拷贝构造函数和赋值函数，实现深拷贝</li>
<li>如果堆区源对象是临时对象（右值），深拷贝会造成无意义的内存申请和释放操作</li>
<li>C++11的移动语义可以直接使用源对象，可以提高效率。</li>
</ul>
<p>例如把指针指向已经生成的堆区上对象，把传入参数的指针设置为nullptr，这样就可以减少无谓的new与delete，减少拷贝花费的时间。</p>
<p>移动语义需要的两个函数</p>
<ul>
<li>移动构造函数<br><code>className(className&amp;&amp; object) &#123;&#125;</code></li>
<li>移动赋值函数<br><code>className&amp; operator=(className&amp;&amp; object) &#123;&#125;</code></li>
</ul>
<p>举个例子<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//特别注意，这里有可能会导致内存泄漏，实际应用需要改写析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">demo&amp;&amp; <span class="title">new_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   demo a = <span class="keyword">new</span> <span class="built_in">demo</span>();</span><br><span class="line">   demo&amp;&amp; b = a;</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里<code>get_demo()</code>返回纯右值，被移动构造函数捕获。<br><strong>output</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">construct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">class destruct!</span><br></pre></td></tr></table></figure></p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h2><p>可以将左值变为右值的函数，用于左值的移动语义。<br>我们可以用std::move实现高效的swap函数<br>在不使用 Move 语义的情况下<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">swap</span>(A &amp;a1, A &amp;a2)&#123;</span><br><span class="line">    <span class="function">A <span class="title">tmp</span><span class="params">(a1)</span></span>; <span class="comment">// 拷贝构造函数一次，涉及大量数据的拷贝</span></span><br><span class="line">    a1 = a2;   <span class="comment">// 拷贝赋值函数调用，涉及大量数据的拷贝</span></span><br><span class="line">    a2 = tmp;  <span class="comment">// 拷贝赋值函数调用，涉及大量数据的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果使用Move语义，即加上移动构造函数和移动赋值函数：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_A</span><span class="params">(A &amp;a1, A &amp;a2)</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">tmp</span><span class="params">(std::move(a1))</span></span>; <span class="comment">// a1 转为右值，移动构造函数调用，低成本</span></span><br><span class="line">    a1 = std::<span class="built_in">move</span>(a2);   <span class="comment">// a2 转为右值，移动赋值函数调用，低成本</span></span><br><span class="line">    a2 = std::<span class="built_in">move</span>(tmp);  <span class="comment">// tmp 转为右值移动给a2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="引用折叠-reference-collapsing"><a href="#引用折叠-reference-collapsing" class="headerlink" title="引用折叠 (reference collapsing)"></a>引用折叠 <em>(reference collapsing)</em></h2><p>引用折叠是指在<strong>模板</strong>函数进行类型推导的时候，发生的编译器解决矛盾的事件，而这个矛盾就是推导得到了引用的引用，这在是C++不被允许的。<br>引用折叠发生在函数和模板参数传递的过程中。另外，由于编译器优化的存在使得特定条件下非引用对象会自动转换为引用对象。<br>下面是一个小例子：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意在参数传递的时候由于传递的是引用，其实是不会引起复制的，值传递的话是会引起复制的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp; a)</span></span>;</span><br><span class="line">std::string&amp; str = std::<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">fun</span>(str);</span><br></pre></td></tr></table></figure><br>上面代码中实参str的类型为std::string&amp;, 形参a被标记为<code>std::string &amp; const &amp;</code> = <code>const std::string&amp;</code><br>具体的折叠规则如下</p>
<blockquote>
<p>T&amp;&amp; &amp;&amp;  -&gt; T&amp;&amp;<br> T&amp;&amp; &amp;   -&gt; T&amp;<br> T&amp; &amp;&amp;   -&gt; T&amp;<br> T&amp; &amp;    -&gt; T&amp;</p>
</blockquote>
<p>即左值引用具有传染性，右值引用是万能引用。<br>万能引用指可以接受一切引用非引用形式的参数。<br>而前者则不能传递纯右值，将亡值<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 <code>std::forward</code></h2><p>在函数模板中，可以将自己的参数“完美地”转发给其他函数，即准确转发参数的值和左右值属性</p>
<ul>
<li>能否实现完美转发，决定了该参数在传递过程中用的是拷贝语义还是移动语义</li>
</ul>
<p>以下实现方式中，<code>func2()</code>可以调用两个重载版本，<code>func1()</code>无法调用rvalue重载版本<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;         <span class="comment">// 参数为lvalue</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;          <span class="comment">// 参数为lvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">func2</span>(i);                   <span class="comment">// 调用lvalue</span></span><br><span class="line">  <span class="built_in">func2</span>(<span class="number">8</span>);                   <span class="comment">// 调用rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>output</strong><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvalue</span><br><span class="line">lvalue</span><br></pre></td></tr></table></figure><br>怎么解决<code>func2</code>无法调用重载版本的问题呢</p>
<ul>
<li><p>在<code>func2(int&amp;&amp; i)</code>中添加<code>std::move()</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(std::<span class="built_in">move</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>func2()</code>改成模板参数写法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp; i)</span> </span>&#123;            <span class="comment">// 参数为lvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp;&amp; i)</span> </span>&#123;           <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(std::<span class="built_in">move</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C++11支持完美转发，提供以下方案<ul>
<li>如果类模板中（包括类模板和函数模板）函数的参数为<code>T&amp;&amp;</code>类型，则为万能引用（既可以接受左值引用，又可以接受右值引用）</li>
<li>提供模板函数<code>std::forward&lt;T&gt;()</code>，用于转发参数，转发后保留参数的左右值类型<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">func1</span>(std::forward&lt;T&gt;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">func</span>(i);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>output</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>51单片机初步印象</title>
    <url>/posts/69d698d4.html</url>
    <content><![CDATA[<h1 id="51单片机初步印象"><a href="#51单片机初步印象" class="headerlink" title="51单片机初步印象"></a>51单片机初步印象</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为前段时间都在搞CS相关的，说实话已经开始有有点后悔了，早知道电子相关的东西也要同步进行的，现在感觉有些事情就因为当时的一步走错拖累了整体的进程，说实话今年上半年的计划被打乱了不少<br>51单片机买的时间很早，但是整体用的并不多，拖到现在才开始写这篇文档。而且以下均是一些零碎的知识点<br><span id="more"></span></p>
<h2 id="关于51单片机的中断向量表"><a href="#关于51单片机的中断向量表" class="headerlink" title="关于51单片机的中断向量表"></a>关于51单片机的中断向量表</h2><p>对于51单片机来说，中断向量表的映射已经写死在了内置的ROM中，直接<code>org &lt;address&gt;</code>写入中断函数跳转地址就可以使用中断，而stm32则可以支持用户修改中断向量表</p>
<h2 id="关于C51的语法障碍"><a href="#关于C51的语法障碍" class="headerlink" title="关于C51的语法障碍"></a>关于C51的语法障碍</h2><p>C51编程语言相比于C语言新添加了四种数据类型，<code>bit</code>，<code>sbit</code>等等，其中有些引脚对应的名称<code>P2^1</code>(P2.1管脚)，一开始我只是以为C51中把<code>^</code>当做名称的一部分，但vscode会把它当做异或运算符，所以vscode会爆红</p>
<p>后来发现问题没有那么简单</p>
<p><code>sft</code>，<code>sbit</code>这种东西的语法似乎是<strong>特殊的</strong>，<strong>不符合语义</strong>的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sfr P1 = <span class="number">0x90</span>;</span><br></pre></td></tr></table></figure><br>在这句语句之后，是把<code>P1</code>看作<code>0x90</code>处的8位寄存器，要想修改这个寄存器里的值<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1 =<span class="number">0xff</span>;</span><br></pre></td></tr></table></figure><br>此刻<code>P1</code>在声明时是<strong>地址</strong>，但修改时又赋值为<strong>数值</strong><br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit P1_1 = P1^<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>这一句话就更加显得奇怪，为什么这里<code>P1</code>为<strong>地址</strong>而不是<strong>数值</strong>呢，就感觉是狗皮膏药打了个补丁，不过既然它已经被广泛应用了，就直接当做一个特殊情况好了。即<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit P1_1 = P1^<span class="number">1</span>;</span><br></pre></td></tr></table></figure><br>类似这样的<strong>特殊声明</strong>会自动修改等号后^的意义，此时不应该再是异或，而是特殊的引脚号的记号，在声明时候的<strong>特殊定义</strong>下，这些P1也是被特殊化为地址。</p>
<p>只能这样解释这种行为了，这个语义问题也是引起vscode报错的根本原因吧，所以不管怎么改，怎么样把它看成<strong>typedef的嵌套</strong>都会爆红(悲)</p>
<p>也许这就是为什么周围的人入门都选择的是stm32的原因吧，一来可以使用更优秀的文本编辑器，又不会引起语法上的误解，还能有更强大的功能</p>
<h2 id="关于VCC、GND的符号"><a href="#关于VCC、GND的符号" class="headerlink" title="关于VCC、GND的符号"></a>关于VCC、GND的符号</h2><p>在电路里，VCC代表电源正极，而GND是逻辑上的接地，其实不一定接地，它是电源负极,直观感受，看上去VCC和GND其实是唯一的？VCC只在中间起供能和”比较”的作用，或者一切的开头起功能作用，端口有一系列的保护措施使得最后电平不易被改写？<br>除了VCC，GND另外的似乎也就是可以<strong>看作</strong>特殊情况下的VCC和GND？现在也只能够这样粗浅的理解了</p>
<h2 id="关于51单片机的GPIO"><a href="#关于51单片机的GPIO" class="headerlink" title="关于51单片机的GPIO"></a>关于51单片机的GPIO</h2><p>GPIO，对于上图所示的准标准输入输出，和51单片机是一致的，其输出时候是利用了锁存器的功能，锁死了电位，而对于输入的时候，是不写入锁存器的，将锁存器写入1，才能读取，这里用的上拉电阻是默认它那个点位是高电位，但是如果直接连接地的话就可以是低电位了</p>
]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>单片机</category>
      </categories>
  </entry>
  <entry>
    <title>C++模板元-欧拉函数表</title>
    <url>/posts/acc766b1.html</url>
    <content><![CDATA[<h1 id="C-模板元-欧拉函数表"><a href="#C-模板元-欧拉函数表" class="headerlink" title="C++模板元-欧拉函数表"></a>C++模板元-欧拉函数表</h1><p>SAST 2023 C++组免试题之模板元编程部分，本身是一个小玩具，不具有多少实际意义<br><span id="more"></span></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">eulerFunction</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = ans / i * (i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        ans = ans / n * (n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">function2List</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> length = <span class="keyword">sizeof</span>...(pack);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> value[<span class="keyword">sizeof</span>...(pack)] = &#123;<span class="built_in">eulerFunction</span>(pack)...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title">log2_func</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;&gt;= <span class="number">1</span>)</span><br><span class="line">        ++ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="keyword">typename</span> T, <span class="type">unsigned</span> <span class="type">int</span> temp, <span class="type">unsigned</span> <span class="type">int</span> MAX, <span class="type">unsigned</span> <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">generatorList</span> : generatorList&lt;N, <span class="type">void</span>, temp - <span class="number">1</span>, <span class="number">2</span> * MAX, pack..., (pack + MAX)...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="type">unsigned</span> <span class="type">int</span> temp, <span class="type">unsigned</span> <span class="type">int</span> MAX, <span class="type">unsigned</span> <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">generatorList</span>&lt;N, std::<span class="type">enable_if_t</span>&lt;(N &gt;&gt; (temp - <span class="number">1</span>)) % <span class="number">2</span>, <span class="type">void</span>&gt;, temp, MAX, pack...&gt; : generatorList&lt;N, <span class="type">void</span>, temp - <span class="number">1</span>, <span class="number">2</span> * MAX + <span class="number">1</span>, <span class="number">1</span>, (pack + <span class="number">1</span>)..., (pack + MAX + <span class="number">1</span>)...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N, <span class="type">unsigned</span> <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">generatorList</span>&lt;N, <span class="type">void</span>, <span class="number">0</span>, N, pack...&gt; : function2List&lt;pack...&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">unsigned</span> <span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">EulerFunctionList</span> : generatorList&lt;N, <span class="type">void</span>, <span class="built_in">log2_func</span>(N) + <span class="number">1</span>, <span class="number">0</span>&gt; &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">unsigned</span> <span class="type">int</span> N = <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; EulerFunctionList&lt;N&gt;::length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; EulerFunctionList&lt;N&gt;::value[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>这里<code>eulerFunction</code>函数为C++17的<code>constexpr</code>函数，可以在编译器执行并获取到输入值的欧拉函数</p>
<p>模板递归部分利用了形参包的多次展开，做到二分法的序列生成，大大提高了自然数序列生成的效率，减少了模板迭代的次数，可以有效的在编译器默认允许的范围内打出更大的值</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++模板元-质数序列</title>
    <url>/posts/3187765d.html</url>
    <content><![CDATA[<h1 id="C-模板元-质数序列"><a href="#C-模板元-质数序列" class="headerlink" title="C++模板元-质数序列"></a>C++模板元-质数序列</h1><p>花了一点时间巩固自己的模板元编程，写了一个编译期质数数组生成器<br><span id="more"></span></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> b&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bool_instant</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_instant = bool_instant&lt;<span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_instant = bool_instant&lt;<span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">intArrayPack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> length = <span class="keyword">sizeof</span>...(pack);</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value[<span class="keyword">sizeof</span>...(pack)] = &#123;pack...&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span> current = <span class="number">2</span>, <span class="type">int</span> flag = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> isPrime : isPrime&lt;N, current + <span class="number">1</span>, !!!(N % current)&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isPrime</span>&lt;N, N, <span class="number">0</span>&gt; : true_instant&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span> current&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">isPrime</span>&lt;N, current, <span class="number">1</span>&gt; : false_instant&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span> current = <span class="number">2</span>, <span class="type">bool</span> flag = <span class="literal">false</span>, <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> primePack : primePack&lt;N, current + <span class="number">1</span>, isPrime&lt;current&gt;::value, pack...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span> current, <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">primePack</span>&lt;N, current, <span class="literal">true</span>, pack...&gt; : primePack&lt;N, current, <span class="literal">false</span>, current - <span class="number">1</span>, pack...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N, <span class="type">int</span>... pack&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">primePack</span>&lt;N, N, <span class="literal">false</span>, pack...&gt; : intArrayPack&lt;pack...&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> numlist = primePack&lt;<span class="number">220</span>&gt;::value;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; primePack&lt;<span class="number">220</span>&gt;::length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; numlist[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="讲解"><a href="#讲解" class="headerlink" title="讲解"></a>讲解</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">primePack&lt;<span class="number">220</span>&gt;::value</span><br></pre></td></tr></table></figure>
<p>输出<strong>小于</strong>输入数字的所有质数组成的数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">primePack&lt;<span class="number">220</span>&gt;::length</span><br></pre></td></tr></table></figure>
<p>输出上述数组的长度</p>
<p>重要的是<code>intArrayPack</code>这种通过形参包生成对应序列的方法，以及<code>primePack</code>这种通过<code>true</code>和<code>false</code>，利用模板特化进行<code>if</code>的模式</p>
<p>本身代码在<code>MSVC for amd64</code>最大只能输出到227的质数，在之后就会报错，原因是<strong>模板递归超过上限</strong>，因而代码仍需要优化，但作为一个练手的，第一次写模板元编程，也挺不错的</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++模板元编程</title>
    <url>/posts/9244e40f.html</url>
    <content><![CDATA[<h1 id="C-模板元编程"><a href="#C-模板元编程" class="headerlink" title="C++模板元编程"></a>C++模板元编程</h1><p>之前看到一个说法，说正常用模板就是模板编程，神神叨叨用模板就是模板元编程，我深以为然，但是模板这东西他提供的编译期运算太过于强大，而且STL里面的内容大量的用到了模板，我觉得我还是有必要写一写东西的。</p>
<span id="more"></span>
<h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>推荐一个<a href="https://zhuanlan.zhihu.com/p/378355217">知乎链接</a>，作者的讲述非常优秀<br>模板元编程是一个庞大的课题，我打算慢慢写它</p>
<h2 id="一些零碎的理解"><a href="#一些零碎的理解" class="headerlink" title="一些零碎的理解"></a>一些零碎的理解</h2><p>由于本人也学艺不精，所以这个板块先写一些临时的感悟啥的，以及学习时候使用的一些例子</p>
<h3 id="std-enable-if的一种用法"><a href="#std-enable-if的一种用法" class="headerlink" title="std::enable_if的一种用法"></a>std::enable_if的一种用法</h3><p>学习时候用到测试代码如下<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> N = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">test</span>&lt;T, std::<span class="type">enable_if_t</span>&lt;std::is_same_v&lt;T, <span class="type">int</span>&gt;, <span class="type">void</span>&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; test&lt;<span class="type">int</span>&gt;::value;<span class="comment">//1</span></span><br><span class="line">    std::cout &lt;&lt; test&lt;<span class="type">char</span>&gt;::value;<span class="comment">//0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过一个迂回的方式来判断一个类型是不是int类型，当然我只是想叙述<code>std::enable_if</code>应该怎么用，这个模板是输入两个参数，第一个是<code>bool</code>类型，第二个是当输入<code>true</code>时，其<code>type</code>是什么类型，由于<code>std::enable_if</code>所返回的类型任意，且利用偏特化进行分支选择时，其主模板，和<code>std::enable_if</code>所处同样位置必须时模板<code>typename T</code>，且由于一般不会写上<code>enable_if</code>这一个位置的类型，主模板必须缺省，缺省<code>void</code>就是一个好选择</p>
<p>注意特化和函数的默认参数不同，可以特化任意位置的参数，如我们可以特化如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyTemplateType</span>&lt;<span class="type">float</span>, N&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//content</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>利用上述特化的性质，<code>enable_if</code>可以塞在模板参数中间，但以我之见，在其等价位置的后方应该只存在形参包或者有缺省值的模板参数</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++模板基础</title>
    <url>/posts/cabf03c1.html</url>
    <content><![CDATA[<h1 id="C-模板基础"><a href="#C-模板基础" class="headerlink" title="C++模板基础"></a>C++模板基础</h1><p>为了我们能在接下来书写模板元编程前有一个良好的基础，我们必须先得了解C++模板的相关内容</p>
<span id="more"></span>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p>Cppreference: <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5</a><br>知乎文章: <a href="https://zhuanlan.zhihu.com/p/378355217">https://zhuanlan.zhihu.com/p/378355217</a></p>
<h2 id="TMP的简单介绍"><a href="#TMP的简单介绍" class="headerlink" title="TMP的简单介绍"></a>TMP的简单介绍</h2><p>在上世纪末，C++模板就被发现是图灵完备的，当时就有大佬利用编译器的报错，在编译器的输出里生成了质数序列</p>
<p>模板元编程，简称TMP，对于元编程的解释要从元程序来说</p>
<blockquote>
<p><strong>NOTE</strong>: Metaprogram is a program about a program.</p>
</blockquote>
<p>元程序是处理程序的程序，而元编程就是编写元程序的一种编程技巧。Python解释器就是一种元程序</p>
<p>C++模板元编程属于元编程中的一种(Metaprogramming in Host Language)，在这类元编程中，逻辑代码和元程序自身的代码是写在一起的，用同一种语言，元程序代码通过某种机制(通常是编译)转变为(或者说生成)逻辑代码，并与其他逻辑代码合并到一起。这就产生一种效果，这个元程序看起来像是在自己改写自己。C++TMP的代码与普通的C++代码写在一起，但TMP的逻辑在编译期执行，而普通C++代码的逻辑在运行期执行。</p>
<p>所以说C++TMP是用于一些编译期的运算，类型的计算，也能进一步美化代码，甚至是效率更高的编译期多态。</p>
<p>C++模板元和宏搭配起来可以被称为是黑魔法，但是缺点也很明显，只能对编译期起到作用，而且缺少debug的工具，debug异常困难</p>
<h2 id="模板的声明与定义"><a href="#模板的声明与定义" class="headerlink" title="模板的声明与定义"></a>模板的声明与定义</h2><p><img src="/images/C++模板基础_图1.png" width="100%" height="100%"><br>(上图摘自cppreference)</p>
<p>在C++中，我们一共可以声明5种不同的模板，分别是：<strong>类模板、函数模板</strong>、<strong>变量模板(C++14)</strong>、<strong>别名模板(C++11)</strong>和<strong>Concept(C++20)</strong></p>
<p>特别提醒，Concept作为较新的特性，放到最后我们再来说说</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// declarations</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span>  <span class="title class_">class_tmpl</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span>    <span class="title">function_tmpl</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T       variable_tmpl;          <span class="comment">// since c++14</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span>   alias_tmpl = T;         <span class="comment">// since c++11</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> no_constraint = <span class="literal">true</span>;   <span class="comment">// since c++20</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>INFO</strong>: 可以看到关键的东西已经接触到了C++11，这倒不是说较旧的C++不能实现模板元，只是一般来说这些东西都会在相对来说modern cpp来进行</p>
</blockquote>
<p>对于前三种模板可以拥有定义<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// definitions</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span>  <span class="title class_">class_tmpl</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="type">void</span>    <span class="title">function_tmpl</span><span class="params">(T)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T       variable_tmpl = <span class="built_in">T</span>(<span class="number">3.14</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，对于类模板、函数模板和变量模板，它们的声明和定义与普通的类、函数和变量一致，区别仅是在开头多了一个<code>template</code>关键字以及一对尖括号<code>&lt;...&gt;</code></p>
<p>尖括号中声明了模板的参数。参数通常是类型，因为模板的发明就是为了实现泛型编程。也正是因为如此，模板一开始就不是为了元编程来的，所以它的确很难</p>
<h2 id="模板形参"><a href="#模板形参" class="headerlink" title="模板形参"></a>模板形参</h2><p>在模板中，我们可以声明三种类型的形参，分别是：<strong>非类型模板形参</strong>、<strong>类型模板形参</strong>和<strong>模板模板形参(C++17)</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// There are 3 kinds of template parameters:</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> n&gt;                               <span class="keyword">struct</span> <span class="title class_">NontypeTemplateParameter</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                          <span class="keyword">struct</span> <span class="title class_">TypeTemplateParameter</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span> Tmpl&gt; <span class="keyword">struct</span> <span class="title class_">TemplateTemplateParameter</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，非类型的形参接受一个确定类型的常量作为实参，例如在上面的例子中，模板<code>NontypeTemplateParameter</code>接受一个int类型的常量。更一般地，非类型模板形参必须是结构化类型的，主要包括：</p>
<ul>
<li>整型，如<code>int, char, long</code></li>
<li><code>enum</code>类型</li>
<li>指针和引用类型</li>
<li>浮点数类型和字面量类型(C++20后)</li>
<li>要注意的是，非类型模板实参<strong>必须是常量</strong>，因为模板是在编译期被展开的，在这个阶段只有常量，没有变量。</li>
</ul>
<p>要注意的是，非类型模板实参必须是常量，因为模板是在编译期被展开的，在这个阶段只有常量，没有变量。</p>
<p>对于类型模板形参，我们使用<code>typename</code>/<code>class</code>关键字声明它是一个类型。对于模板模板形参，和类模板的声明类似，也是在类型的前面加上<code>template &lt;...&gt;</code>。模<strong>板模板形参只接受类模板或类的别名模板作为实参，并且实参模板的形参列表必须要与形参模板的形参列表匹配</strong>。要注意的是，关键字<code>typename</code>和<code>class</code>是完全等效的，唯一的不同就是字面语义。</p>
<p>一个模板可以声明多个形参，更一般地，可以声明一个变长的形参列表，变长形参列表可以接受0个或多个非类型常量、类型、或模板作为模板实参。变长形参列表必须出现在所有模板形参的最后。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>... Args&gt;                            <span class="keyword">struct</span> <span class="title class_">VariadicTemplate1</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span>, <span class="keyword">typename</span>... Args&gt;                  <span class="keyword">struct</span> <span class="title class_">VariadicTemplate2</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">typename</span>... Args&gt; <span class="keyword">struct</span> <span class="title class_">VariadicTemplate3</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>模板可以声明默认实参，与函数的默认实参类似。只有主模板才可以声明默认实参，模板特化不可以。<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// default template argument</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt; <span class="keyword">struct</span> TemplateWithDefaultArguments &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="模板实例化"><a href="#模板实例化" class="headerlink" title="模板实例化"></a>模板实例化</h2><p><strong>cppreference</strong>: <a href="https://zh.cppreference.com/w/cpp/language/function_template">https://zh.cppreference.com/w/cpp/language/function_template</a></p>
<p>是指由泛型的模板定义生成具体的类型、函数、和变量的过程。模板在实例化时，模板形参被替换为实参，从而生成具体的实例。<br>模板的实例化分为两种：<strong>隐式实例化</strong>和<strong>显式实例化</strong>，其中的<strong>隐式的实例化</strong>是我们平时最常用的实例化方式<br>采用隐式的实例化时，编译器就会在编译时根据你具体使用模板的类型，用模板生成对应的真正的函数定义，类定义等。</p>
<blockquote>
<p><strong>NOTE</strong>:模板自身并不是类型、函数或任何其他实体。不会从只包含模板定义的源文件生成任何代码。模板只有实例化才会有代码出现</p>
</blockquote>
<p>为了实例化一个模板，编译器需要知道所有的模板实参，但不是每个实参都要显式地指定。有时，编译器可以根据函数调用的实参来推断模板的实参，这一过程被称为<strong>模板实参推导</strong>。对每一个函数实参，编译器都尝试去推导对应的模板实参，如果所有的模板实参都能被推导出来，且推导结果不产生冲突，那么模板实参推导成功。C++17引入了类模板实参推导，可以通过类模板的构造函数来推导模板实参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T s1, T s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">double</span> pi_double = <span class="number">3.14</span>;</span><br><span class="line">  <span class="type">int</span> pi_int = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">f</span>(pi_double, pi_double); </span><br><span class="line">  <span class="built_in">f</span>(pi_int, pi_double); <span class="comment">//error</span></span><br><span class="line">  <span class="built_in">f</span>&lt;<span class="type">double</span>&gt;(pi_int, pi_double);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="模板特化"><a href="#模板特化" class="headerlink" title="模板特化"></a>模板特化</h2><p>模板特化，望文生义，即特殊化模板参数列表中的一部分，使得他在模板实参输入特殊输入的时候，采用特殊化的模板定义，这里涉及到编译器会从所有的特化版本中选择的问题，其中有一套固定的选择的逻辑，利用这一<strong>选择</strong>特性使得它可以实现逻辑判断，甚至做到编译期的图灵完备，具体让我们来看看</p>
<h3 id="部分模板特化-偏特化"><a href="#部分模板特化-偏特化" class="headerlink" title="部分模板特化/偏特化"></a>部分模板特化/偏特化</h3><p><img src="/images/C++模板基础_图2.png" width="100%" height="100%"><br>(上图以及下面的例子摘自cppreference)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>;             <span class="comment">// 主模板</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T, T*, I&gt; &#123;&#125;;   <span class="comment">// #1：部分特化，其中 T2 是指向 T1 的指针</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">T2</span>, <span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;T*, T2, I&gt; &#123;&#125;;  <span class="comment">// #2：部分特化，其中 T1 是指针</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;<span class="type">int</span>, T*, <span class="number">5</span>&gt; &#123;&#125;; <span class="comment">// #3：部分特化，其中 T1 是 int，I 是 5，T2 是指针</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">X</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="type">int</span> I&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&lt;X, T*, I&gt; &#123;&#125;;   <span class="comment">// #4：部分特化，其中 T2 是指针</span></span><br></pre></td></tr></table></figure>
<p>看起来有点复杂对吧，说点人话，我们可以粗略的理解为，在原本的模板上又定义了全新的模板，即上述这个例子，在#1-#4中，我们可以把第一行template盖住，下面看作使用模板，但是我们又把这个使用模板的行为套了一层模板。但这种理解从替换的角度而言是不正确的，但能阐释它的写法了<br>要注意的是，后面这个尖括号里面填的是主模板的实参列表，而外面套的偏特化的形参列表可以随意发挥(当然也有一定的限制，比如偏特化一定要比主模板更特殊等，一共有好几条，具体可以搜索cppreference)，只要能匹配到就行了</p>
<h3 id="显式具体化-模板全特化"><a href="#显式具体化-模板全特化" class="headerlink" title="显式具体化/模板全特化"></a>显式具体化/模板全特化</h3><p>全特化的语法也用人话说就是，当模板中所有的部分全部确定，偏特化到极点，使得<code>template &lt;...&gt;</code>的尖括号里不需要放任何东西，就换了个名字，称为全特化，很形象吧<br>要注意全特化和显式实例化的写法很类似，不要混淆<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Don&#x27;t mix the syntax of &quot;full specialization declaration&quot; up with &quot;explict instantiation&quot;</span></span><br><span class="line"><span class="keyword">template</span>    <span class="type">void</span> foo&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;   <span class="comment">// this is an explict instantiation</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="type">void</span> foo&lt;<span class="type">int</span>, <span class="type">int</span>&gt;;   <span class="comment">// this is a full specialization declaration</span></span><br></pre></td></tr></table></figure></p>
<p>模板的特化允许我们替换一部分或全部的形参，并定义一个对应改替换的模板实现。其中，<strong>替换全部形参的特化称为全特化，替换部分形参的特化称为偏特化</strong>，非特化的原始模板称为主模板。只有类模板和变量模板可以进行偏特化，函数模板只能全特化。<br>在实例化模板的时候，编译器会从所有的特化版本中选择<strong>最匹配的那个实现来做替换</strong>，如果没有特化匹配，那么就会选择主模板进行替换操作。</p>
<blockquote>
<p><strong>INFO</strong>:在这里要另外提一个事情，C++中有部分概念的翻译没有那么的好，就像这里将要提到的全特化，有好几种叫法，比如显式模板特化，还有一种叫法是显式具体化，在我写这份文档的时候也对我产生了一点困惑。其实去各大平台和cppreference搜一搜就会发现，显示具体化就是Explicit specialization这个术语，也就是模板全特化，所以在学习时，还请<strong>中英文结合学习</strong>，当然我本人英语很差，如果各位可以不必借助翻译软件就畅读英文文献，自然是能获得最好的学习体验的</p>
</blockquote>
<h2 id="C-Templates——SFINAE"><a href="#C-Templates——SFINAE" class="headerlink" title="C++ Templates——SFINAE"></a>C++ Templates——SFINAE</h2><p>到了SFINAE正式开始上强度<br>SFINAE是“Substitution failure is not an error.”的缩写。意为替换失败并非一个错误<br>根本方法是利用函数重载和静态行为(static, sizeof，constexpr等，即编译期确定行为)。</p>
<p>怎么理解SFINAE这个东西呢？还记得我们刚刚提到的模板特化有一套选择的方法吧，再想想我们这次SAST笔试题C++组出的题，重点考察了函数重载决议的内容，编译器也会在你调用函数时在所有的函数重载版本中挑选一个最符合的版本进行调用，而这种选择，和存在模板特化的主模板调用时的在众多特化版本中的选择是有异曲同工之妙的，在这些“选择”发生时，如果有一个重载版本或者特化版本选不上的时候，编译器会忽略它，尝试匹配下一个，而不抛出错误</p>
<h2 id="实例化的过程"><a href="#实例化的过程" class="headerlink" title="实例化的过程"></a>实例化的过程</h2><blockquote>
<p><strong>NOTE</strong>: 我觉得这部分是最重要的，C++14前的模板元要想实现复杂的功能，完全利用了泛型模板实现的细节顺序，正如我所说的，模板一开始不是为了元编程所服务的，所以抠顺序的细节去实现“黑魔法”</p>
</blockquote>
<p>整个实例化的过程具体的步骤是这样的，当一个实例化发生时，编译器：</p>
<ol>
<li>进行名字查找，找到所有匹配该名字的模板<ul>
<li>如果是函数模板，可能会找到一个或多个重载</li>
<li>如果是类/变量模板，应找到唯一一个主模板，否则报错:重定义</li>
</ul>
</li>
<li>确定所有的模板实参，需要推导的，通过主模板来推导<ul>
<li>对函数模板，如果推导失败，那么这个模板从重载集中剔除</li>
<li>对类/变量模板，如果推导失败，则抛出错误</li>
</ul>
</li>
<li>对函数模板，进行重载决议，决议时只考虑主模板，偏序规则和SFINAE在此发挥作用</li>
<li>对确定的主模板和它的特化，选择最匹配的那个<ul>
<li>对类/变量模板，因为存在偏特化，偏序规则和 SFINAE 在此发挥作用</li>
<li>对函数模板，只有全特化，直接匹配就行了</li>
</ul>
</li>
<li>对最终选定的主模板或特化进行替换，生成真实代码，放到 POI 中</li>
</ol>
<h2 id="type-traits"><a href="#type-traits" class="headerlink" title="type_traits"></a><code>type_traits</code></h2><p>不知道大家有没有听过<code>type_traits</code>这个标准库，它的译名叫做类型萃取，顾名思义，就是把类型提取出来，其中有许多好东西：<code>std::is_class</code>/<code>std::is_same</code>/<code>std::is_base_of</code>/…，他们其中有许多都是模板元编程的产物，我们挑点简单的例子来看看这些东西是怎么实现的吧</p>
<h3 id="template-is-void-v-lt-gt"><a href="#template-is-void-v-lt-gt" class="headerlink" title="template is_void_v&lt;&gt;"></a>template is_void_v&lt;&gt;</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_void</span>&lt;<span class="type">void</span>&gt;&#123;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> is_void_v = is_void&lt;T&gt;::value;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">is_void_v&lt;<span class="type">int</span>&gt;</span><br></pre></td></tr></table></figure>
<h3 id="template-is-reference-lt-gt"><a href="#template-is-reference-lt-gt" class="headerlink" title="template is_reference&lt;&gt;"></a>template is_reference&lt;&gt;</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_reference</span>      &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>; &#125;;    <span class="comment">// #1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_reference</span>&lt;T&amp;&gt;  &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;     <span class="comment">// #2</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">struct</span> <span class="title class_">is_reference</span>&lt;T&amp;&amp;&gt; &#123; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>; &#125;;     <span class="comment">// #3</span></span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; is_reference&lt;<span class="type">int</span>&gt;::value &lt;&lt; std::endl;    <span class="comment">// 0</span></span><br><span class="line">std::cout &lt;&lt; is_reference&lt;<span class="type">int</span>&amp;&gt;::value &lt;&lt; std::endl;   <span class="comment">// 1</span></span><br><span class="line">std::cout &lt;&lt; is_reference&lt;<span class="type">int</span>&amp;&amp;&gt;::value &lt;&lt; std::endl;  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="is-class"><a href="#is-class" class="headerlink" title="is_class"></a>is_class</h3><p>从前的版本<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_class</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> success [<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">char</span> failure [<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//注意编译器对函数重载的匹配顺序：</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="type">static</span> success&amp; <span class="title">test</span><span class="params">(<span class="type">void</span> U::* p)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="type">static</span> failure&amp; <span class="title">test</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">enum</span> &#123;value = <span class="built_in">sizeof</span>(<span class="built_in">test</span>&lt;T&gt;(<span class="literal">NULL</span>)) == <span class="built_in">sizeof</span>(success)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如今的版本<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_class</span> &#123;</span><br><span class="line">    <span class="comment">//void *不行了</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C&gt; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(<span class="type">int</span> C::* p)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>&gt; <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">test</span><span class="params">(...)</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="built_in">test</span>&lt;T&gt;(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这些只是一个概览，具体的细节留到提高篇针对单一情况具体说明，下次，我们会对更多的代码例子进行导读</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>CSAPP章节二中的数学公式整理</title>
    <url>/posts/f1f78c10.html</url>
    <content><![CDATA[<h1 id="CSAPP章节二中的数学公式整理"><a href="#CSAPP章节二中的数学公式整理" class="headerlink" title="CSAPP章节二中的数学公式整理"></a>CSAPP章节二中的数学公式整理</h1><p>这一章偏向理论，有时候能利用编码知识大大简化计算之类的</p>
<span id="more"></span>
<h2 id="关于这一章的符号说明"><a href="#关于这一章的符号说明" class="headerlink" title="关于这一章的符号说明:"></a><em>关于这一章的符号说明:</em></h2><p><em>注意：当反函数难以直观写出时，将直接省略</em><br><img src="/images/CSAPP章节二中的数学公式整理_图1.png" width="100%" height="100%"></p>
<p><strong>整数部分:</strong></p>
<p><em>1.二进制转反码</em></p>
<script type="math/tex; mode=display">B 2 S_{w}(\vec{x}) \doteq(-1)^{x_{w-1}} \cdot\left(\sum_{i=0}^{w-2} x_{i} 2^{i}\right)</script><p><em>2.二进制转原码</em></p>
<script type="math/tex; mode=display">B2O_{w}(\vec{x}) \doteq-x_{w-1}\left(2^{w-1}-1\right)+\sum_{i=0}^{w-2} x_{i} 2^{i}</script><p><em>3.二进制转补码</em></p>
<p>补码有特殊的数学性质，形成一个自洽的体系，故如今机子几乎都用补码<br>这是一个一一到上的映射，故对应0的向量x不像原码一般对0有两种解释</p>
<script type="math/tex; mode=display">B 2 T_{w}(\vec{x}) \doteq-x_{w-1} 2^{w-1}+\sum_{i=0}^{w-2} x_{i} 2^{i}</script><p><em>4.补码转无符号</em></p>
<p>二进制（向量x）不变的直接编码转化，公式很简单</p>
<script type="math/tex; mode=display">T 2 U_{w}(x) \doteq B 2 U_{w}\left(T 2 B_{w}(x)\right)</script><script type="math/tex; mode=display">T 2 U_{w}(x)=\left\{\begin{array}{ll}
x+2^{w}, & x<0 \\
x, & x \geqslant 0
\end{array}\right.</script><script type="math/tex; mode=display">B 2 U_{w}\left(T 2 B_{w}(x)\right)=T 2 U_{w}(x)=x+x_{w-1} 2^{w}</script><p><em>5.无符号转补码</em></p>
<p>同上，二进制（向量x）不变的直接编码转化</p>
<script type="math/tex; mode=display">U 2 T_{w}(x) \doteq B 2 T_{w}\left(U 2 B_{w}(x)\right)</script><script type="math/tex; mode=display">U 2 T_{w}(u)=\left\{\begin{array}{ll}
u, & u \leqslant \operatorname{TMax}_{w} \\
u-2^{w}, & u>\operatorname{TMax}_{w}
\end{array}\right.</script><p><em>6.二进制转无符号</em></p>
<script type="math/tex; mode=display">B 2 U_{w}(\vec{x}) \doteq \sum_{i=0}^{w-1} x_{i} 2^{i}</script><p><em>7.补码的相关性质（无符号省略）</em></p>
<p>存在有定义域 $[TMin,TMax]$ ,其中满足<br>$\mid \text { TMin }|=| \text { TMax } \mid+1$</p>
<script type="math/tex; mode=display">\operatorname{TMin}_{w}\doteq-2^{w-1}\operatorname\qquad{TMax}_{w} \doteq \sum_{i=0}^{w-2} 2^{i}=2^{w-1}-1</script><p><em>8.整数的扩展</em></p>
<p>无符号零扩展，即直接在二进制下的数字前补零，在16进制下也是补0</p>
<p>补码的符号扩展，即在二进制下补原先符号的数字，若为正数补1，负数补0，在16进制下前者补f后者补0</p>
<p>相关公式</p>
<script type="math/tex; mode=display">B 2 T_{w+k}\left([\underbrace{x_{w-1}, \cdots, x_{u-1}}_{k 个数}, x_{u-1}, x_{w-2}, \cdots, x_{0}]\right)=B 2 T_{w}\left(\left[x_{u-1}, x_{w-2}, \cdots, x_{0}\right]\right)</script><p><em>9.整数的截断数字</em></p>
<ul>
<li><p>无符号<br>这里所谓的截断数字对于二进制来说就单纯是把多出来的高位切掉而已<br>令 $\vec{x}$ 等于位向量 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right] $, 而 $ \vec{x}^{\prime}$ 是将其截断为  k  位的结果: $\vec{x}^{\prime}=\left[x_{k-1}\right.$ , $ \left.x_{k-2}, \cdots, x_{0}\right]_{\text {。 }} $令$ x=B 2 U_{w}(\vec{x}), x^{\prime}=B 2 U_{k}\left(\vec{x}^{\prime}\right) $ 。则 $x^{\prime}=x \bmod 2^{k}$ 。</p>
<script type="math/tex; mode=display">x^{\prime}=x \bmod 2^{k}=x-\sum_{i=k+1}^{w}{x_i}2^{i}</script></li>
<li><p>补码<br>这里所说的截断的定义是借由无符号数的截断，即先转化为对应的无符号数，再进行截断<br>实质上对于二进制来说也是直接的高位截断<br>令 $\vec{x}$ 等于位向量 $\left[x_{w-1}, x_{w-2}, \cdots, x_{0}\right]$ , 而 $\vec{x}^{\prime} $ 是将其截断为  k  位的结果: $\vec{x}^{\prime}=\left[x_{k-1}\right. $ , $ \left.x_{k-2}, \cdots, x_{0}\right]$ 。令 $  x=B 2 U_{w}(\vec{x}), x^{\prime}=B 2 T_{k}\left(\vec{x}^{\prime}\right) $ 。则 $  x^{\prime}=U 2 T_{k}\left(x \bmod 2^{k}\right) $ 。</p>
<script type="math/tex; mode=display">x^{\prime}=U 2 T_{k}\left(x \bmod 2^{k}\right) =B 2 T_{w}(x)-\sum_{i=k+1}^{w-1}{x_i}2^{i}+{x_w}2^{w}-{x_k}2^{k}</script></li>
</ul>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Computer_composition</category>
      </categories>
  </entry>
  <entry>
    <title>CelesteMiaoNet自建群服教程</title>
    <url>/posts/75894d10.html</url>
    <content><![CDATA[<h1 id="CelesteMiaoNet自建群服教程"><a href="#CelesteMiaoNet自建群服教程" class="headerlink" title="CelesteMiaoNet自建群服教程"></a>CelesteMiaoNet自建群服教程</h1><blockquote>
<p>本教程能够帮助你自建喵服群服，此教程发布时间为2025.3.1，请注意教程的时效性</p>
</blockquote>
<span id="more"></span>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>你需要对基本的服务器运维有一些了解，本教程不负责教学服务器基本运维，可以自行搜寻资料<br>你需要有一台 Windows 为系统的设备用来编译喵服(Linux/MacOS 可能亦可，但 Windows 能保证可行)<br>其次你需要一个拥有公网IP的服务器，你可以选择常见的云服务器 ECS </p>
<h2 id="下载-NET-编译工具"><a href="#下载-NET-编译工具" class="headerlink" title="下载 .NET 编译工具"></a>下载 .NET 编译工具</h2><p>前往微软官方，选择合适的 .NET 版本下载 <strong>SDK</strong><br><a href="https://dotnet.microsoft.com/zh-cn/download/dotnet">https://dotnet.microsoft.com/zh-cn/download/dotnet</a></p>
<p>注意 Everest 使用的版本是 .NET 7.0，尽管目前这已经是一个不被支持的版本，但你可以仍然可以使用它</p>
<p>选取 <code>x64</code> ，即可开始下载<br><img src="/images/CelesteMiaoNet自建群服教程_图1.png" width="100%" height="100%"></p>
<p>下载完毕后，直接运行就可以安装编译工具</p>
<h2 id="下载喵服仓库"><a href="#下载喵服仓库" class="headerlink" title="下载喵服仓库"></a>下载喵服仓库</h2><p>到喵服 Github 官网<br><a href="https://github.com/CelesteNyaServer/CelesteNet">https://github.com/CelesteNyaServer/CelesteNet</a></p>
<p>直接下载项目 zip 或使用 <code>git</code> 工具下载</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/CelesteNyaServer/CelesteNet.git</span><br></pre></td></tr></table></figure>
<p><strong>注意这个项目要求你把项目文件夹置于 Celeste 的 Mods 文件夹下</strong></p>
<h2 id="编译喵服服务器"><a href="#编译喵服服务器" class="headerlink" title="编译喵服服务器"></a>编译喵服服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd CelesteNet</span><br><span class="line">dotnet build -c Release</span><br></pre></td></tr></table></figure>
<p>如果运行没有报错，这时你应该能够在 <code>./CelesteNet.Server/bin/Debug/net7.0/*</code> 看见一个已经完整编译好的服务器，比如，目录下有 <code>CelesteNet.Server.exe</code></p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>将上面的 <code>./CelesteNet.Server/bin/Debug/net7.0/*</code> 中 net7.0 这个文件夹压缩，并上传到你的服务器</p>
<p>如果服务器是 Windows 系统，你可以直接运行 <code>CelesteNet.Server.exe</code></p>
<p>如果服务器是 Linux/MacOS 系统，请重复 <code>下载 .NET 编译工具</code> 这一步骤，注意选择对应系统与架构的 .NET 安装，你也可以直接使用包管理<br>安装完毕后你只需要使用如下指令即可轻松打开服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dotnet ./CelesteNet.Server.dll</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于 Linux 你也可以参考微软官方的教程<br><a href="https://learn.microsoft.com/zh-cn/dotnet/core/install/linux">https://learn.microsoft.com/zh-cn/dotnet/core/install/linux</a><br>注意 Debian 源内的包只支持 amd64 架构，如果你的服务器是其他架构，比如我的树莓派是 arm64，请使用手动安装方法</p>
</blockquote>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>服务器的配置文件存在于 <code>./ModuleConfigs</code> 里，比如 <code>./ModuleConfigs/CelesteNetServer.ChatModule.yaml</code> 你可以添加一些进服时显示的信息，如下图</li>
</ol>
<p><img src="/images/CelesteMiaoNet自建群服教程_图2.jpg" width="100%" height="100%"></p>
<ol>
<li>服务器默认开放端口号为 17230</li>
</ol>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>[喵服仓库] <a href="https://github.com/CelesteNyaServer/CelesteNet">https://github.com/CelesteNyaServer/CelesteNet</a></li>
<li>[官服仓库] <a href="https://github.com/0x0ade/CelesteNet">https://github.com/0x0ade/CelesteNet</a></li>
</ol>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Another</category>
      </categories>
  </entry>
  <entry>
    <title>C/C++的特别复杂的类型</title>
    <url>/posts/8fb716fa.html</url>
    <content><![CDATA[<h1 id="那些C-C-的特别复杂的类型"><a href="#那些C-C-的特别复杂的类型" class="headerlink" title="那些C/C++的特别复杂的类型"></a>那些C/C++的特别复杂的类型</h1><p>首先来看如下的一个声明<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> (*(*fp2)(<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure><br><span id="more"></span><br>是不是已经看晕了，但其实这个还不够复杂，我就不举更多的例子了<br>前排提示，为了您和您的家人健康，如果不是迫不得已，请不要写出这种反人类代码<br><del>除非你想被我##%&amp;@&amp;&amp;%(数据删除)</del><br>但别说这个东西没用，有些底层的东西确实有这么复杂(但不一定复杂成这样)</p>
<hr>
<h2 id="前人的智慧"><a href="#前人的智慧" class="headerlink" title="前人的智慧"></a>前人的智慧</h2><p>其实可以通过一个叫右左法则的东西来解决这个问题，不过我觉得后缀表达式还是看的有点头疼，有兴趣可以找找看，它可以将式子变成一个后缀表达式，采取编译器的形式进行处理。但我们不采用这种方法，<del>原因是后缀表达式还是不够可读</del>，原因是我不会用<br>补充：链接贴在这里<a href="https://www.bilibili.com/video/BV1mB4y1L7HB/?is_story_h5=false&amp;p=1&amp;share_from=ugc&amp;share_medium=android&amp;share_plat=android&amp;share_session_id=8c3141a9-9324-4449-8409-8f2d1d7846dd&amp;share_source=QQ&amp;share_tag=s_i&amp;timestamp=1668064269&amp;unique_k=GWrf0E0">B站：初中生也能看懂的C/C++类型声明规则教学，很简单的！</a></p>
<hr>
<h2 id="着手解决这个问题"><a href="#着手解决这个问题" class="headerlink" title="着手解决这个问题"></a>着手解决这个问题</h2><p>我们先来看看一个声明，他到底是什么意思<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> (*p)[] = <span class="literal">NULL</span>;<span class="comment">//这是一个指向char数组的指针</span></span><br></pre></td></tr></table></figure></p>
<p>其实无论是什么样的声明，都是同样的格式<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Type_1 Type_2 = xxx;</span><br><span class="line"><span class="comment">//准确来说Type_2不是一种类型，而是对变量进行多种符号操作后的产物</span></span><br><span class="line"><span class="comment">//简单的变量声明如 &quot;int a;&quot; 中 a被0个符号修饰 从而a等价int</span></span><br></pre></td></tr></table></figure></p>
<p>就是说，在如上这个声明里就是<br><code>Type_1</code>是<code>char</code><br><code>Type_2</code>是<code>(*p)[]</code><br>你可以把<code>p</code>就想象成一个已经定义的指向<code>char</code>数组的指针<br>对其解引用并取下标类型就是<code>char</code></p>
<p>也就是说<br><code>char</code> 在类型上等价于<code>(*p)[]</code></p>
<p>也就是说这是通过一个<span style="color: pink; font-size: 20px; font-weight: bolder;"><code>Type_1</code>在类型上等价<code>Type_2</code>的一个类型的等式</span>来确定的要赋值的变量名的类型到底是什么<br><span style="color: pink; font-size: 20px; font-weight: bolder;">所以，我们可以对一个合法的变量声明在其内部任意位置进行分割，然后加括号保证可读性,用以区分<code>Type_1</code>和<code>Type_2</code></span></p>
<p>也就是说其实可以这么处理：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> **p[]; <span class="comment">// 以下对表达式逐步进行分割</span></span><br><span class="line">**p[] <span class="comment">//是int</span></span><br><span class="line">*p[]  <span class="comment">//是指向int的指针 即int*</span></span><br><span class="line">p[]   <span class="comment">//是指向 指向int的指针 的指针 即int**</span></span><br><span class="line">p     <span class="comment">//是指向 指向int的指针 的指针 的数组 即int**</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="现在找一个看起来更舒服的方法"><a href="#现在找一个看起来更舒服的方法" class="headerlink" title="现在找一个看起来更舒服的方法"></a>现在找一个看起来更舒服的方法</h2><p>让我们来看一个例子<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="type">const</span> * ch2;</span><br><span class="line">(<span class="built_in">const</span> (<span class="type">char</span>*))* ch2;</span><br><span class="line"><span class="comment">//这两个是等价的</span></span><br></pre></td></tr></table></figure><br>仔细看看<strong>第二个式子</strong>绝对比第一个式子阳间，为什么？<br>因为这里的<code>Type_2</code>就是<code>ch2</code><br><strong>变量名ch2没有经过各种符号的修饰</strong>，直接等于左边的一坨<code>Type_1</code><br>那所以说其实化成可读性强的式子就是把变量名从一堆修辞里拯救出来的过程<br>就是说把变量名的一堆枷锁找个简单的类型当替死鬼装它身上(奇妙的比喻增加了)<br>我们可以用一些看上去更数学的方法来做(滑稽)</p>
<h2 id="需要强调的一点"><a href="#需要强调的一点" class="headerlink" title="需要强调的一点"></a>需要强调的一点</h2><p><strong>以下的转化到其最后结果只是为了可读性，不一定能过编译！！！！！<br>以下的转化到其最后结果只是为了可读性，不一定能过编译！！！！！<br>以下的转化到其最后结果只是为了可读性，不一定能过编译！！！！！</strong></p>
<h2 id="让我们来开始着手做吧"><a href="#让我们来开始着手做吧" class="headerlink" title="让我们来开始着手做吧"></a>让我们来开始着手做吧</h2><p>首先一个声明里其实是只有一个简单类型的(这里的简单类型就是说的那些基础类型，<code>int</code>，<code>char</code>，<code>double</code>，或者是<code>class</code>，<code>struct</code>)<br><code>模板&lt;&gt;</code>和<code>函数()</code>内的简单类型其实是不会和其混淆的<br><code>模板&lt;&gt;</code>有尖括号<br>而<code>函数()</code>在变量名后，而简单类型一定在变量名前<br><code>int</code>是类型声明，<code>(int)</code>是参数表<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//int不会和(int)混淆</span></span><br></pre></td></tr></table></figure><br>变量名并不好脱掉一堆枷锁嘛，所以我们要强迫让简单类型这个替死鬼自己扒了变量名的衣服自己穿上(What’s The Fuck)<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span> (*(*fp2)(<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>))(<span class="type">int</span>); <span class="comment">// 这是一个函数指针的形式</span></span><br></pre></td></tr></table></figure><br><code>float</code>替死鬼上线，先把和它处于同一优先级的”<code>(int)</code>“扒了套自己身上，并加个括号以示对它的主权(乐)<br>并暗示你被我扒了一层所以这下<code>(*(*fp2)(int,int,float))</code>最外层的括号可以脱了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="built_in">float</span> (<span class="type">int</span>)) *(*fp2)(<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>);</span><br></pre></td></tr></table></figure><br>可以看到这个工具的强大了<br><code>(float (int))</code>这个就是一个传入<code>int</code>返回<code>float</code>的函数<br>但是过不了编译！！！！！注意！！！！！<br>然后替死鬼现在是<code>(float (int))</code>，继续把<code>*</code>扒了<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((<span class="built_in">float</span> (<span class="type">int</span>))*) (*fp2)(<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>);</span><br></pre></td></tr></table></figure><br>虽然现在已经能看出来最外层是<code>(float (int))</code>的函数指针了，但我们再来一次<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(((<span class="built_in">float</span> (<span class="type">int</span>))*) (<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>)) *fp2;</span><br></pre></td></tr></table></figure><br>得到 返回值<code>((float (int))*</code>，参数表<code>(int,int,float)</code> 的<code>Type_1</code><br>再来<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">((((<span class="built_in">float</span> (<span class="type">int</span>))*) (<span class="type">int</span>,<span class="type">int</span>,<span class="type">float</span>)))* fp2;</span><br></pre></td></tr></table></figure><br>这下结构也太清晰了<br>看懂了但是很难描述，但是我还是想尝试描述一下 （就算是中文也要靠多重括号来断句（悲<br><code>fp2</code>是一个{以【返回值为<code>float</code>，参数表为<code>(int)</code>的函数指针】为返回值，<code>(int,int,float)</code>为参数表}的函数指针</p>
<p>实质上当中的过程覆盖了所有可能的情况了，我们可以用 <a href="#着手解决这个问题">着手解决这个问题</a> 上面这一小标题所写的本质证明这样做的合理性，如指针无非就是一方解引用一方变指针做到的等价。</p>
<hr>
<h2 id="cv限定符"><a href="#cv限定符" class="headerlink" title="cv限定符"></a>cv限定符</h2><p>因为有<code>const</code>，<code>volatile</code>这样的限定符存在，故而这个方法进行开扒的时候，需<strong>先向</strong>替死鬼<strong>前</strong>看一看有没有这些<strong>限定符</strong>，再结合后面<strong>距离<code>Type_1</code>最近的运算符</strong><br><strong>cv限定符应该置于Type_1之前以修饰Type_1</strong><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子一</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> ch1;</span><br><span class="line">(<span class="type">char</span>*) <span class="type">const</span> ch1;</span><br><span class="line"><span class="built_in">const</span> (<span class="type">char</span>*)  ch1;</span><br><span class="line"><span class="comment">//例子二</span></span><br><span class="line"><span class="type">char</span> **<span class="type">const</span> *<span class="type">const</span> ch2;</span><br><span class="line">(<span class="type">char</span> *) *<span class="type">const</span> *<span class="type">const</span> ch2;</span><br><span class="line">((<span class="type">char</span> *)*)<span class="type">const</span> *<span class="type">const</span> ch2;</span><br><span class="line"><span class="built_in">const</span> (<span class="built_in">const</span>((<span class="type">char</span>*)*))* ch2;</span><br><span class="line"><span class="comment">//例子三</span></span><br><span class="line"><span class="type">int</span> *a[][N];</span><br><span class="line">((<span class="type">int</span> *)[N])[] a;</span><br><span class="line"><span class="comment">//例子四</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">()</span>[]</span>;<span class="comment">//无法过编译，如vs2022会指出其为返回数组的函数</span></span><br><span class="line">(<span class="type">int</span> [])() a;<span class="comment">//可以看到这是返回数组的函数，非法</span></span><br><span class="line"><span class="comment">//例子五</span></span><br><span class="line"><span class="type">int</span> a[]();<span class="comment">//无法过编译，如vs2022会指出其为函数数组</span></span><br><span class="line">(<span class="built_in">int</span> ())[] a;<span class="comment">//可以看到这是函数数组，非法</span></span><br></pre></td></tr></table></figure><br>对于例子三和例子四还有例子五，实质上有一个整体考虑的办法</p>
<ul>
<li>例子三<code>[][]</code>可以当作二维数组来看，第一个<code>[]</code>转移过程中可以不给替死鬼加括号就清楚了</li>
<li>对于例子四<code>()[]</code>，其实我们完全可以把数组取下标看作一种特殊的函数，反过来也是</li>
<li>函数其实和数组在这里可以不用特别区分，所以五和四和三一样</li>
<li>同时这也启示我们<code>()[]</code> , <code>[]()</code>如果出现在一块，这必定不可能是合法的</li>
<li>因为其必定包含函数数组或是返回数组的函数，不合法<br>*当然<code>[]</code>和<code>()</code>因为优先级是最高的，所以和名字结合最紧，最后才能被扒掉，而<code>()[]</code>之间呢，与名字最靠近的当然结合更紧，所以在之后被扒</li>
</ul>
<hr>
<h2 id="Ending"><a href="#Ending" class="headerlink" title="Ending"></a>Ending</h2><p>至此我们完成了这种特别复杂的声明的辨析，但其实这个工具还有一种应用就是依照这种格式，可以从<strong>可读性强的格式反向推得这种复杂的声明</strong>。<br><span style="color: pink; font-size: 20px; font-weight: bolder;">即<code>Type_1</code>在类型上等价<code>Type_2</code>先将变量名后缀移到<code>Type_1</code>上，再通过分割将变量名彻底弄干净（无符号修饰无后缀），最后变量类型即为<code>Type_1</code>，而开扒的顺序，关键看这些符号作用在变量名上的顺序，如果优先级高，则说明与之结合紧，越晚被扒，而括号里的部分可以看作一个整体开扒，这样就可以化简整体的结构</span><br>终于写完了，虽然如此，我只希望尽可能不要有人为了炫技而写出这种声明<br>脱帽子，yeah~~</p>
<hr>
<p><strong>editor</strong>  594飞飘<br><strong>audit</strong>   Serein</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Github登陆与验证的故事</title>
    <url>/posts/5ef186e7.html</url>
    <content><![CDATA[<h1 id="Github登陆与验证的故事"><a href="#Github登陆与验证的故事" class="headerlink" title="Github登陆与验证的故事"></a>Github登陆与验证的故事</h1><p>最近一次给我的 Gentoo 滚包的时候，发现了一个很神奇的问题，特此来写一篇博客</p>
<span id="more"></span>
<h2 id="问题阐述"><a href="#问题阐述" class="headerlink" title="问题阐述"></a>问题阐述</h2><p>更新元数据到 steam 的时候，突然开始问我要用户名和密码了<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Syncing repository &#x27;steam-overlay&#x27; into &#x27;/var/db/repos/steam-overlay&#x27;...</span><br><span class="line">/usr/sbin/git fetch origin --depth 1</span><br><span class="line">Username for &#x27;https://github.com&#x27;:</span><br></pre></td></tr></table></figure></p>
<p>还记得很久之前，我一开始学习使用 git 的时候，到发生这个事情之前，我一直都是在这个登陆上瞎搞搞就成功的，但是此次发生这样的错误，我实在是受不了了。<code>steam-overlay</code> 提供了 <code>proton</code> 这样的基础设施，我必须修好它。</p>
<h2 id="解决问题的开篇"><a href="#解决问题的开篇" class="headerlink" title="解决问题的开篇"></a>解决问题的开篇</h2><p>实质上这个问题是好几个事情的叠加，我此次滚包距离上次滚包已经是有两个月之久了，最后变动的包一共有 684 项，总体编译并更新时长超过了 11 个小时。<br>首先我们知道，Github 其实在很久之前就不允许使用用户名+密码这种比较弱的身份验证方式登陆了，你必须在 Github 上创建 PAT(personal access token) 来验证你的身份，具体的创建方式在官方文档里有提供<br><a href="https://githubdocs.cn/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens">https://githubdocs.cn/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens</a></p>
<p>注意上述方式只支持 https 的登陆，ssh 不能使用 PAT 进行登陆，而 Github 也给出了这个 PAT 具体是怎么使用的</p>
<p><img src="/images/Github登陆与验证的故事_图1.png" width="100%" height="100%"></p>
<p>可以看到，默认的 Git 只支持使用 username 和 password 进行认证。让我们来细细讨论一下 git 的认证模式</p>
<h2 id="git-认证机制"><a href="#git-认证机制" class="headerlink" title="git 认证机制"></a>git 认证机制</h2><blockquote>
<p>注:下面讨论的对象全部都是官方的 Git CLI，不讨论第三方的 git 实现</p>
</blockquote>
<p>其实官方的 Git CLI 并不是自己实现各种 HTTP 认证机制的，而是调用了 <code>libcurl</code> 来处理 HTTP 连接、握手、认证等底层细节。使用 <code>libcurl</code> 你只需要像下面这样设置 username 和 password</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CURL *curl = curl_easy_init();</span><br><span class="line"><span class="keyword">if</span> (curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">&quot;https://example.com/repo.git&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Git 就是这么做的:把从 credential helper 拿到的字段设置进去</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_USERNAME, <span class="string">&quot;myuser&quot;</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_PASSWORD, <span class="string">&quot;mypassword&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况 libcurl 根据服务器实际支持情况自动选择认证方式</span></span><br><span class="line">    CURLcode res = curl_easy_perform(curl);</span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但大家都知道，验证方式可不是只有 username + password 这样一种模式，那么如果服务器问你要 token-only 的协商模式怎么办？<br>让我们来看看 git 实现了什么，搜索 <code>curl_easy_setopt</code>:<br><a href="https://github.com/search?q=repo%3Agit%2Fgit%20curl_easy_setopt&amp;type=code">https://github.com/search?q=repo%3Agit%2Fgit%20curl_easy_setopt&amp;type=code</a></p>
<p>你会发现，其实 git 只给 libcurl 传了 username + password，那么在这种情况下，其实如果服务器真问你要 token-only，是属于 <code>libcurl</code> 在只有 username + password 下无法处理的情况，那么库也只能给你返回一个错误了</p>
<p><strong>(结论 1) 所以其实 git 支持的模式就是，libcurl 在拥有 username + password 时能正常工作的那几个认证模式，其中最典型的就是 basic，其他都是在此基础上的安全性修正。</strong><br>所以在这种情况下，绝大部分 git 仓库在 http(s)下，既然反正都要使用用户名密码了，那么把密码当 token 也是一种合适的行为了</p>
<h2 id="VSCode-怎么做的？"><a href="#VSCode-怎么做的？" class="headerlink" title="VSCode 怎么做的？"></a>VSCode 怎么做的？</h2><p>在通过各种途径:比如 <strong>Git Pro</strong>、Git 源代码、LLM 搜索的情况下了解了这些，我立马意识到一个问题:<br>是啊，我现在也许可以解决当下的问题了，但是有一个破绽我还是不能理解，我常用的 VSCode 提供了 GUI 模式的 git 仓库操作能力，我为什么最近在 VSCode 底下的提交行为并没有出现问题，偏偏是滚包的时候出问题了？</p>
<p>AI 给我了一个结果，因为有所谓 GCM(<a href="https://github.com/git-ecosystem/git-credential-manager">git credential manager</a>) 存在，他说这个工具是通过设置如下选项进行配置 git 的 credential.helper 来起作用的<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config credential.helper</span><br></pre></td></tr></table></figure></p>
<p>credential.helper 是 git 的一个凭证管理子系统，用于在“git 想要 username/password 时”，提供这些凭证，或者把它们保存下来。<br>其实工作原理就是 git 在做一些远程操作的时候就传给他们一些信息，要他们返还的一组 username + password 来登陆，而 git 本身并不负责这些</p>
<p>也就是说如果他们不存在那 git 应该每次 push/clone 操作都会问你讨要用户名密码</p>
<p>如果这条指令能够返回 <code>manager-core</code> 那么就说明我在使用 gcm 了<br>是…是么？AI 说的话我只能相信 50%，在我的电脑上这行指令成功返回了 <code>cache</code></p>
<p>这是何意，cache 就只是把密码暂存在内存里几分钟，但我 VSCode 在我装完它这一年，基本在登陆后从不会再怎么多登陆，我甚至不知道怎么退出登陆(笑)</p>
<p>于是在实践下我发现了一些东西，<code>feipiao-study-record</code> 是我新建的一个私有库，在 vscode 的聚合终端和外部的 konsole 中完全不一样</p>
<p><img src="/images/Github登陆与验证的故事_图2.jpg" width="100%" height="100%"></p>
<p>而且在我把 credential.helper 置空后，vscode 这边仍然可以工作。</p>
<p>这肯定是环境变量在起作用了，搜索了一下 vscode 聚合终端下面的环境变量，锚定了下面几个</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">env</span> | grep -i askpass</span><br><span class="line">VSCODE_GIT_ASKPASS_NODE=/opt/vscode/code</span><br><span class="line">SSH_ASKPASS=/usr/bin/ksshaskpass</span><br><span class="line">GIT_ASKPASS=/opt/vscode/resources/app/extensions/git/dist/askpass.sh</span><br><span class="line">VSCODE_GIT_ASKPASS_EXTRA_ARGS=</span><br><span class="line">VSCODE_GIT_ASKPASS_MAIN=/opt/vscode/resources/app/extensions/git/dist/askpass-main.js</span><br></pre></td></tr></table></figure>
<p>描述他们的<a href="https://git-scm.com/docs/gitcredentials">官方文档</a>如下:</p>
<p><img src="/images/Github登陆与验证的故事_图3.png" width="100%" height="100%"></p>
<p>他们这几个环境变量其实是一个朴素的 credential.helper，单纯只是一个 cli 进程，git 从标准 IO 传递并获取他们存取的用户名密码</p>
<p><strong>(结论 2)</strong> 而这边的 <code>GIT_ASKPASS</code> 赫然就是 vscode 的东西，原来是用这种方式侵入并提供了认证服务啊，所有 vscode 的登陆窗口，vscode 里方便的认证，都来自于此，vscode 负责替你与 github 产生交互，最终生成一个 username + password 给 git，git 在这个会话的基础上进行与 github git 仓库的远程操作</p>
<p>使用以下命令可以删去这个环境变量，此时 vscode 和外部的 konsole 效果就一致了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">env</span> -u GIT_ASKPASS git <span class="built_in">clone</span> &lt;your-repo-https-url&gt;</span><br></pre></td></tr></table></figure></p>
<p>但是还是报错，直接报错，也没问我要，在给 GIT 打上 TRACE 环境变量后，从 log 里看到是 <code>SSH_ASKPASS</code> 在干坏事，我从来没有调整过 kde 的 <code>kwallet</code>，里面存储的从来就是一个错误的 token，所以这下就寄掉了。调整一下就可以工作了。</p>
<h2 id="GCM-去哪了"><a href="#GCM-去哪了" class="headerlink" title="GCM 去哪了"></a>GCM 去哪了</h2><p>可以看到啊，在 github 的 settings - application 里有相关的允许的认证客户端的信息，vscode 插件的认证次数要远多于 gcm (我这边按照 Recently Used 排序了)</p>
<p><img src="/images/Github登陆与验证的故事_图4.png" width="100%" height="100%"></p>
<p>但 GCM 这个东西确实存在啊。其实它是绑定在 windows 的 git 安装包的，所以 windows 用户其实一上来就使用了最现代的认证模式，它会拉起一个浏览器页面让你登陆<br>所以在 windows 上执行刚刚的我返回 <code>cache</code> 的指令，你们大概率会得到 <code>manager-core</code> 或者 <code>manager</code></p>
<p>而如果 gcm 存在，那这些环境变量就不需要考虑了</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>官方 git cli 只在远程请求的时候问你要 username + password，支持的 http(s) 的认证模式就是，它所依赖的 libcurl 在拥有 username + password 时能正常工作的那几个认证模式，其中最典型的就是 basic，其他都是在此基础上的安全性修正。</li>
<li>官方 git cli 可以从别的地方读入 username + password，有 credential.helper 和 askpass 系环境变量两种，其中前者优先级更高，详情请看上方标注出的官方文档</li>
<li>vscode 通过设置 GIT_ASKPASS 与其自身的内置插件来实现 github 登陆</li>
</ol>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>完全使用 GCM 来统一登陆手段，全局配置 credential.helper 为 GCM 会让 vscode 的认证 hook 失效，因为其实质上只是在调用 git，而 git 负责决定认证信息来源。</p>
<h2 id="番外"><a href="#番外" class="headerlink" title="番外"></a>番外</h2><h3 id="事件一"><a href="#事件一" class="headerlink" title="事件一"></a>事件一</h3><p>2025-10-30 时，Gentoo 官方的 Github Organization 踢掉了所有第三方源，包括一些比较有名的，比如 steam-overlay、gentoo-zh<br>这也导致了上述滚包的时候产生的 github 认证问题不只是上述的这个问题，可能是 github 服务器认为这是一个属于 Gentoo 官方的 Github Organization 的私有仓库，问我要 token 来了<br>而我很久没滚包了，没看见 gentoo 社区里的新闻www</p>
<h3 id="事件二"><a href="#事件二" class="headerlink" title="事件二"></a>事件二</h3><p>在查看 Pro Git 这本书的时候，我发现关于传输协议这段的描述<br><a href="https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols">https://git-scm.com/book/en/v2/Git-Internals-Transfer-Protocols</a></p>
<p>中文版会把 The Dumb Protocol 翻译成哑协议，在我印象里 dumb 是愚蠢的意思，而且这边就两个协议，另一个叫 The Smart Protocol</p>
<p>我一开始以为是某种中国人的含蓄（<br>一搜发现 dumb 还真有哑的意思，而且排在愚蠢前，那到底是谁比较愚蠢自不必多说了 qwq</p>
<p><img src="/images/Github登陆与验证的故事_图5.png" width="100%" height="100%"></p>
<p>我还是觉得这是中国人的含蓄</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Git使用_第2弹</title>
    <url>/posts/2b9af9d8.html</url>
    <content><![CDATA[<h1 id="Git使用-第2弹"><a href="#Git使用-第2弹" class="headerlink" title="Git使用_第2弹"></a>Git使用_第2弹</h1><p>接下来正式进入Git的使用部分，这一弹从 <code>&quot;Pro Git&quot;</code>的第二章开始</p>
<span id="more"></span>
<h2 id="在已存在目录中初始化仓库"><a href="#在已存在目录中初始化仓库" class="headerlink" title="在已存在目录中初始化仓库"></a>在已存在目录中初始化仓库</h2><p>如果你有一个尚未进行版本控制的项目目录，想要用Git来控制它，那么首先需要进入该项目目录中。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br></pre></td></tr></table></figure>
<p>该命令将创建一个名为 <code>.git</code>的子目录，这个子目录含有你初始化的Git仓库中所有的必须文件，这些文件是Git仓库的骨干。但是在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。</p>
<p>如果在一个已存在文件的文件夹(而非空文件夹)中进行版本控制，你应该开始追踪这些文件并进行初始提交。可以通过 <code>git add</code>命令来指定所需的文件来进行追踪，然后执行 <code>git commit</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *.c</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add LICENSE</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&#x27;initial project version&#x27;</span></span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="克隆现有的仓库"><a href="#克隆现有的仓库" class="headerlink" title="克隆现有的仓库"></a>克隆现有的仓库</h2><p>如果你想获得一份已经存在了的Git仓库的拷贝，比如说，你想为某个开源项目贡献自己的一份力，这时就要用到 <code>git clone</code>命令。<br>克隆仓库的命令是 <code>git clone &lt;url&gt;</code>。比如，要克隆该博客的markdown文件夹，可以用下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/feipiao594/Self-study-notes.git</span></span><br></pre></td></tr></table></figure>
<p>这会在当前目录下创建一个名为 <code>&quot;Self-study-notes&quot;</code> 的目录，并在这个目录下初始化一个 <code>.git</code>文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code>文件夹，然后从中读取最新版本的文件的拷贝。如果你进入到这个新建的文件夹，你会发现所有的项目文件已经在里面了，准备就绪等待后续的开发和使用。<br>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/feipiao594/Self-study-notes.git dailyNotes</span></span><br></pre></td></tr></table></figure>
<p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>dailyNotes</code>。<br>Git 支持多种数据传输协议。 上面的例子使用的是 <code>https://</code>协议，不过你也可以使用 <code>git://</code>协议或者使用<br>SSH传输协议，比如 <code>user@server:path/to/repo.git</code>。我们会 <code>&quot;在服务器上搭建Git&quot;</code>将会介绍所有这些协议在服务器端如何配置使用，以及各种方式之间的利弊。</p>
<hr>
<h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>现在我们的机器上有了一个真实项目的Git仓库，并从这个仓库中检出了所有文件的工作副本。通常，你会对这些文件做些修改，每当完成了一个阶段的目标，想要将记录下它时，就将它提交到仓库。<br>请记住，你工作目录下的每一个文件都不外乎这两种状态：<strong>已跟踪</strong>或<strong>未跟踪</strong>。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能是未修改，已修改或已放入暂存区。简而言之，已跟踪的文件就是Git已经知道的文件。<br>工作目录中除已跟踪文件外的其它所有文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有被放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为Git刚刚检出了它们，而你尚未编辑过它们。<br>编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git将它们标记为已修改文件。在工作时，你可以选择性地将这些修改过的文件放入暂存区，然后提交所有已暂存的修改，如此反复。<br>下图展示了文件的状态变化周期<br><img src="/images/Git使用_第二弹_图1.png" width="100%" height="100%"></p>
<h2 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h2><p>下面是一些基本的操作</p>
<h3 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h3><p>可以用 <code>git status</code>命令查看哪些文件处于什么状态。</p>
<h3 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h3><p>使用命令 <code>git add</code>开始跟踪一个文件。所以，要跟踪 <code>README</code>文件，运行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>此时再运行 <code>git status</code>命令，会看到 <code>README</code>文件已被跟踪，并处于暂存状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">   new file: README</span><br></pre></td></tr></table></figure>
<p>只要在 <code>Changes to be committed</code>这行下面的，就说明是已暂存状态。如果此时提交，那么该文件在你运<br>行 <code>git add</code>时的版本将被留存在后续的历史记录中。<code>git add</code>命令使用<strong>文件或目录的路径</strong>作为参数；如果参数是<strong>目录的路径</strong>，该命令将<strong>递归</strong>地跟踪该目录下的<strong>所有文件</strong>。</p>
<h3 id="暂存已修改的文件"><a href="#暂存已修改的文件" class="headerlink" title="暂存已修改的文件"></a>暂存已修改的文件</h3><p>如果你修改了一个名为 <code>CONTRIBUTING.md</code>的已被跟踪的文件，然后运行 <code>git status</code>命令,，此时文件 <code>CONTRIBUTING.md</code>出现在 <code>Changes not staged for commit</code>这行下面，说明已跟踪文件的内容发生了变化，但还没有放到暂存区。要暂存这次更新，需要运行 <code>git add</code>命令。</p>
<blockquote>
<p>注意 <code>git add</code>这是个多功能命令：可以用它开始<strong>跟踪新文件</strong>，或者把<strong>已跟踪</strong>的文件放到<strong>暂存区</strong>，还能用于<strong>合并时把</strong>有<strong>冲突</strong>的文件<strong>标记</strong>为<strong>已解决</strong>状态等。</p>
</blockquote>
<p>如果你运行 <code>git add</code>命令后再一次修改 <code>CONTRIBUTING.md</code>文件，你就会发现现在 <code>CONTRIBUTING.md</code>文件同时出现在暂存区和非暂存区。</p>
<h3 id="状态简览"><a href="#状态简览" class="headerlink" title="状态简览"></a>状态简览</h3><p>可以在 <code>git status</code>后面添加 <code>-s</code>或者 <code>--short</code>参数即使用 <code>git status -s</code>命令或 <code>git status --short</code>命令，你将得到一种格式更为紧凑的输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status -s</span><br><span class="line">  M README</span><br><span class="line">  MM Rakefile</span><br><span class="line">  A lib/git.rb</span><br><span class="line">  M lib/simplegit.rb</span><br><span class="line">  ?? LICENSE.txt</span><br></pre></td></tr></table></figure>
<p>新添加的未跟踪文件前面有 <code>??</code>标记，新添加到暂存区中的文件前面有 <code>A</code>标记，修改过的文件前面有 <code>M</code>标记。输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。例如，上面的状态报告显示：<code>README</code>文件在工作区已修改但尚未暂存，而 <code>lib/simplegit.rb</code>文件已修改且已暂存。<code>Rakefile</code>文件已修改，暂存后又作了修改，因此该文件的修改中既有已暂存的部分，又有未暂存的部分。</p>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>一般我们总会有些文件无需纳入Git的管理，也不希望它们总出现在未跟踪文件列表。通常都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以在项目根目录下创建一个名为 <code>.gitignore</code>的文件，列出要忽略的文件的模式。<br>要养成一开始就为你的新仓库设置好 <code>.gitignore</code>文件的习惯，以免将来误提交这类无用的文件。<br>文件 <code>.gitignore</code>的格式规范如下：</p>
<ul>
<li>所有空行或者以 <code>#</code>开头的行都会被Git忽略。</li>
<li>可以使用标准的<strong>glob模式匹配</strong>，它会递归地应用在整个工作区中。</li>
<li>匹配模式可以以 <code>(/)</code>开头防止递归。</li>
<li>匹配模式可以以 <code>(/)</code>结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号 <code>(!)</code>取反。</li>
</ul>
<p>所谓的glob模式是指<strong>shell</strong>所使用的<strong>简化了的正则表达式</strong>。 星号 <code>(*)</code>匹配零个或多个任意字符；<code>[abc]</code>匹配<br>任何一个列在方括号中的字符 (这个例子要么匹配一个a，要么匹配一个b，要么匹配一个 c)； 问号 <code>(?)</code>只<br>匹配一个任意字符；如果在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配<br>(比如 <code>[0-9]</code>表示匹配所有0到9的数字)。 使用两个星号 <code>(**)</code>表示匹配任意中间目录，比如 <code>a/**/z</code>可以匹配 <code>a/z</code>、<code>a/b/z</code>或 <code>a/b/c/z</code>等。</p>
<h3 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h3><p>想知道具体修改了什么地方，可以用 <code>git diff</code>命令。 稍后我们会详细介绍 <code>git diff</code>，你通常可能会用它来回答这两个问题：<strong>当前做的哪些更新尚未暂存？有哪些更新已暂存并准备好下次提交</strong>？ 虽然 <code>git status</code>已经通过在相应栏下列出文件名的方式回答了这个问题，但 <code>git diff</code>能通过文件补丁的格式更加具体地显示哪些行发生了改变。</p>
<p>不加参数直接输入 <code>git diff</code>可以比较工作目录中当前文件和暂存区域快照之间的差异。 也就是修改之后还没有暂存起来的变化内容。<br>若要查看已暂存的将要添加到下次提交里的内容，可以用 <code>git diff --staged</code>命令。 这条命令将比对已暂存文件与最后一次提交的文件差异</p>
<p>请注意，<code>git diff</code>本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。 所以有时候你一下子暂存了所有更新过的文件，运行 <code>git diff</code>后却什么也没有，就是这个原因。</p>
<p>用 <code>git diff --cached</code>查看已经暂存起来的变化(<code>--staged</code>和 <code>--cached</code>是同义词)</p>
<h3 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h3><p>现在的暂存区已经准备就绪，可以提交了。 在此之前，请务必确认还有什么已修改或新建的文件还没有 <code>git add</code>过，否则提交的时候不会记录这些尚未暂存的变化。这些已修改但未暂存的文件只会保留在本地磁盘。所以，每次准备提交前，先用 <code>git status</code>看下，你所需要的文件是不是都已暂存起来了，然后再运行提交命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit</span></span><br></pre></td></tr></table></figure>
<p>这样会启动你选择的文本编辑器(在很多IDE中，通常是vim)来输入提交说明。<br>你也可以在 <code>commit</code>命令后添加 <code>-m</code>选项，将提交信息与命令放在同一行</p>
<h3 id="跳过使用暂存区域"><a href="#跳过使用暂存区域" class="headerlink" title="跳过使用暂存区域"></a>跳过使用暂存区域</h3><p>尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 <code>git commit</code>加上 <code>-a</code>选项，Git就会自动把<strong>所有已经跟踪过</strong>的文件<strong>暂存</strong>起来<strong>一并提交</strong>，从而跳过 <code>git add</code>步骤</p>
<h3 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h3><p>要从Git中移除某个文件，就必须要从已跟踪文件清单中移除(确切地说，是从暂存区域移除)，然后提交。<br>可以用 <code>git rm</code>命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>要在 Git 中对文件改名，可以这么做：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> file_from file_to</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with &#x27;origin/master&#x27;.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  renamed: README.md -&gt; README</span><br></pre></td></tr></table></figure>
<p>运行 <code>git mv</code>就相当于运行了下面三条命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mv</span> README.md README</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README</span></span><br></pre></td></tr></table></figure>
<p>如此分开操作，Git也会意识到这是一次重命名，所以不管何种方式结果都一样。 两者唯一的区别在于，<code>git mv</code>是一条命令而非三条命令，直接使用 <code>git mv</code>方便得多。不过在使用其他工具重命名文件时，记得在提交前 <code>git rm</code>删除旧文件名，再 <code>git add</code>添加新文件名。</p>
<h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是 <code>git log</code>命令。</p>
<p><img src="/images/Git使用_第二弹_图2.png" width="100%" height="100%"><br><img src="/images/Git使用_第二弹_图3.png" width="100%" height="100%"></p>
<h3 id="撤消操作"><a href="#撤消操作" class="headerlink" title="撤消操作"></a>撤消操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit --amend</span></span><br></pre></td></tr></table></figure>
<p>这个命令会将<strong>暂存区</strong>中的文件提交。如果自上次提交以来你还未做任何修改(例如，在上次提交后马上执行了此命令)，那么快照会保持不变，而你所修改的只是提交信息。<br>文本编辑器启动后，可以看到之前的提交信息。编辑后保存会覆盖原来的提交信息。</p>
<h3 id="取消缓存与撤销修改"><a href="#取消缓存与撤销修改" class="headerlink" title="取消缓存与撤销修改"></a>取消缓存与撤销修改</h3><p>观察下面这段，可以看到下面叙述两个指令连用的效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add *</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  renamed: README.md -&gt; README</span><br><span class="line">  modified: CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD CONTRIBUTING.md</span></span><br><span class="line"></span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  renamed: README.md -&gt; README</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working</span><br><span class="line">directory)</span><br><span class="line">  modified: CONTRIBUTING.md</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- CONTRIBUTING.md</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line"></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line">  renamed: README.md -&gt; README</span><br></pre></td></tr></table></figure>
<h4 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h4><p>在你输入 <code>git status</code>后，在 <code>“Changes to be committed”</code>文字正下方，提示使用 <code>git reset HEAD &lt;file&gt;...</code>来取消<strong>暂存</strong>。</p>
<h4 id="撤消对文件的修改"><a href="#撤消对文件的修改" class="headerlink" title="撤消对文件的修改"></a>撤消对文件的修改</h4><p>同理，<code>git status</code>也会提示使用 <code>git checkout -- &lt;file&gt;...</code>来对未暂存区域中文件进行撤销修改，将它还原成上次提<br>交时的样子</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code>命令。它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code>——这是Git给你克隆的仓库服务器的默认名字<br>你也可以指定选项 <code>-v</code>，会显示需要读写远程仓库使用的Git保存的简写与其对应的URL。</p>
<p>我们在之前的章节中已经提到并展示了 <code>git clone</code>命令是如何自行添加远程仓库的， 不过这里将告诉你如何自<br>己来添加它。 运行 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code>添加一个新的远程Git仓库，同时指定一个方便<br>使用的简写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add pb https://github.com/paulboone/ticgit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">origin https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin https://github.com/schacon/ticgit (push)</span><br><span class="line">pb https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>
<p>现在你可以在命令行中使用字符串 <code>pb</code>来代替整个URL。例如，如果你想拉取 <code>Paul</code>的仓库中有但你没有的信息，可以运行 <code>git fetch pb</code>：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch pb</span></span><br><span class="line">remote: Counting objects: 43, done.</span><br><span class="line">remote: Compressing objects: 100% (36/36), done.</span><br><span class="line">remote: Total 43 (delta 10), reused 31 (delta 5)</span><br><span class="line">Unpacking objects: 100% (43/43), done.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch] master -&gt; pb/master</span><br><span class="line"> * [new branch] ticgit -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>
<p>现在Paul的 <code>master</code>分支可以在本地通过 <code>pb/master</code>访问到——你可以将它合并到自己的某个分支中， 或者如果你想要查看它的话，可以检出一个指向该点的本地分支。</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>就如刚才所见，从远程仓库中获得数据，可以执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch &lt;remote&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个命令会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。如果你使用clone命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 <code>“origin”</code>为简写。所以，<code>git fetch origin</code>会抓取克隆(或上一次抓取)后新推送的所有工作。必须注意 <code>git fetch</code>命令只会将数据下载到你的本地仓库，它并<strong>不会自动合并或修改</strong>你当前的工作。当准备好时你必须手动将其合并入你的工作。<br>如果你的当前分支设置了跟踪远程分支，那么可以用 <code>git pull</code>命令来<strong>自动抓取</strong>后<strong>合并</strong>该远程分支到当前分支。这或许是个更加简单舒服的工作流程。默认情况下，<code>git clone</code>命令会自动设置本地 <code>master</code>分支跟踪克隆的远程仓库的 <code>master</code>分支(或其它名字的默认分支)。 运行 <code>git pull</code>通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>当你想分享你的项目时，必须将其推送到上游。这个命令很简单：<code>git push &lt;remote&gt; &lt;branch&gt;</code>。当你想要将 <code>master</code>分支推送到 <code>origin</code>(再次说明，克隆时通常会自动帮你设置好那两个名字)， 那么运行这个命令就可以将你所做的备份到服务器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin master</span></span><br></pre></td></tr></table></figure>
<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。</p>
<h3 id="查看某个远程仓库"><a href="#查看某个远程仓库" class="headerlink" title="查看某个远程仓库"></a>查看某个远程仓库</h3><p>如果想要查看某一个远程仓库的更多信息，可以使用 <code>git remote show &lt;remote&gt;</code>命令。还可以通过 <code>git remote show</code>看到更多的信息</p>
<h3 id="远程仓库的重命名与移除"><a href="#远程仓库的重命名与移除" class="headerlink" title="远程仓库的重命名与移除"></a>远程仓库的重命名与移除</h3><p>你可以运行 <code>git remote rename</code>来修改一个远程仓库的简写名。 例如，想要将 <code>pb</code>重命名为 <code>paul</code>，可以用 <code>git remote rename</code>这样做：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote rename pb paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure><br>值得注意的是这同样也会修改你所有远程跟踪的分支名字。那些过去引用<code>pb/master</code>的现在会引用<br><code>paul/master</code>。<br>如果因为一些原因想要移除一个远程仓库——你已经从服务器上搬走了或不再想使用某一个特定的镜像了， 又或<br>者某一个贡献者不再贡献了——可以使用<code>git remote remove</code>或<code>git remote rm</code>：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote remove paul</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure><br>一旦你使用这种方式删除了一个远程仓库，那么所有和这个远程仓库相关的远程跟踪分支以及配置信息也会一起被删除。</p>
<h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><h4 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h4><p>在Git中列出已有的标签非常简单，只需要输入<code>git tag</code>(可带上可选的<code>-l</code>选项<code>--list</code>)</p>
<h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>Git 支持两种标签：轻量标签(lightweight)与附注标签(annotated)。</p>
<ul>
<li>轻量标签很像一个不会改变的分支——它只是某个特定提交的引用。</li>
<li>而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard (GPG)签名并验证。通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。</li>
</ul>
<h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>在Git中创建附注标签十分简单。 最简单的方式是当你在运行tag命令时指定<code>-a</code>选项：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.4 -m <span class="string">&quot;my version 1.4&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br><span class="line">v0.1</span><br><span class="line">v1.3</span><br><span class="line">v1.4</span><br></pre></td></tr></table></figure><br><code>-m</code>选项指定了一条将会存储在标签中的信息。如果没有为附注标签指定一条信息，Git会启动编辑器要求你输<br>入信息。<br>通过使用<code>git show</code>命令可以看到标签信息和与之对应的提交信息</p>
<h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>假设提交历史是这样的：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">15027957951b64cf874c3557a0f3547bd83b3ff6 Merge branch &#x27;experiment&#x27;</span><br><span class="line">a6b4c97498bd301d84096da251c98a07c7723e65 beginning write support</span><br><span class="line">0d52aaab4479697da7686c15f77a3d64d9165190 one more thing</span><br><span class="line">6d52a271eda8725415634dd79daabbc4d9b6008e Merge branch &#x27;experiment&#x27;</span><br><span class="line">0b7434d86859cc7b8c3d5e1dddfed66ff742fcbc added a commit function</span><br><span class="line">4682c3261057305bdd616e23b64b0857d832627b added a todo file</span><br><span class="line">166ae0c4d3f420721acbb115cc33848dfcc2121a started write support</span><br><span class="line">9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile</span><br><span class="line">964f16d36dfccde844893cac5b347e7b3d44abbc commit the todo</span><br><span class="line">8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme</span><br></pre></td></tr></table></figure><br>现在，假设在 v1.2 时你忘记给项目打标签，也就是在 <code>“updated rakefile”</code>提交。你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的<strong>校验和</strong>(或部分校验和)：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v1.2 9fceb02</span></span><br></pre></td></tr></table></figure></p>
<h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>默认情况下，<code>git push</code>命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到<br>共享服务器上。这个过程就像共享远程分支一样——你可以运行<code>git push origin &lt;tagname&gt;</code>。</p>
<p>如果想要一次性推送很多标签，也可以使用带有<code>--tags</code>选项的<code>git push</code>命令。这将会把所有不在远程仓库服务器上的标签全部传送到那里</p>
<h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><p>要删除掉你本地仓库上的标签，可以使用命令<code>git tag -d &lt;tagname&gt;</code>。<br>注意上述命令并不会从任何远程仓库中移除这个标签，你必须用<code>git push &lt;remote&gt;
:refs/tags/&lt;tagname&gt;</code>来更新你的远程仓库</p>
<p>这种操作有两个变体<br>第一种变体是<code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;</code>，这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。<br>第二种更直观的删除远程标签的方式是：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin --delete &lt;tagname&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>如果你想查看某个标签所指向的文件版本，可以使用<code>git checkout</code>命令， 虽然这会使你的仓库处于“分离头指针(detached HEAD)”的状态——这个状态有些不好的副作用：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0.0</span></span><br><span class="line">Note: checking out &#x27;2.0.0&#x27;.</span><br><span class="line">You are in &#x27;detached HEAD&#x27; state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout.</span><br><span class="line"></span><br><span class="line">If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example:</span><br><span class="line"></span><br><span class="line">  git checkout -b &lt;new-branch&gt;</span><br><span class="line"></span><br><span class="line">HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout 2.0-beta-0.1</span></span><br><span class="line"></span><br><span class="line">Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final </span><br><span class="line">HEAD is now at df3f601... add atlas.json and cover image</span><br></pre></td></tr></table></figure>
<p>在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任<br>何分支，并且将无法访问，除非通过确切的提交哈希才能访问。因此，如果你需要进行更改，比如你要修复旧<br>版本中的错误，那么通常需要创建一个新分支：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b version2 v2.0.0</span></span><br><span class="line">Switched to a new branch &#x27;version2&#x27;</span><br></pre></td></tr></table></figure><br>如果在这之后又进行了一次提交，<code>version2</code>分支就会因为这个改动向前移动， 此时它就会和<code>v2.0.0</code>标签稍<br>微有些不同，这时就要当心了。</p>
<h3 id="Git别名"><a href="#Git别名" class="headerlink" title="Git别名"></a>Git别名</h3><p>有一个小技巧可以使你的Git体验更简单、容易、熟悉：别名。我们不会在之后的章节中引用到或假定你使用过它们，但是你大概应该知道如何使用它们。<br>Git并不会在你输入部分命令时自动推断出你想要的命令。如果不想每次都输入完整的Git命令，可以通过git config文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.co checkout</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.br branch</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.ci commit</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.st status</span></span><br></pre></td></tr></table></figure>
<p>这意味着，当要输入<code>git commit</code>时，只需要输入<code>git ci</code>。 随着你继续不断地使用 Git，可能也会经常使用其<br>他命令，所以创建别名时不要犹豫。<br>在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中<br>添加你自己的取消暂存别名：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.unstage <span class="string">&#x27;reset HEAD --&#x27;</span></span></span><br></pre></td></tr></table></figure><br>这会使下面的两个命令等价：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git unstage fileA</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD -- fileA</span></span><br></pre></td></tr></table></figure><br>这样看起来更清楚一些。 通常也会添加一个last命令，像这样：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.last <span class="string">&#x27;log -1 HEAD&#x27;</span></span></span><br></pre></td></tr></table></figure><br>这样，可以轻松地看到最后一次提交：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git last</span></span><br><span class="line">commit 66938dae3329c7aebe598c2246a8e6af90d04646</span><br><span class="line">Author: Josh Goebel &lt;dreamer3@example.com&gt;</span><br><span class="line">Date: Tue Aug 26 19:48:51 2008 +0800</span><br><span class="line">  test for current head</span><br><span class="line">  Signed-off-by: Scott Chacon &lt;schacon@example.com&gt;</span><br></pre></td></tr></table></figure>
<p>可以看出，Git只是简单地将别名替换为对应的命令。 然而，你可能想要<strong>执行外部命令</strong>，而不是一个 Git 子命令。如果是那样的话，可以在<strong>命令前面加入<code>!</code>符号</strong>。 如果你自己要写一些与Git仓库协作的工具的话，那会很有用。我们现在演示将 git visual 定义为 gitk 的别名：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global alias.visual <span class="string">&#x27;!gitk&#x27;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章讲了许多东西，但真正的重头戏还没有开始，下一弹，我们将进入分支模型</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/posts/fed4c017.html</url>
    <content><![CDATA[<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><p>旨在记录IO流的相关内容，更加熟悉缓冲区(<strong>但不会提及最最简单基础的东西</strong>)，以及文件的输入输出相关的内容<br>这篇文档前面的部分将会更新C语言的相关内容，后面有空会跟上CPP的IO流<br><span id="more"></span></p>
<h2 id="最熟悉的反而是最不熟悉的"><a href="#最熟悉的反而是最不熟悉的" class="headerlink" title="最熟悉的反而是最不熟悉的"></a>最熟悉的反而是最不熟悉的</h2><p>对于任何一个cpp初学者来说，最先接触的函数一般除了<code>main()</code>之外就是<code>printf()</code>了，<code>scanf()</code>紧跟其后进入了我们的视野，但一定一直保留有很大的疑惑，首先是入门书不会教我们变长函数是怎么实现的，在参数列表里使用<code>...</code>这样的东西很有意思，在cpp里有其它的语言特性与之有关(形参包)，不过这不是我们这篇文档记录的重点。</p>
<p>初学者一定会在<code>scanf()</code>的输入缓冲区上栽跟头，我们就先来聊聊<code>scanf()</code></p>
<h2 id="scanf-的更多应用"><a href="#scanf-的更多应用" class="headerlink" title="scanf()的更多应用"></a>scanf()的更多应用</h2><p>要想更加仔细的探讨<code>scanf()</code>，必然要进入到源码中去咯<br>在<code>scanf()</code>其中会调用<code>_doscan()</code>这一个函数，这个函数主要的目的就是处理那些格式串<br>对于这个函数我的研究目的是确定是否对于<code>scanf(&quot;%d%c&quot;,d,c);</code>这样一条语句，c只能接收到空白字符，现在看来这个问题的答案是肯定的<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((kind != <span class="string">&#x27;c&#x27;</span>) &amp;&amp; (kind != <span class="string">&#x27;[&#x27;</span>) &amp;&amp; (kind != <span class="string">&#x27;n&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        ic = getc(stream);</span><br><span class="line">        nrchars++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">isspace</span>(ic));</span><br><span class="line">    <span class="keyword">if</span> (ic == EOF)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">/* outer while */</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (kind != <span class="string">&#x27;n&#x27;</span>)</span><br><span class="line">&#123;<span class="comment">/* %c or %[ */</span></span><br><span class="line">    ic = getc(stream);</span><br><span class="line">    <span class="keyword">if</span> (ic == EOF)</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">/* outer while */</span></span><br><span class="line">    nrchars++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码说明了<code>%</code>后接的不是<code>&quot;c&quot; , &quot;[&quot; , &quot;n&quot;</code>则会在缓冲区里去掉前面的空白字符，而在执行<code>scanf(&quot;%d%c&quot;,d,c);</code>时候，当变量d接收到数值，在缓冲区中把接收到的d删掉，后面还会跟着一个未删除的空白字符，<code>%c</code>就正好接受到了那个空白字符，因而c永远都是空白字符</p>
<p>要想避免这样一种情况的发生，有几种方法</p>
<p>1.使用非格式串，在<code>%d</code>和<code>%c</code>中间加一个空格，这样在输入的时候你必须多输入一个空格，这样并不好，没有包括所有的空白字符，万一你用的是换行呢<br>2.使用<code>%*c</code>可以跳过一个字符，这里*代表忽略，c代表忽略的大小，如果把c换成一个d那么将会忽略掉第一个输入的整型，将第二个输入的整型存入c<br>3.使用<code>fflush()</code>清理缓冲区，这样的方法也有一定的弊端</p>
<p>这里我倾向于<strong>使用第二种方法</strong>，当然这里也可以使用一个<code>getchar()</code>来跳过啦</p>
<p>对于上面这段清除空白字符的代码，我们需要注意，清除空白代码只在一开始匹配才去掉开头的空白字符</p>
<p>仔细看一看发现居然还有格式串和<code>%c</code>这样特殊，<code>%[</code>和<code>%n</code>，这是什么东西，从来没听说过嘛，仔细一查，<code>%n</code>会给变量赋值在匹配它时scanf处理的字符数量，比如<code>scanf(&quot;%d%d%n&quot;,x,y,z)</code>输入<code>10 20</code>那么x，y，z会分别匹配上10 20 5，所有对于这样一个格式串，确实不能清除空白字符</p>
<p>而<code>%[</code>就有趣了，这样一个东西，看起来很像是一种<strong>正则</strong>，它其实是<code>%[]</code>，<code>%[]</code>主要用来输入字符串，以控制输入的字符。如：<code>%[123]</code>则只输入集合123中的字符，遇到其他字符输入就结束，<code>%[^123]</code>表示不输入字符集123中的字符,即遇到123中的某个字符就停止输入。比如我们想用<code>scanf</code>实现输入一行，而一行中可能有空格，如果用<code>scanf(&quot;%s&quot;,str)</code>;则在输入遇到空格时就停止了输入，而我们用<code>scanf(&quot;%[^\n]&quot;,str);</code>则其再遇到换行时才结束输入，遇到其他人是字符都不会停止。</p>
<p><code>scanf()</code>是有返回值的，除了返回-1表示输入出错以外，输出多少，表示成功匹配了(<strong>前</strong>)多少个值，如果一个没匹配上，在其<strong>之后匹配的都失败</strong>。</p>
<h2 id="缓冲区的引入"><a href="#缓冲区的引入" class="headerlink" title="缓冲区的引入"></a>缓冲区的引入</h2><p>在上面讲到<code>scanf()</code>时候的第三种方法时谈到了缓冲区，其实这是一块用于临时存放的内存。<br>我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取，这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。</p>
<p>又比如，我们使用打印机打印文档，由于打印机的打印速度相对较慢，我们先把文档输出到打印机相应的缓冲区，打印机再自行逐步打印，这时我们的CPU可以处理别的事情。现在您基本明白了吧，缓冲区就是一块内存区，它用在输入输出设备和CPU之间，用来缓存数据。它使得低速的输入输出设备和高速的CPU能够协调工作，避免低速的输入输出设备占用CPU，解放出CPU，使其能够高效率工作。</p>
<p>其实在linux下系统调用<code>read()</code>与<code>write()</code>函数参数列表就要给出buf<br>我们可以把stdout也看作一个文件，对于文件的IO，本质上都是调用了<code>read()</code>、<code>write()</code>，以及<code>lseek()</code>等等这样的系统调用<br>(注解：所有打开的文件都有一个当前文件偏移量（current file offset），以下简称为 cfo。cfo 通常是一个非负整数，用于表明文件开始处到文件当前位置的字节数，使用 lseek 函数可以改变文件的 cfo )<br><a href="https://blog.csdn.net/qq_44096670/article/details/121632471">关于缓冲区的具体实现请点击这里</a></p>
<h2 id="C-IO流"><a href="#C-IO流" class="headerlink" title="C++ IO流"></a>C++ IO流</h2><p>To be continue</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>Git使用_第1弹</title>
    <url>/posts/392f5636.html</url>
    <content><![CDATA[<h1 id="Git使用-第1弹"><a href="#Git使用-第1弹" class="headerlink" title="Git使用_第1弹"></a>Git使用_第1弹</h1><p><strong>前言</strong>:<br>在写Sast-Evento的时候深刻意识到了自己Git使用相关知识的匮乏，Git作为版本控制功能强大，我却只会删仓库(悲)。痛定思痛，决定好好学一学Git。<br>本系列为<code>&quot;Pro Git&quot;</code>这本书的学习笔记，感谢编写这本书的贡献者们</p>
<span id="more"></span>
<h1 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h1><p>分布式版本控制系(Distributed Version Control System，简称DVCS) 在这类系统中,客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来，包括完整的历史记录。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的clone操作，实际上都是一次对代码仓库的完整备份。<br>Git就是一种分布式的版本控制系统</p>
<h1 id="Git的一些特点"><a href="#Git的一些特点" class="headerlink" title="Git的一些特点"></a>Git的一些特点</h1><h2 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h2><p>Git和其它版本控制系统的主要差别在于 Git 对待数据的方式。从概念上来说，其它大部分系统以文件变更列表的方式存储信息，这类系将它们存储的信息看作是一组基本文件和每个文件随时间逐步累积的差异，它们通常称作<strong>基于差异</strong>的版本控制。如下图<br><img src="/images/Git使用_第一弹_图1.png" width="100%" height="100%"><br>而Git不按照以上方式对待或保存数据。反之，Git更像是把数据看作是对小型文件系统的一系列快照。在Git中，每当你提交更新或保存项目状态时，它基本上就会对当时的全部文件<strong>创建一个快照并保存这个快照的索引</strong>。为了效率，如果文件没有修改，Git<strong>不再重新存储</strong>该文件，而是只保留一个链接指向之前存储的文件。Git对待<br>数据更像是一个快照流。如下图<br><img src="/images/Git使用_第一弹_图2.png" width="100%" height="100%"></p>
<h2 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h2><p>在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p>
<h2 id="Git保证完整性"><a href="#Git保证完整性" class="headerlink" title="Git保证完整性"></a>Git保证完整性</h2><p>Git中所有的数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git用以计算校验和的机制叫做 SHA-1 散列。</p>
<blockquote>
<p>事实上，校验和在数学上仍然有两个文件不同但校验和相同的情况，但是几乎只要不是恶意设计，碰撞的概率小到可以忽略不计，使用更复杂的方法还可以使得概率进一步降低</p>
</blockquote>
<h2 id="Git一般只添加数据"><a href="#Git一般只添加数据" class="headerlink" title="Git一般只添加数据"></a>Git一般只添加数据</h2><p>你执行的Git操作，几乎只往Git数据库中 添加 数据。你很难使用Git从数据库中删除数据，也就是说Git几乎不会执行任何可能导致文件不可恢复的操作</p>
<h1 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h1><p>Git有三种状态，你的文件可能处于其中之一: 已提交(committed)、已修改(modified)和已暂存(staged)。</p>
<ul>
<li>已修改表示修改了文件，但还没保存到数据库中。</li>
<li>已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li>
<li>已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>这会让我们的Git项目拥有三个阶段: <strong>工作区</strong>、<strong>暂存区</strong>以及<strong>Git目录</strong>。</p>
<p><strong>工作区</strong>是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p><strong>暂存区</strong>是一个文件，保存了下次将要提交的文件列表信息，一般在Git仓库目录中。按照 Git 的术语叫做“索引”，不过一般说法还是叫“暂存区”。</p>
<p><strong>Git仓库目录</strong>是Git用来保存项目的元数据和对象数据库的地方。这是Git中最重要的部分，从其它计算机克隆仓库时，复制的就是这里的数据。</p>
<p><strong>基本的Git工作流程如下</strong>：</p>
<ol>
<li>在工作区中修改文件。</li>
<li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li>
<li>提交更新，找到暂存区的文件，将快照永久性存储到Git目录。</li>
</ol>
<blockquote>
<p>如果Git目录中保存着特定版本的文件，就属于<strong>已提交</strong>状态。如果文件已修改并放入暂存区，就属于<strong>已暂存</strong>状态。如果自上次检出后，作了修改但还没有放到暂存区域，就是<strong>已修改</strong>状态。</p>
</blockquote>
<h1 id="Git配置文件"><a href="#Git配置文件" class="headerlink" title="Git配置文件"></a>Git配置文件</h1><p>在Windows操作系统下通过下面这条指令获得配置文件的位置<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --list --show-origin</span></span><br></pre></td></tr></table></figure></p>
<h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><p>安装完Git之后，要做的第一件事就是设置你的用户名和邮件地址。这一点很重要，因为每一个Git提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.name <span class="string">&quot;John Doe&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git config --global user.email johndoe@example.com</span></span><br></pre></td></tr></table></figure>
<p>再次强调，如果使用了<code>--global</code>选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情，Git都会使用那些信息。当你想针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有<code>--global</code>选项的命令来配置。很多GUI工具都会在第一次运行时帮助你配置这些信息。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>我认为配置Git环境这个事情，应当在安装时顺带查查帮助文档，而不是写在笔记里，反正每次都要找个地方查，还不如留给时刻更新的强大的互联网(乐)<br>上面都是一些前言，具体需要完成的部分需要来iu给下一份blog</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Git</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch学习_1</title>
    <url>/posts/6c7f2ed0.html</url>
    <content><![CDATA[<h1 id="Pytorch学习-1"><a href="#Pytorch学习-1" class="headerlink" title="Pytorch学习_1"></a>Pytorch学习_1</h1><p>也是正式的开始学pytorch了，准备充分，炼丹去，前面的部分主要就是写一些基础的东西</p>
<span id="more"></span>
<h2 id="Python中的切片"><a href="#Python中的切片" class="headerlink" title="Python中的切片"></a>Python中的切片</h2><p>关于numpy中n维数组的表示方法</p>
<ul>
<li><code>:</code>表示一整行</li>
<li><code>a:b</code>表示<code>a&lt;=x&lt;b</code>的元素，也就是说<code>1:3</code>表示第二、三个</li>
<li><code>0</code>表示第一个元素，这和c/c++都一样</li>
<li><code>-1</code>表示最后一个元素</li>
</ul>
<h2 id="关于tensor单独维度的计算"><a href="#关于tensor单独维度的计算" class="headerlink" title="关于tensor单独维度的计算"></a>关于tensor单独维度的计算</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单独维度求和示例程序</span></span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">a = torch.rand(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(torch.<span class="built_in">sum</span>(a, dim=<span class="number">2</span>))</span><br><span class="line"><span class="comment"># dim即在其余指标固定情况下，第n个数字指标求和相消</span></span><br><span class="line"><span class="comment">#体现在多维数组上即从外向内数相同的第n层，不跨越中括号的相同子tensor对应元素完全相加</span></span><br></pre></td></tr></table></figure>
<p>该部分的某次运行结果如下<br><img src="/images/Pytorch学习_1_图1.png" width="70%" height="70%"></p>
<h2 id="记录一些简单的函数"><a href="#记录一些简单的函数" class="headerlink" title="记录一些简单的函数"></a>记录一些简单的函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = torch.arrange(<span class="number">12</span>)</span><br><span class="line"><span class="comment"># 生成一维行向量，从1到11 </span></span><br><span class="line">torch.randn(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 创建⼀个形状为(3,4)的张量。每个元素都从均值为0、标准差为1的标准⾼斯分布（正态分布）中随机采样</span></span><br><span class="line">x = torch.normal(means, std, out=<span class="literal">None</span>)</span><br><span class="line"><span class="comment"># 返回一个张量，包含从给定参数means，std的离散正态分布中抽取随机数</span></span><br><span class="line"><span class="comment"># 均值means是一个张量，包含每个输出元素相关的正态分布的均值</span></span><br><span class="line"><span class="comment"># 标准差std是一个张量，包含每个输出元素相关的正态分布的标准差</span></span><br><span class="line"><span class="comment"># 均值和标准差的形状不须匹配，但每个张量的元素个数须相同</span></span><br><span class="line">x.reshape(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 将矩阵变成3行4列的矩阵，即重排</span></span><br><span class="line"><span class="comment"># -1代表无此列</span></span><br></pre></td></tr></table></figure>
<h2 id="神经网络训练基础"><a href="#神经网络训练基础" class="headerlink" title="神经网络训练基础"></a>神经网络训练基础</h2><p>在介绍深度神经网络之前，我们需要了解神经网络训练的基础知识。接下来奖介绍神经网络训练的整个过程，包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型</p>
<h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><p>回归是能为一个或多个自变量和因变量之间关系建模的一类方法。在自然科学和社科领域，回归经常用来表示输入和输出之间的关系</p>
<p><strong>线性回归的基本元素</strong>如下：<br>为了开发模型，我们需要收集一个真实的数据集，在机器学习的术语中，该数据集称为<strong>训练数据集</strong>或<strong>训练集</strong><br>其中的每行数据被称为<strong>样本</strong>或<strong>数据点</strong>或<strong>数据样本</strong><br>我们把试图预测的目标称为<strong>标签</strong>或<strong>目标</strong><br>预测所依据的自变量称为<strong>特征</strong>或<strong>协变量</strong></p>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><p><strong>线性假设</strong>是指目标可以表示为特征的加权和，其中加权和的系数称为<strong>权重</strong>，后面跟和系数称为<strong>偏置</strong>、<strong>偏移量</strong>或<strong>截距</strong><br>因为观测误差，所以即使确信特征与标签的潜在关系是线性的，也会加入一个噪声项来考虑观测误差带来的影响</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>在考虑如何用模型拟合数据之前，我们需要确定一个拟合程度的度量。损失函数能够量化目标的实际值与预测值之间的差距<br>通常会使用非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0<br>回归问题中最常用的损失函数时平方误差函数<br>当样本$i$的预测值为$\hat{y}^{(i)}$，其相应的真实标签为$y^{(i)}$时，平方误差可以定义为以下公式</p>
<script type="math/tex; mode=display">
l^{(i)}(\mathbf{w},b)=\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2</script><p>其中常数$\frac{1}{2}$不会造成本质的差别，只是在形式上简单一些。由于训练数据集并不受我们控制，使用经验误差只是关于模型参数的函数<br>由于平方误差函数中的二次方项，估计值和观测值之间较大的差异将导致更大的损失，为了度量模型在整个数据集上的质量，我们需要计算训练集n个样本上的损失均值(也等价于求和)</p>
<script type="math/tex; mode=display">
L(\mathbf{w},b)=\frac{1}{n}\sum^{n}_{i=1}l^{(i)}(\mathbf{w},b)=\frac{1}{n}\sum^{n}_{i=1}\frac{1}{2}(\mathbf{w}^T\mathbf{x}^{(i)}+b-y^{(i)})^2</script><p>在训练模型时，我们希望寻找一组参数$(\mathbf{w}^<em>,b^</em>)$，这组参数能最小化在所有训练样本上的总损失。如下</p>
<script type="math/tex; mode=display">
\mathbf{w}^*,b^*=\sideset{}{}{\text{argmin }}_{\mathbf{w},b} L(\mathbf{w},b)</script><p>通过计算可以证明，这里使用的最小化均方误差法等价于对线性模型的极大似然估计</p>
<blockquote>
<p>在学到这里的时候，我想到了NFL定义(No Free Lunch Theoren，没有免费的午餐定理)，实际上关系不大，NFL定理表述的是对于特定的问题，我们比较不同模型的才有意义</p>
</blockquote>
<h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><p>线性回归的解可以用一个公式简单地表达表达出来，这类解被称为解析解(analytical solution)，但并不是所有的问题都存在解析解，事实上大部分问题都不会存在解析解，解析解无法广泛应用在深度学习中</p>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><p>利用梯度下降法可以几乎优化所有深度学习，他通过不断地在损失函数递减的方向上更新参数来降低误差，具体的内容这里不进行展开</p>
<h3 id="用模型进行预测"><a href="#用模型进行预测" class="headerlink" title="用模型进行预测"></a>用模型进行预测</h3><p>给定已经完成学习的模型，输入特征估计目标的这一过程，在深度学习中的标准术语中被称为<strong>预测</strong>或<strong>推断</strong></p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch学习_2</title>
    <url>/posts/f5767f6a.html</url>
    <content><![CDATA[<h1 id="Pytorch学习-2"><a href="#Pytorch学习-2" class="headerlink" title="Pytorch学习_2"></a>Pytorch学习_2</h1><p>隔了有一段时间没写东西了，前一篇主要是一些准备的工作，这次我们从线性回归开始</p>
<span id="more"></span>
<h2 id="概览神经网络"><a href="#概览神经网络" class="headerlink" title="概览神经网络"></a>概览神经网络</h2><ul>
<li>机器学习模型中的关键要素是训练数据、损失函数、优化算法，还有模型本身。</li>
<li>矢量化使数学表达上更简洁，同时运行的更快</li>
<li>最小化目标函数和执行极大似然估计等价</li>
<li>线性回归模型也是一个简单的神经网络</li>
</ul>
<h2 id="线性回归的从零开始实现"><a href="#线性回归的从零开始实现" class="headerlink" title="线性回归的从零开始实现"></a>线性回归的从零开始实现</h2><p>先把包引入一下<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">%matplotlib inline</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> d2l <span class="keyword">import</span> torch <span class="keyword">as</span> d2l</span><br></pre></td></tr></table></figure><br>注意第一行中的<code>%matplotlib inline</code>语句被称为魔法语句。作用就是这样图像就会出现在Jupyter Notebook里面，而不是一个新窗口里。对于纯纯使用vscode的我来说用处不大</p>
<p>首先为了简单起见，我们用带有噪声的线性模型手动构造一个人造数据集。首先生成一个包含1000个样本的数据集，每个样本包含从标准正态分布<br>我们使用线性模型参数$\mathbf{w}=[2,-3.4]^T$、$b=4.2$和噪声项$\epsilon$生成数据集及其标签：</p>
<script type="math/tex; mode=display">
\mathbf{y}=\mathbf{Xw}+b+\epsilon</script><p>$\epsilon$可以被视作模型预测和标签时的潜在观测误差。在这里我们认为标准假设成立，即$\epsilon$服从均值为0的正态分布。为了简化问题，我们将标准差设为0.01.下面的代码生成数据集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">synthetic_data</span>(<span class="params">w, b, num_examples</span>): <span class="comment">#@save</span></span><br><span class="line"><span class="comment"># 生成y=Xw+b噪声</span></span><br><span class="line">  X = torch.normal(<span class="number">0</span>, <span class="number">1</span>, (num_examples, <span class="built_in">len</span>(w)))</span><br><span class="line">  y = torch.matmul(X, w) + b</span><br><span class="line">  y += torch.normal(<span class="number">0</span>, <span class="number">0.01</span>, y.shape)</span><br><span class="line">  <span class="keyword">return</span> X, y.reshape((-<span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注:<code>torch.matmul</code>是<code>tensor</code>的乘法，输入可以是高维的。当输入都是二维时，就是普通的矩阵乘法，和<code>tensor.mm</code>函数用法相同。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">true_w = torch.tensor([<span class="number">2</span>, -<span class="number">3.4</span>])</span><br><span class="line">true_b = <span class="number">4.2</span></span><br><span class="line">features, labels = synthetic_data(true_w, true_b, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch学习_3</title>
    <url>/posts/82714ffc.html</url>
    <content><![CDATA[<h1 id="Pytorch学习-3"><a href="#Pytorch学习-3" class="headerlink" title="Pytorch学习_3"></a>Pytorch学习_3</h1><p>距离上次写 pytorch 相关的东西已经过了很久，也是看了另一些去学习</p>
<span id="more"></span>
<h2 id="一些变化"><a href="#一些变化" class="headerlink" title="一些变化"></a>一些变化</h2><p>我并不是很喜欢 AI ，感觉大家都过于看重 AI 了，其实它也就是一个普普通通的工具罢了，而且使用的技术入门十分容易，并没有大家想象的那么高深，它不是一个万能钥匙，能开世界上任何一扇门<br>中文互联网上有太多 pytorch 的资料了，但是这些资料大多都不止是在讲 pytorch 本身，他们大多有一个”利好初学者”的标签，但是往往这时候意味着他们对 pytorch 本身这个库的诠释完全不足，所以最近我选择了直接去看 pytorch 的官方文档，总算是总结出来了一些东西。</p>
<h2 id="Tensor-的一些新理解"><a href="#Tensor-的一些新理解" class="headerlink" title="Tensor 的一些新理解"></a>Tensor 的一些新理解</h2><p>pytorch 里面我个人认为最重要的库就是 Tensor 库，它定义了 Tensor 和其他一系列和 Tensor 计算有关的函数。但 Tensor 这个名字很有趣，它来自于数学，它的标准中文译名叫<strong>张量</strong>，在中文互联网(bing)上搜索 Tensor ，你得到的前几条信息都是深度学习 pytorch 里的 Tensor ，但是你如果搜索它的中文名张量，你得到的就是数学和物理里的那个张量，这很有趣了 :)</p>
<blockquote>
<p>我个人认为 Tensor 是纯纯的名词污染，我并不认为这个东西它是一个张量在欧式空间上的矩阵表示，即使它确实等价，但你不可以用一个东西的片面去描述一个东西，就像，还有些朋友认为它和 numpy 里的数组之间最大的差别是它可以交给 GPU 去处理所以要取一个和数组不一样的高大上的名字，但我作为一个 C/C++ 程序员，成天能和底层打交道，觉得这个纯是扯了</p>
</blockquote>
<p>言归正传，在我看来 Tensor 和普通的n维数组最大的差别是，Tensor 中有一个计算图累加的概念，简单来说，Tensor 这个类中有一个成员变量”存储”了得到这个 Tensor 通过了什么运算，这个就是计算图，你使用的 Tensor 只会调用 pytorch 里的 Tensor 数学运算函数进行运算，原因是这些数学运算函数不止做了 Tensor 的运算，他们同时承担了这个成员变量的计算图计算的内容，而如果你自己实现一个 Tensor 的运算，你就要手动去实现这个计算图拼合的行为。</p>
<p>懵懵的？举个例子，<code>torch.matmul</code> 是 <code>Tensor</code> 的乘法，在上一章我们讲过，事实上 Tensor 的运算都是<strong>输入(单个或者多个) Tensor 输出 Tensor 的函数</strong>，对于乘法，它实质上会提取输入的两个 <code>Tensor</code> 里面成员变量存储的计算图，用一个乘号把他们相连，同时数值也会被相乘，最后输出的 Tensor 就是一个数值是前两个 Tensor 计算的结果，同时计算图是前两个 Tensor 的计算图加一个乘号拼合的结果</p>
<h3 id="看看-Tensor-机理"><a href="#看看-Tensor-机理" class="headerlink" title="看看 Tensor 机理"></a>看看 Tensor 机理</h3><p>你也许会好奇，口说无凭，Tensor 在 pytorch 上的原文就是说的不同于 numpy 的 ndarrays 之处就只是可以在 GPU 或其他硬件加速器上运行:</p>
<blockquote>
<p>Tensors are similar to NumPy’s ndarrays, <strong>except that Tensors can run on GPUs or other hardware accelerators</strong>. In fact, Tensors and NumPy arrays can often share the same underlying memory, eliminating the need to copy data (see Bridge with NumPy). Tensors are also optimized for automatic differentiation (we’ll see more about that later in the Autograd section). If you’re familiar with ndarrays, you’ll be right at home with the Tensor API. If not, follow along! (<a href="https://pytorch.org/tutorials/beginner/basics/Tensorqs_tutorial.html">https://pytorch.org/tutorials/beginner/basics/Tensorqs_tutorial.html</a>)</p>
</blockquote>
<p>以及看看文档里说的 Tensor 的成员变量</p>
<blockquote>
<p>In PyTorch, a regular Tensor is a multi-dimensional array that is defined by the following components:</p>
<blockquote>
<p><strong>Storage</strong>: The actual data of the Tensor, stored as a contiguous, one-dimensional array of bytes.<br><strong>dtype</strong>: The data type of the elements in the Tensor, such as torch.float32 or torch.int64.<br><strong>shape</strong>: A tuple indicating the size of the Tensor in each dimension.<br><strong>Stride</strong>: The step size needed to move from one element to the next in each dimension.<br><strong>Offset</strong>: The starting point in the storage from which the Tensor data begins. This will usually be 0 for newly created Tensors.</p>
</blockquote>
<p>These components together define the structure and data of a Tensor, with the storage holding the actual data and the rest serving as metadata.<br>(<a href="https://pytorch.org/docs/stable/storage.html">https://pytorch.org/docs/stable/storage.html</a>)</p>
</blockquote>
<p>这压根没提到计算图啊，博主你这是给我们干哪来了，这还是 Tensor 么，别急，让我们深入代码看看实际的机理来佐证我们刚刚说的话</p>
<p>首先看 Python 侧的 Tensor 定义，发现它继承自一个 <code>torch._C.TensorBase</code> ，同时追踪观察 <code>torch.matmul</code> 发现追踪到了一个 <code>.pyi</code> 的文件里，所以其实现明显不是 python 实现的，其实实际上它和 Tensor 都是通过 PyBind11 绑定到 C++ 的。让我们来看看 C++ 里它是怎么实现的</p>
<p>相关的文件有</p>
<ul>
<li><code>aten/src/ATen/core/Tensor.h</code></li>
<li><code>aten/src/ATen/core/Tensor.cpp</code></li>
<li><code>aten/src/ATen/core/TensorBase.h</code></li>
</ul>
<p>在 TensoBase 里有一个这样的成员变量<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c10::intrusive_ptr&lt;TensorImpl, UndefinedTensorImpl&gt; impl_;</span><br></pre></td></tr></table></figure></p>
<p>在这里提到的 <code>TensorImpl</code> 中，有一大段话描述了下面这个成员变量，这就是存储计算图的实际指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;c10::AutogradMetaInterface&gt; autograd_meta_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>在上面的注释当中你可以知道 <code>autograd_meta_</code> 指向了和梯度有关的信息，比如 <code>grad_fn</code></p>
<p>你自己构造的 Tensor 是计算图中的叶子节点，它的grad_fn 为 None</p>
<p>这就是计算图的存储，可想而知，其实计算的函数会更新这个 Tensor 的计算图，而 Tensor 的核心其实就是这个在 C++ 侧没被文档所写出来的计算图相关的成员变量，当你计算梯度的时候，正是查看了这个成员变量的信息，因而能够计算出梯度来，所以能计算梯度的也是 Tensor</p>
<blockquote>
<p>如果要我给 Tensor 下一个定义的话，那么我会说，<strong>Tensor 就是一个保存了历史计算方式的多维数组类，同时其有在 CPU 或其他来加速存储的能力</strong><br>其实在 GPU 上跑个人感觉完全不是一个核心的概念值得多言，难道计算机图形学里的 shaders 算的那些东西都是 Tensor 吗</p>
</blockquote>
<h2 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h2><p>这篇博客的另一位贡献者 Github@besthope-official ，一开始是他的探索才让我研究这个比较容易，这份博客也有他的一份力</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Pytorch学习_4</title>
    <url>/posts/1c15da5f.html</url>
    <content><![CDATA[<h1 id="Pytorch学习-4"><a href="#Pytorch学习-4" class="headerlink" title="Pytorch学习_4"></a>Pytorch学习_4</h1><p>在上一章我们知道了 pytorch 的核心机制 Tensor 的计算图与梯度运算，接下来一切都是对它的封装</p>
<span id="more"></span>
<h2 id="相关的概念"><a href="#相关的概念" class="headerlink" title="相关的概念"></a>相关的概念</h2><p><code>nn.Parameter</code>，<code>nn.forward</code>，<code>nn.Module</code><br>我一开始学的时候觉得这些东西好复杂，一点都没有章法，我自己学习的时候时常会想，如果使用 Rust 里的 Trait 概念或者 Haskell 的 TypeClass 是不是能把它描述的更清楚一些，但是初学者友好的文档并不会告诉我这些。<br>在看完 Pytorch 的官方文档后我终于看明白了<br>关于看完 Pytorch 官方文档后一个上午写出来的一个手写数字识别 HelloWorld ：<a href="https://github.com/feipiao594/mnist_numrecg">https://github.com/feipiao594/mnist_numrecg</a></p>
<h2 id="nn-Module"><a href="#nn-Module" class="headerlink" title="nn.Module"></a><code>nn.Module</code></h2><p>这是一个对 Tensor 的封装与管理函数，你需要实现的函数有两个 <code>__init__</code> 与 <code>forward</code> 函数，继承自 <code>nn.Module</code> 的层或者网络，有一个内秉的 parameter 集合，在 <code>__init__</code> 里面使用 <code>nn.Parameter</code> 就会把这个变量的引用交给这个 parameter 集合，如果你使用 <code>nn.Linear()</code> 里面也有 <code>nn.Parameter</code> 也会自动注册进去，这个函数就是起到这样的一个作用，同时因为他指定的是要被学习的参数，所以他也会把你输入进去的 Tensor 的 <code>require_grad</code> 变成 false。<br><code>forward</code> 函数就是数值前向传播，就把在 <code>__init__</code> 定义的计算方法拿出来对输入的值运算一下 </p>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>举个例子<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)</span><br></pre></td></tr></table></figure><br><code>model.parameters()</code> 就是我们刚刚说到的 <code>nn.Module</code> 的子类有一个内秉的 parameter 集合，你可以通过这个方法传给优化器进行注册</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> batch, (X, y) <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataloader):</span><br><span class="line">        <span class="comment"># Compute prediction and loss</span></span><br><span class="line">        X, y = X.to(device), y.to(device)</span><br><span class="line">        pred = model(X)</span><br><span class="line">        loss = loss_fn(pred, y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Backpropagation</span></span><br><span class="line">        loss.backward()</span><br><span class="line">        optimizer.step()</span><br><span class="line">        optimizer.zero_grad()</span><br></pre></td></tr></table></figure>
<p>具体使用时格式非常固定，loss 函数计算误差最后输出的就还是一个 Tensor ，其实里面还是保留计算图的，<code>loss.backward()</code> 就是用 Tensor 的 backward 把所有要学习的参数的梯度算出来并且存储在那些参数的成员变量里(毕竟参数也是 Tensor 嘛，它有 grad 成员变量作为他的梯度值很正常)，接着调用 <code>optimizer.step()</code> 来读取注册的这些变量的 grad 并执行优化，所以优化器和网络就完全解离，其实核心仍然在 Tensor 的梯度运算上</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>听说 pytorch 已经很少有人像这样写网络了，大家都用 lightning ，后面有空我也会尝试一下的</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>RopUI开发_第1弹</title>
    <url>/posts/4de565e4.html</url>
    <content><![CDATA[<h1 id="RopUI开发-第1弹"><a href="#RopUI开发-第1弹" class="headerlink" title="RopUI开发_第1弹"></a>RopUI开发_第1弹</h1><p>RopUI，是我目前正在制作的一个项目，我的目的是开发一个跨平台的一个 UI 框架。制作这个东西的目的其实相当的明确，我就是为了写博客，做视频，以及作为一个我的求职所用的一个项目。如今我的设计进入的一个开头的阶段，便有了这样的一篇博客。虽然我有一个短期的目标，但这个项目本身作为一个超长线的项目，我想关于开发时候的博客也会有不少吧。</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在刚刚进入大学之时，其实就有未来走客户端开发的一个倾向，当时加入我校社团，参加 C++ 组的相关的活动，也是凭借自己很久之前就有 Qt 的一些相关经验，自然后来也就走上了客户端开发的一条道路</p>
<p>写 Qt 的过程当中，一开始编写项目的时候，由于缺乏计算机网络的相关知识，我第一个遇到的问题就是网络相关的问题，当时是做一个最最简单的象棋的客户端，我们用到了 Qt 的 <code>QNetworkAccessManager</code>，这东西用起来还是很方便的。只要绑定一下信号槽，post 完接受到服务器返回的信息，回调自然而然的就会被启动。在这个过程当中并不会阻碍 UI 的运行，一切都好像完全没有关系，就像魔法一样。</p>
<p>在这个时候，我还对此并不好奇，也并不明白为什么在编程语言的世界会有”事件”这个概念，好像计算机诞生的时候就有了这样的行为，默认它是存在的，我只是非常高兴的写下 Qt 的信号槽，或者是像 Android 那样调用了系统的库，拼一下拼图，很好啊，这个世界上的应用都是这么写出来的吧，我心里想着</p>
<p>稍过一段时间，我了解到了多线程多进程，我慢慢开始察觉，这件事情没有那么简单，计算机如此简单的一个模型，在操作系统的调度下，程序只能一路走到黑，汇编/二进制代码才不会管你什么 OOP，在他们的世界里没有什么对象不对象的，对于单线程来说，只有指令流，一个时间就是只能有一条指令被送到 CPU 里被执行(我们不考虑流水线，分支预测，乱序执行等乱七八糟的硬件行为，单纯只是说顺序执行)，这些执行的指令排列组合，赋予了这个二进制的世界色彩和美丽。但他们唯独不能在单线程的情况下突破界限：我不可能即在管我显示器上显示的图样，又管网络有没有收到，我必须分步骤去做</p>
<p>看过我此前<a href="https://feipiao594.github.io/posts/9b424f3e.html">深入异步通用概念</a>这片博客的朋友应该知道，我现在已经明了这样的事情究竟是怎么发生的。因此我有一个执念，我想要在 UI 线程里也同样能够调度网络请求。</p>
<p>是的，我希望我这个 UI 框架不依赖 glfw 这样的库，同时由于绝大部分比较裸的事件库其实是网络库，并不太支持自己添加事件源。我决定亲自完成关于窗口，关于图像绘制，关于底层事件调度器的工作</p>
<p>这将是一个完完全全直接接入底层的 UI 框架。</p>
<p>其实我看网上关于这方面的描述并不是很多，客户端，或者说泛前端，在今年早就已经开始退化。可我并不希望这些知识逐渐遗失，我希望我的努力能为社区做出一点点贡献。为大家了解所谓我们这帮 UI 仔，所做的一切也没有那么的简单</p>
<h2 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h2><p>当确定了目标之后，我就开始了前期调研，距离我毕业还有大概半年多一点的时间，我其实并没有很充分的机会去完成这样的一个事情，但我会尽力。<br>我当下仍然在使用 Gentoo Linux 作为我的主力机，其上和图形有关的一些环境是 Wayland 以及渲染库使用的是 Mesa3D。Linux 在这一个方面有一个非常大的优势，在 2025 年的二月份，我曾了解过 drm 的工作原理，并且成功让一个程序在 tty 下切换图形状态为 graphic，显示一张直接所谓 CPU 绘制的图像，其实核心原理就是调用 libdrm 库上的一些函数，初始化，创建 framebuffer，然后 mmap 映射到内存空间，这种方式创建的 framebuffer 就是一个内存里的二维数组，在上面写入 rgba 信息提交即可</p>
<p><img src="/images/RopUI开发_第1弹_图1.png" width="100%" height="100%"></p>
<blockquote>
<p>这是天依蓝 #66ccff UwU</p>
</blockquote>
<p>我还让它成功作为我树莓派的启动程序顶掉了桌面环境(笑)</p>
<p>在此以后，我还在暑假实习的空余时间学习了计算机图形学的相关知识。了解了一些关于渲染的原理<br>总之，各种原因叠加下来，我决定先为 Linux wayland 做我的一个支持，现在看来这个选择也挺正确的。</p>
<p>那么我们第一步就是要实现一个可靠的 Async Runtime</p>
<h2 id="EventLoopCore-EventLoopBackend-EventSource"><a href="#EventLoopCore-EventLoopBackend-EventSource" class="headerlink" title="EventLoopCore/EventLoopBackend/EventSource"></a>EventLoopCore/EventLoopBackend/EventSource</h2><p>作为异步实现的核心，任何一个 UI 框架都必须有所谓的 IO syscall，他们有的是 IO 多路复用，有的是真正的异步 IO,这并不重要，但是他们必然在每一个线程都会存在，而这些处理 IO 的线程就必然会进入到一个状态：他们只能做 IO 密集型任务，不能承担计算密集型任务，换而言之，这种状态让他们和同步执行的逻辑再也不会关联起来了</p>
<p>一开始我是打算直接设计 EventLoop 的，但后来改名叫 <code>EventLoopCore</code> 了，原因很简单，事实上按照现在的设计，每一个 IO syscall/系统 API 都将对应一个 <code>EventLoopCore</code>，这些 <code>EventLoopCore</code> 继承自 <code>IEventLoopCore</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IEventLoopCore</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IEventLoopCore</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyInitialChanges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">applyPendingChanges</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">runOnce</span><span class="params">(<span class="type">int</span> timeout = <span class="number">-1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addSource</span><span class="params">(IEventSource* source)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeSource</span><span class="params">(IEventSource* source)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">IEventLoopCore</span><span class="params">(std::unique_ptr&lt;IEventCoreBackend&gt; backend)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dispatchRawEvents</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">applyPendingChanges</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::unique_ptr&lt;IEventCoreBackend&gt; backend_;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;IEventSource*&gt; sources_;</span><br><span class="line">    std::vector&lt;IEventSource*&gt; pending_add_;</span><br><span class="line">    std::vector&lt;IEventSource*&gt; pending_remove_;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> in_dispatch_ = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个实现并不复杂，主要是对 IO syscall/系统 API 的一个封装，你可以简单调用 <code>runOnce</code> 运行等待</p>
<p>但其实 <code>EventLoopCore</code> 也只是一个代理者，核心的处理逻辑在相对应的 Backend，<code>EventLoopCore</code> 提供了统一上传事件的接口 <code>addSource</code> 与 <code>removeSource</code>，递交一个 <code>IEventSource</code>，会加入缓冲区，等待一个合适的时机真正加入 backend 的 Source 里</p>
<p>这里的 <code>EventLoopBackend</code> 和 <code>EventSource</code> 是真正处理事件的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IEventCoreBackend</span> &#123;</span><br><span class="line">    BackendType type_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IEventCoreBackend</span>(BackendType type) : <span class="built_in">type_</span>(type) &#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IEventCoreBackend</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">addSource</span><span class="params">(IEventSource* source)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 添加事件源</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">removeSource</span><span class="params">(IEventSource* source)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 移除事件源</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">wait</span><span class="params">(<span class="type">int</span> timeout)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> RawEventSpan <span class="title">rawEvents</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">BackendType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type_;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IEventSource</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    BackendType type_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">IEventSource</span>(BackendType type) : <span class="built_in">type_</span>(type) &#123;&#125;;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IEventSource</span>() = <span class="keyword">default</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">arm</span><span class="params">(IEventCoreBackend&amp; backend)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 绑定到 backend</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">disarm</span><span class="params">(IEventCoreBackend&amp; backend)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从 backend 解绑</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">matches</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* raw_event)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断某个原始回调是否属于自己</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dispatch</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* raw_event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 调用回调</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSourceMatchBackend</span><span class="params">(IEventCoreBackend* backend)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type_ == backend-&gt;<span class="built_in">getType</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 Linux 下 <code>EventSource</code> 需要你传入一个 fd 作为其监听的文件描述符，把 <code>EventSource</code> 传入 <code>EventLoopCore</code> 的 <code>addSource</code> 方法中，会透穿给 <code>Backend</code>，Backend 会在分发收到的任务时，主动调用注册进来的 <code>EventSource</code> 的 <code>Dispatch</code> 方法以此实现一个原始事件分发的一个功能</p>
<p>设计完了这些原始的事件源和事件循环核心，就要来实现一个真的 EventLoop 了</p>
<h2 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h2><p>我前面说 <code>EventLoopCore</code> 只是 IO syscall 的代理层，它的职责是“收事件”，而不是“安排工作”。<br>真正面向 UI 线程的事件循环，必须还要干三件事：<br>1) 能从别的线程安全地投递任务；<br>2) 能有定时器，按时间触发任务；<br>3) 能随时唤醒正在阻塞的 IO syscall。<br>于是我在 <code>EventLoopCore</code> 外面包了一层 <code>EventLoop</code>，它就是 UI 线程真正跑的那一层。</p>
<p>如果只看接口，它其实非常朴素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLoop</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">EventLoop</span>(BackendType backend_type);</span><br><span class="line">    ~<span class="built_in">EventLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(Task task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postDelayed</span><span class="params">(Task task, Duration delay)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">requestExit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">attachSource</span><span class="params">(IEventSource* source)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">detachSource</span><span class="params">(IEventSource* source)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="先说构造：选-backend-安排唤醒源"><a href="#先说构造：选-backend-安排唤醒源" class="headerlink" title="先说构造：选 backend + 安排唤醒源"></a>先说构造：选 backend + 安排唤醒源</h3><p>构造函数里干了两件事：</p>
<ul>
<li>调用 <code>createEventLoopCore(backend_type)</code> 创建核心 <code>EventLoopCore</code>。</li>
<li>根据 backend 创建一个 <code>WakeUpWatcher</code>，把它作为一个事件源注册进去。</li>
</ul>
<p>为什么需要唤醒源？因为 <code>post()</code> 和 <code>postDelayed()</code> 是线程安全的，我允许别的线程投任务。  但是 UI 线程很可能正卡在 <code>epoll_wait/poll</code> 里，如果没人唤醒它，它永远看不到新的任务。  所以“唤醒源”其实就是一个可被触发的 fd（Linux 下可以用 eventfd 或 pipe），它一旦写入，就会让 IO syscall 立刻返回。</p>
<p>这就是 <code>post()</code> 的核心逻辑：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::post</span><span class="params">(Task task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!task) <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mu_)</span></span>;</span><br><span class="line">        tasks_.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">    &#125;</span><br><span class="line">    wakeup_-&gt;<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它不直接跑任务，只是把任务丢进队列，然后用唤醒源把阻塞的 IO 拉起来。事实上按照设计，<code>EventSource</code> 的回调函数就可以选择将事件 post 入队列中，等待处理。实际使用的时候可以灵活选择</p>
<h3 id="任务队列-定时器"><a href="#任务队列-定时器" class="headerlink" title="任务队列 + 定时器"></a>任务队列 + 定时器</h3><p><code>EventLoop</code> 里有两个“任务容器”：</p>
<ul>
<li><code>tasks_</code>：一个简单的 <code>deque</code>，存放即时任务。</li>
<li><code>timers_</code>：一个小顶堆（优先队列），按照 deadline 排序的延迟任务。</li>
</ul>
<p>延迟任务的投递是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLoop::postDelayed</span><span class="params">(Task task, Duration delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!task) <span class="keyword">return</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mu_)</span></span>;</span><br><span class="line">        timers_.<span class="built_in">push</span>(TimerTask&#123;Clock::<span class="built_in">now</span>() + delay, std::<span class="built_in">move</span>(task)&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    wakeup_-&gt;<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依然是先入队，再唤醒，保证 UI 线程不会错过。</p>
<h3 id="计算-timeout：决定-IO-等多久"><a href="#计算-timeout：决定-IO-等多久" class="headerlink" title="计算 timeout：决定 IO 等多久"></a>计算 timeout：决定 IO 等多久</h3><p>这一步是整个 loop 的“节拍器”。<br><code>computeTimeoutMs()</code> 负责告诉 <code>EventLoopCore::runOnce()</code>：你最多等多久。</p>
<p>规则也很直觉：</p>
<ul>
<li>有即时任务：<code>timeout = 0</code>，不要阻塞，直接跑。</li>
<li>没有定时器：<code>timeout = -1</code>，可以无限等 IO。</li>
<li>有定时器：计算最近 deadline 到现在的差值，作为等待上限。</li>
</ul>
<p>而且我还加了一个“上限保护”，避免超时值溢出 <code>int</code>。</p>
<h3 id="主循环：IO-定时器-任务队列"><a href="#主循环：IO-定时器-任务队列" class="headerlink" title="主循环：IO + 定时器 + 任务队列"></a>主循环：IO + 定时器 + 任务队列</h3><p>真正的 <code>run()</code> 就是一个非常直白的 while：</p>
<ol>
<li>先 <code>applyInitialChanges()</code>，把初始事件源都注册好（包括唤醒源）。</li>
<li>计算 timeout，调用 <code>core_-&gt;runOnce(timeout)</code> 处理 IO。</li>
<li>执行到期的定时器任务。</li>
<li>执行即时任务队列。</li>
<li>循环直到 <code>requestExit()</code> 被调用。</li>
</ol>
<p><code>runExpiredTimers()</code> 的实现我也刻意做成“先收集后执行”的模式：<br>先在锁内把到期任务全部搬出来，再在锁外执行。这样避免回调里再 <code>post()</code> 造成死锁，也减少锁的持有时间。</p>
<h3 id="退出机制"><a href="#退出机制" class="headerlink" title="退出机制"></a>退出机制</h3><p><code>requestExit()</code> 只是把一个 <code>atomic&lt;bool&gt;</code> 置为 true，然后唤醒一次 loop。<br>这是为了保证即使 UI 线程正在阻塞，也能被拉起来看见“退出请求”。</p>
<p>到这里为止，<code>EventLoop</code> 已经完成了一个 UI 线程所需的“基本调度器”：<br>它能收 IO，能收任务，能有定时器，能安全唤醒和退出。<br>后面我只需要把“窗口事件”、“渲染时机”、“输入设备”都包装成 <code>IEventSource</code>，就可以自然接入这套体系。</p>
<p>于是乘热打铁我还写了几个 example</p>
<p><img src="/images/RopUI开发_第1弹_图2.png" width="100%" height="100%"><br>可以创建一个 TCP client</p>
<p><img src="/images/RopUI开发_第1弹_图3.png" width="100%" height="100%"><br>看看回调地狱</p>
<h2 id="EventLoop-的后续"><a href="#EventLoop-的后续" class="headerlink" title="EventLoop 的后续"></a>EventLoop 的后续</h2><p>事实上这套做法在 linux 上实现的很顺利，在 Windows 和 MacOS 上却出现了问题。Linux 内核本身是不具有图形环境的，所以接口相对统一，但是对于其他两个平台，他们的 UI 线程往往非常具有平台特色，而且独立</p>
<p>Windows 平台的 WinMain 函数支持 UI，但是与此同时又只支持同时监听 64 个句柄，要想使用 IOCP 必须单独开一个线程，这体验并不好，所以 EventLoop 有可能在后续的版本被废弃，转而使用更复杂的多线程调度器，请等待我的后续信息叭</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>ropui_blog</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_10_生命周期</title>
    <url>/posts/11c8f25c.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-10-生命周期"><a href="#Rust-Chapter-10-生命周期" class="headerlink" title="Rust_Chapter_10_生命周期"></a>Rust_Chapter_10_生命周期</h1><p>一开始学习 Rust 时，生命周期(Lifetime)是一个过不去的坎，它看起来和其他语言常说的生命周期类似，但因为它其实实际上也是 Rust 类型系统的一部分，并不是那么易读的</p>
<span id="more"></span>
<h2 id="悬垂指针和生命周期"><a href="#悬垂指针和生命周期" class="headerlink" title="悬垂指针和生命周期"></a>悬垂指针和生命周期</h2><p>生命周期诞生的主要目的就是为了放置悬垂指针，避免引用空悬。通过 Rust 编译器检查生命周期，从语言层面上限制程序员，基本上可以在编译期就保证内存安全</p>
<p>像下面的这段代码</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">        r = &amp;x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时会报下面的错误<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error[E0597]: `x` does not live long enough // `x` 活得不够久</span><br><span class="line">  --&gt; src/main.rs:7:17</span><br><span class="line">   |</span><br><span class="line">7  |             r = &amp;x;</span><br><span class="line">   |                 ^^ borrowed value does not live long enough // 被借用的 `x` 活得不够久</span><br><span class="line">8  |         &#125;</span><br><span class="line">   |         - `x` dropped here while still borrowed // `x` 在这里被丢弃，但是它依然还在被借用</span><br><span class="line">9  |</span><br><span class="line">10 |         println!(&quot;r: &#123;&#125;&quot;, r);</span><br><span class="line">   |                           - borrow later used here // 对 `x` 的借用在此处被使用</span><br></pre></td></tr></table></figure></p>
<p>我们在别的语言里会说 x 的作用域在第二个括号末就结束了，所以这是一个典型的可能导致引用空悬的代码，我们可以用 <code>&#39;a</code>、<code>&#39;b</code> 这样的标签来标记这么一个生命周期，如下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">r</span>;                <span class="comment">// ---------+-- &#x27;a</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    &#123;                     <span class="comment">//          |</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;        <span class="comment">// -+-- &#x27;b  |</span></span><br><span class="line">        r = &amp;x;           <span class="comment">//  |       |</span></span><br><span class="line">    &#125;                     <span class="comment">// -+       |</span></span><br><span class="line">                          <span class="comment">//          |</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="comment">//          |</span></span><br><span class="line">&#125;                         <span class="comment">// ---------+</span></span><br></pre></td></tr></table></figure>
<p>我们说 <code>r</code> 这个变量的生命周期是 <code>&#39;a</code>，而 <code>x</code> 这个变量的生命周期是 <code>‘b</code>，从图示上可以明显看出生命周期 <code>&#39;b</code> 比 <code>&#39;a</code> 小很多。</p>
<p>在编译期，Rust 会比较两个变量的生命周期，结果发现 <code>r</code> 明明拥有生命周期 <code>&#39;a</code>，但是却引用了一个小得多的生命周期 <code>&#39;b</code>，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p>
<p>在这里，编译器自动就知道了生命周期，但是这不是时时刻刻都能成的：在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</p>
<h2 id="关于-Rust-类型系统"><a href="#关于-Rust-类型系统" class="headerlink" title="关于 Rust 类型系统"></a>关于 Rust 类型系统</h2><p>在了解这些之前，我们先要介绍一下由 Rust 生命周期而来的类型系统，详细需要观看如下的一篇文章<br>[SAST.Mathematics SIG / Subtyping variance and its application] <a href="https://sast-mathematics-sig.github.io/posts/subtyping_variance_and_its_application/">https://sast-mathematics-sig.github.io/posts/subtyping_variance_and_its_application/</a></p>
<p>我们有一个基本的事实，即 <code>Bot = &amp;&#39;static T &lt;: &amp;&#39;b T &lt;: &amp;&#39;a T</code> ，没那么严谨的说法是，当生命周期标签的范围越大，那这个类型就是越小的子类型</p>
<p>而如果 S 是 T 的子类型，意思是在任何需要使用 T 类型对象的环境中，都可以安全地使用 S 类型的对象。</p>
<p>这暗含的含义就是：变量本身内蕴的生命周期标签大的可以被借用给生命周期小的，而且一个类型为 <code>&amp;&#39;b T</code> 的变量它的类型其实也满足 <code>&amp;&#39;a T</code></p>
<h2 id="为一些特殊的函数标注生命周期"><a href="#为一些特殊的函数标注生命周期" class="headerlink" title="为一些特殊的函数标注生命周期"></a>为一些特殊的函数标注生命周期</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">longest</span>&lt;<span class="symbol">&#x27;a</span>&gt;(x: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>, y: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>) <span class="punctuation">-&gt;</span> &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.<span class="title function_ invoke__">len</span>() &gt; y.<span class="title function_ invoke__">len</span>() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到生命周期标注和泛型标注很相似，且有了上面的铺垫，我们理解了为什么在这里需要标注生命周期(实际上，如果你这个函数不标记生命周期就会收获一个编译报错)</p>
<p>该函数签名表明对于某些生命周期 <code>&#39;a</code>，函数的两个参数都至少跟 <code>&#39;a</code> 活得一样久，同时函数的返回引用也至少跟 <code>&#39;a</code> 活得一样久。实际上，这意味着返回值的生命周期与参数生命周期中的较小值一致：虽然两个参数的生命周期都是标注了 <code>&#39;a</code>，但是实际上这两个参数的真实生命周期可能是不一样的(上面的讨论说明了生命周期 <code>&#39;a</code> 不代表生命周期等于 <code>&#39;a</code>，而是大于等于 <code>&#39;a</code>)</p>
<h2 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h2><p>定义包含引用的结构体时，需要为结构体定义中的每一个引用添加生命周期注解</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ImportantExcerpt</span>&lt;<span class="symbol">&#x27;a</span>&gt; &#123;</span><br><span class="line">    part: &amp;<span class="symbol">&#x27;a</span> <span class="type">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">novel</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Call me Ishmael. Some years ago...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">first_sentence</span> = novel.<span class="title function_ invoke__">split</span>(<span class="string">&#x27;.&#x27;</span>).<span class="title function_ invoke__">next</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">i</span> = ImportantExcerpt &#123;</span><br><span class="line">        part: first_sentence,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h2><p>并非所有时候使用引用都需要标注生命周期，历史为我们提供了一些语法糖帮助我们消除生命周期</p>
<p>消除规则不是万能的，若编译器不能确定某件事是正确时，会直接判为不正确，那么你还是需要手动标注生命周期</p>
<p>函数或者方法中，参数的生命周期被称为<strong>输入生命周期</strong>，返回值的生命周期被称为<strong>输出生命周期</strong></p>
<h3 id="三条消除规则"><a href="#三条消除规则" class="headerlink" title="三条消除规则"></a>三条消除规则</h3><p>编译器使用三条消除规则来确定哪些场景不需要显式地去标注生命周期。其中第一条规则应用在输入生命周期上，第二、三条应用在输出生命周期上。若编译器发现三条规则都不适用时，就会报错，提示你需要手动标注生命周期。</p>
<ol>
<li>每一个引用参数都会获得独自的生命周期<br> 例如一个引用参数的函数就有一个生命周期标注: <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32)</code>，两个引用参数的有两个生命周期标注:<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>, 依此类推。</li>
<li>若只有一个输入生命周期（函数参数中只有一个引用类型），那么该生命周期会被赋给所有的输出生命周期，也就是所有返回值的生命周期都等于该输入生命周期<br> 例如函数 <code>fn foo(x: &amp;i32) -&gt; &amp;i32</code>，<code>x</code> 参数的生命周期会被自动赋给返回值 <code>&amp;i32</code>，因此该函数等同于 <code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code></li>
<li>若存在多个输入生命周期，且其中一个是 <code>&amp;self</code> 或 <code>&amp;mut self</code>，则 <code>&amp;self</code> 的生命周期被赋给所有的输出生命周期<br> 拥有 <code>&amp;self</code> 形式的参数，说明该函数是一个 方法，该规则让方法的使用便利度大幅提升。</li>
</ol>
<h2 id="方法定义中的生命周期注解"><a href="#方法定义中的生命周期注解" class="headerlink" title="方法定义中的生命周期注解"></a>方法定义中的生命周期注解</h2><p>当为带有生命周期的结构体实现方法时，其语法依然类似泛型类型参数的语法。我们在哪里声明和使用生命周期参数，取决于它们是与结构体字段相关还是与方法参数和返回值相关。</p>
<p>(实现方法时)结构体字段的生命周期必须总是在 <code>impl</code> 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。</p>
<p><code>impl</code> 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。</p>
<h2 id="静态生命周期"><a href="#静态生命周期" class="headerlink" title="静态生命周期"></a>静态生命周期</h2><p>这里有一种特殊的生命周期值得讨论：<code>&#39;static</code>，其生命周期能够存活于整个程序期间。所有的字符串字面值都拥有 <code>&#39;static</code> 生命周期，我们也可以选择像下面这样标注出来：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span>: &amp;<span class="symbol">&#x27;static</span> <span class="type">str</span> = <span class="string">&quot;I have a static lifetime.&quot;</span>;</span><br></pre></td></tr></table></figure><br>这个字符串的文本被直接储存在程序的二进制文件中而这个文件总是可用的。因此所有的字符串字面值都是 <code>&#39;static</code> 的。</p>
<h2 id="泛型中的生命周期"><a href="#泛型中的生命周期" class="headerlink" title="泛型中的生命周期"></a>泛型中的生命周期</h2><p>因为生命周期也是泛型，所以生命周期参数 <code>&#39;a</code> 和泛型类型参数 <code>T</code> 都位于函数名后的同一尖括号列表中</p>
<blockquote>
<p>至此，匆匆忙忙把 Rust 一些很基础的语法介绍完毕了，接下来这一个小系列也告一段落了</p>
</blockquote>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_2_通用编程概念</title>
    <url>/posts/896c357a.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-2-通用编程概念"><a href="#Rust-Chapter-2-通用编程概念" class="headerlink" title="Rust_Chapter_2_通用编程概念"></a>Rust_Chapter_2_通用编程概念</h1><p>你可能会好奇什么是通用编程概念，其实在我看的这一本经典书中这一章节内容主要是Rust的变量、函数、注释、if表达式及循环。而变量由于其特性十分有趣，我就在上一章节单独拿了出来为一章了。</p>
<span id="more"></span>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在Rust中，函数定义以<code>fn</code>关键字开始并紧随函数名称与一对圆括号，另外还有一对花括号用于标识函数体开始和结尾的地方。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="title function_ invoke__">sayhello</span>();<span class="comment">//可以用这样的方式来调用函数，这很容易</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">sayhello</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Rust不关心你在何处定义函数，函数定义在<code>main()</code>前后都行，只要这些定义对于<strong>使用区域是可见的</strong>即可</p>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>你也可以在函数声明中定义参数，它们是一种特殊的变量，并被视作函数签名的一部分。当函数存在参数时，你需要在调用函数时为这些变量提供具体的值。参数变量和传入的具体参数值有自己分别对应的名称<strong>parameter</strong>和<strong>argument</strong>，但我们通常会混用两者并将它们统一地称为参数而不加以区别。<br>很简单，和众多语言的例子一样，直接看代码<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">another_function</span>(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">another_function</span>(x: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出The value of x is: 5</span></span><br></pre></td></tr></table></figure><br>出于严谨的考虑，在Rust的函数签名中，你必须<strong>显式</strong>地声明<strong>每个参数的类型</strong>。</p>
<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><p>函数可以向调用它的代码返回值。虽然你不用为这个返回值命名，但需要在箭头符号<code>-&gt;</code>的后面<strong>声明它的类型</strong>，类型在函数定义时时确定的。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">five</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="title function_ invoke__">five</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意上面的5不是语句而是<strong>表达式</strong>，Rust中的函数会返回最后一个表达式，但你也可以使用<code>return</code><strong>语句</strong>来返回值<br>注意如果<strong>函数最后还是分号结尾的语句而非表达式</strong>的话，实际上返回的是<code>()</code>，会和函数声明的类型相悖，由于不允许隐式转化，也无法转化的规则存在，这样会引起编译器错误</p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul>
<li>普通注释，其内容将被编译器忽略掉：<br>  <code>//</code> 单行注释，注释内容直到行尾。<br>  <code>/*</code> 块注释，注释内容一直到结束分隔符。 <code>*/</code></li>
<li>文档注释，其内容将被解析成 HTML 帮助文档：<br>  <code>///</code> 为接下来的项生成帮助文档。<br>  <code>//!</code> 为注释所属于的项（译注：如 crate、模块或函数）生成帮助文档。</li>
</ul>
<h2 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is negative&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is positive&quot;</span>, n);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">&quot;&#123;&#125; is zero&quot;</span>, n);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>与C/C++类似，但有几个不同或需要注意的地方</p>
<ul>
<li>分支条件<strong>无需</strong>写括号，但不是说不能写</li>
<li>if不支持C/C++那样的单行写法，大括号必须要有</li>
<li>Rust期望在条件表达式中获得一个bool值，而不是一个整数。Rust<strong>不会</strong>自动尝试将非布尔类型的值<strong>转换</strong>为布尔类型。你必须<strong>显式</strong>地在if表式中提供一个布尔类型作为条件</li>
<li>Rust会且仅会执行第一个条件为真的代码块，一旦发现满足的条件，它便不会再继续检查剩余的那些条件分支了。</li>
</ul>
<p>注意我们这一节说<code>if表达式</code>，而不是语句是有原因的，比如在<code>let</code>中是可以使用表达式的<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果 The value of number is: 5</span></span><br></pre></td></tr></table></figure><br>这也意味着，所有if分支可能返回的值都必须是一种类型的；if分支与else分支的结果都是i32类型的整数。而如下运行这段代码会导致<strong>编译时错误</strong>，因为if与else分支产生了不同类型的值。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">&quot;six&quot;</span><span class="comment">//ERROR!!!</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of number is: &#123;&#125;&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>为了对其他使用number变量的代码进行编译时类型检查，Rust需要在<strong>编译时</strong>确定number的具体类型。如果Rust能够使用运行时确定的number类型，那么它就不得不记录变量所有可能出现的类型，这会使得编译器的实现更加复杂，并丧失许多代码安全保障</p>
<h2 id="循环表达式"><a href="#循环表达式" class="headerlink" title="循环表达式"></a>循环表达式</h2><p>Rust提供了3种循环：<code>loop</code>、<code>while</code>和<code>for</code>。</p>
<h3 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h3><p>我们可以使用loop关键字来指示Rust反复执行某一块代码，直到我们显式地声明退出为止。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;again!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>loop</code>相当于<code>while(true)</code>，需要<code>break</code>来弹出，否则就会<strong>无限循环</strong><br>在break后面跟着返回的值，就可以设置<strong>loop表达式返回的值</strong>了<br>注意所有循环中都有<code>break</code>，但<strong>只有</strong><code>loop</code>的<code>break</code>才能跟返回值，如下例子<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The result is &#123;&#125;&quot;</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p><code>while</code>会在条件为真时重复执行代码，<code>while</code>也不需要一定需要加括号<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">n</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">101</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,n);</span><br><span class="line">        n += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出1到100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>用for循环来遍历集合中的每一个元素。<code>for in</code>结构可以遍历一个<code>Iterator</code>(迭代器)。创建迭代器的一个最简单的方法是使用区间标记<code>a..b</code>。这会生成从<code>a</code>(包含此值)到<code>b</code>(不含此值)的，步长为1的一系列值，如果使用<code>a..=b</code>表示<strong>两端都包含在内</strong>的范围<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">4</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;<span class="comment">//输出1! 2! 3! 4!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).<span class="title function_ invoke__">rev</span>() &#123;</span><br><span class="line">        <span class="comment">//rev()是迭代器的方法，可以翻转序列</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;<span class="comment">//输出3! 2! 1!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而迭代器显然的也可以用于一个数组，太典了<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">    &#125;<span class="comment">//输出1! 2! 3! 4! 5!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="语句和表达式语义的区分"><a href="#语句和表达式语义的区分" class="headerlink" title="语句和表达式语义的区分"></a>语句和表达式语义的区分</h2><p>由于Rust是一门基于表达式的语言，所以它将<strong>语句/statement</strong>与<strong>表达式/expression</strong>区别为两个不同的概念，这与其他某些语言不同，因此区分他俩就显得十分重要了</p>
<ul>
<li>语句：指的是要执行的一些操作和产生副作用的表达式。</li>
<li>表达式：主要用于计算求值。</li>
</ul>
<p>而语句又可以分为两类，<strong>声明语句</strong>与<strong>表达式语句</strong></p>
<ul>
<li>声明语句：用于声明各种语言项，包括变量、静态变量、常量、结构体、函数等，以及通过extern和use关键字引入包和模块</li>
<li>表达式语句：特指以分号结尾的表达式。此类表达式求值结果将会被舍弃，并总是返回单元类型()</li>
</ul>
<p>当遇到函数的时候，会将函数体的花括号识别为块表达式。块表达式是由<strong>一对花括号和一系列表达式</strong>组成的，它总是返回块中最后一个表达式的值。</p>
<p>Rust编译器在解析代码的时候，如果碰到分号，就会继续往后面执行；如果碰到语句，则执行语句；如果碰到表达式，则会对表达式求值，如果分号后面什么都没有，就会补上单元值<code>()</code></p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_1_变量</title>
    <url>/posts/2d38ec93.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-1-变量"><a href="#Rust-Chapter-1-变量" class="headerlink" title="Rust_Chapter_1_变量"></a>Rust_Chapter_1_变量</h1><p>这一章节内容主要是Rust的变量</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从现在开始，我正式开始学习Rust。Rust相对于C++在出于安全的<strong>规范优势</strong>不必多说，我发现Rust也能用于嵌入式开发。<br>因而我受够了，<strong>快用Rust重写</strong>(乐)</p>
<span id="more"></span>
<blockquote>
<p>在写这一章的时候，我手头看的这一本书是《Rust权威指南》，虽说序论中说并不适合新手，但是就我读了前三章似乎也没有遇见特别难懂的概念。这一章包括之后，都是这本书的学习笔记</p>
</blockquote>
<h2 id="Hello-Rust"><a href="#Hello-Rust" class="headerlink" title="Hello Rust"></a>Hello Rust</h2><p>新学一门编程语言，肯定少不了Hello_World，基本礼仪<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hello Rust!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>简简单单的一行，与C++类似<br><code>fn main()</code>是main函数的声明，入口函数就是<code>main()</code>函数，没什么好说的<br><code>println!()</code>是一个宏而非函数，这点在后面在解释<br><code>println!()</code>可以使用类似C++20<code>std::format</code>的语法形式，具体如下<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;1&#125; learn rust &#123;0&#125;&quot;</span>,<span class="number">666</span>,<span class="string">&quot;feipiao&quot;</span>);</span><br><span class="line"><span class="comment">//输出结果 feipiao learn rust 666</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">233</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，Rust中的变量默认是<strong>不可变变量</strong>，也就是<code>let x = 666;</code>，这和C++有很大的不同，我想不出C++有什么平替，因为它并不是C++中加<code>const</code>的那种常量，C/C++中的变量其实都是第二条<code>let mut y = 233;</code>，为<strong>可变变量</strong><br>还记得C/C++有一个<code>mutable</code>关键字么，这里的<code>mut</code>其实就是它的缩写，那么他俩有什么区别呢？</p>
<h3 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h3><p>不可变变量保证了数据不会被修改，例如运行如下的错误代码会报错<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">666</span>;</span><br><span class="line">    x = <span class="number">100</span>;<span class="comment">//这是会报错滴</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>而以下代码就不会报错，因为这里<code>666</code>是利用<code>let</code>被<strong>隐藏/shadow</strong>了，我们可以重复使用<code>let</code>关键字并配以相同的名称来不断地<strong>隐藏</strong>变量<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">666</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">100</span>;<span class="comment">//666被隐藏了，x代表100，这保证了666这个数据没有被修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>值得一提的是，这种shadow甚至可以改变x的类型，也就是说除了x的名字没变，它这个名字代表的本身是什么完全可以变掉<br>也就是说，把一个人的名字给了另一个人，这个人也就自然被隐藏起来了，但谁也还是自己，<strong>没被修改</strong>不是么<br>个人感觉这和<strong>C/C++作用域下名称的覆盖</strong>类似，也许那也是一种shadow呢？</p>
<h3 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h3><p>像可变变量就很类似C/C++了，其在第一次声明的时候类型就已经被确定了<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">666</span>;</span><br><span class="line">    x = <span class="number">233</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里声明了x是一个可变变量，第二句就修改了它的值，但<strong>x的类型</strong>在第一句的时候就已经被<strong>确认</strong>是一个整型了(下面会讲到，这里是<strong>自动类型推导</strong>)，如果在这个时候把第二句改成<code>x = 233.2</code>就会报错</p>
<h3 id="let即隐藏-amp-可变与不可变的底层内涵"><a href="#let即隐藏-amp-可变与不可变的底层内涵" class="headerlink" title="let即隐藏&amp;可变与不可变的底层内涵"></a>let即隐藏&amp;可变与不可变的底层内涵</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">233</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">a</span> = <span class="number">233</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">    a = <span class="number">666</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//正确编译，结果如下</span></span><br><span class="line"><span class="comment">//233</span></span><br><span class="line"><span class="comment">//233</span></span><br><span class="line"><span class="comment">//666</span></span><br></pre></td></tr></table></figure>
<p>注意<code>let</code>代表的就是shadow的含义，既然是隐藏，那么意味着类型可以被更改，也就是说第二个<code>let mut a = 233;</code>时a就变成了一个可变变量了，但原来上面第一个的<code>let a = 233</code>中233还存在于栈上，并<strong>没有被改变</strong>，只是a不再能访问到它了而已。第三句由于a已经是一个可变变量了，自然也是成立的</p>
<p>可以看看如下<strong>缩减的汇编码</strong>，本篇文档记录时使用的环境为<code>rustc 1.69.0 (84c898d65 2023-04-16)</code><br>上述代码经过<code>rustc -O --emit asm=main.s .\main.rs</code>生成的<a href="https://github.com/feipiao594/Self-study-notes/blob/main/CS_%E8%AE%A1%E7%AE%97%E6%9C%BA/Rust/Rust_Chapter_1_%E5%8F%98%E9%87%8F_%E7%A4%BA%E4%BE%8B%E6%96%87%E4%BB%B6.s">完整的汇编文件github仓库链接</a><br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_ZN4main4main17hd0d97daef3a32cf2E:</span><br><span class="line">...</span><br><span class="line">movl	$233, 36(%rsp)</span><br><span class="line">...</span><br><span class="line">callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E</span><br><span class="line">...</span><br><span class="line">movl	$233, 32(%rsp)</span><br><span class="line">...</span><br><span class="line">callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E、</span><br><span class="line">...</span><br><span class="line">movl	$666, 32(%rsp)</span><br><span class="line">...</span><br><span class="line">callq	_ZN3std2io5stdio6_print17hce7a376ab49946d5E</span><br></pre></td></tr></table></figure><br>可以清晰的看到Rust所承诺的<strong>不可变变量的不可被修改性</strong>，也可以看到<strong>可变变量在原位被更改</strong>，而let就是生成一个崭新的变量，在地址上区别于原对象，这不像C++，因为C++是不允许局部静态变量重复被初始化的</p>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>用<code>const</code>而不是<code>let</code>来声明一个常量，常量和变量是不同的，不论变量可变还是不可变，常量不可以使用<code>mut</code>修饰，常量不仅默认不可变，还总是不可变，这体现为下列<strong>错误</strong><br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> MAX: <span class="type">u32</span> = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, MAX);</span><br><span class="line">    <span class="keyword">const</span> MAX: <span class="type">u32</span> = <span class="number">10</span>;<span class="comment">//ERROR!!!报错啦</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>即不允许MAX被重定义<br>常量在声明时候必须<strong>第一时间显式标注类型</strong><br>常量只能绑定到常量表达式上，不能被绑定到函数的返回值上，或其它需要在运行时计算的值</p>
<h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>Rust是一个<strong>强类型</strong>的语言，但从上面的例子好像看不出来，因为它存在有<strong>自动的类型推导</strong>，当然我们也<strong>可以显式</strong>的给它声明变量是什么类型，如下<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">test</span>: <span class="type">u32</span> = <span class="number">42</span>;</span><br></pre></td></tr></table></figure><br>有时候Rust无法推导出变量的类型，我们就不能去掉这个显式声明的过程，如下段代码，就不能去除<code>: u32</code>，否则就会愉快的报错<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;Not a number!&quot;</span>);</span><br></pre></td></tr></table></figure><br>Rust中内建了4种基础的标量类型：整型、浮点数、布尔值与字符，2种内置的基础的复合类型：元组(tuple)和数组(array)</p>
<h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>没啥好说的，直接上表格</p>
<p><strong>Rust中的整数类型</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>长度</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>8-bit</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16-bit</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32-bit</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64-bit</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>arch</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody>
</table>
</div>
<p>最后一行的<code>isize</code>和<code>usize</code>的长度取决于程序运行的目标平台，在64位上就64位，32位上就32位</p>
<p>你可以使用如下表的方式书写整型字面量，注意，除了Byte，其余所有的字面量都可以使用<strong>整型后缀</strong>，比如<code>57u8</code>，代表一个使用了u8类型的整数57。同时你可以使用<code>_</code>作为<strong>分隔符</strong>方便读数，比如<code>1_000</code></p>
<p><strong>Rust中的整型字面量</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>整型字面量</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Decimal</td>
<td>98_222</td>
</tr>
<tr>
<td>Hex</td>
<td>0xff</td>
</tr>
<tr>
<td>Octal</td>
<td>0o77</td>
</tr>
<tr>
<td>Binary</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>Byte(u8 only)</td>
<td>b’A’</td>
</tr>
</tbody>
</table>
</div>
<p>关于整型的类型溢出，在debug版本下会直接被Rust检测到，<strong>弹出panic并结束程序</strong>，在release版本下会形成经典的C/C++中的overflowing，这本书中称为<strong>二进制补码环绕</strong>，如果希望显示使用环绕，可以使用标准库中的类型<code>Wrapping</code></p>
<h3 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h3><p>基本的两个类型<code>f32</code>与<code>f64</code>，依照遵循IEEE-754，Rust中浮点数字面量默认推导为<code>f64</code></p>
<h3 id="Bool类型"><a href="#Bool类型" class="headerlink" title="Bool类型"></a>Bool类型</h3><p>没啥好说的，和其它编程语言一致，都是<code>True</code>和<code>False</code>，类型名就是<code>Bool</code></p>
<h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><p>即<code>char</code>类型，注意字符类型是用<strong>单引号</strong>包围的，而字符串是用<strong>双引号</strong>包围的<br>Rust中的<code>char</code>类型占4个字节，是一个Unicode标量值，头皮发麻了</p>
<h3 id="元组类型"><a href="#元组类型" class="headerlink" title="元组类型"></a>元组类型</h3><p>元组类型可以将多个<strong>不同类型</strong>的多个值组合进一个复合类型中<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">tup</span>:(<span class="type">i32</span>,<span class="type">f64</span>,<span class="type">u8</span>) = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (x,y,z) = tup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里第一行创建了一个元组，注意这里的类型显示说明是不必要的，我们也可以写成<code>let tup = (500,6.4,1);</code></p>
<p>第二行看起来像是结构化绑定，在这里被称为是<strong>解构</strong></p>
<p>除此以外我们还可以使用<strong>索引</strong>并通过<strong>点号</strong>来访问元组中的值<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = (<span class="number">500</span>,<span class="number">6.4</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = x.<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = x.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = x.<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>与元组类型不同，数组中的每个值只能够是<strong>相同</strong>的类型，相同的是类型在一开始必须就能推导或者显式声明，而且数组的大小也必须在一开始就确定<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i32</span>;<span class="number">5</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//显式说明类型以及个数</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line">    <span class="comment">//隐式推导</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>特殊用法</strong>，如果想创建一个含有相同值的数组，可以如下简写<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">3</span>;<span class="number">5</span>];<span class="comment">//注意中括号里面是分号</span></span><br></pre></td></tr></table></figure></p>
<p>访问数组的元素与C/C++一致，即<code>arrayname[index]</code>，如果数组越界访问，也会引起运行时的panic，程序会崩溃退出，十分的<strong>保守与安全</strong>，不像C/C++留下引发一系列的安全问题的隐患</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_3_所有权</title>
    <url>/posts/f75e4487.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-3-所有权"><a href="#Rust-Chapter-3-所有权" class="headerlink" title="Rust_Chapter_3_所有权"></a>Rust_Chapter_3_所有权</h1><p>所有权是Rust的一个关键概念，我时常会想这个东西我会不会叙述不清楚，截至今天我已经把Chapter_7读完了，也没有来写这一份所有权的md，就是如此。</p>
<span id="more"></span>
<h2 id="简述所有权"><a href="#简述所有权" class="headerlink" title="简述所有权"></a>简述所有权</h2><p>Rust采用了所有权这种机制，在编译器就避开各种阻碍，精确调控垃圾回收机制，从而在不需要类似C/C++手动回收垃圾的机制和类似Java自动GC的机制下，保留高性能，又内存安全。</p>
<h2 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h2><ul>
<li>Rust中的每一个值都有一个对应的变量作为它的所有者</li>
<li>在同一时间内，值有且仅有一个所有者</li>
<li>当所有者离开自己的作用域时，它持有的值就会被释放掉</li>
</ul>
<p>这三条概念需要慢慢体悟</p>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><p>变量从声明的位置开始直到当前作用域结束都是有效的<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;<span class="comment">//由于变量s在这里还没有声明，所以它是不可用的</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;Hello&quot;</span>;<span class="comment">//从这里变量s开始变得可用</span></span><br><span class="line">    <span class="comment">//执行与s相关的操作</span></span><br><span class="line">&#125;<span class="comment">//作用域到这里结束，变量s变得不可用</span></span><br></pre></td></tr></table></figure></p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>同C++类型一致，String类型所指向的数据必然要创建在堆上，那这势必会引发”析构”的问题，当然在rust里我们不这么称呼<br>与C/C++不同，Rust提供了另一套解决方案：<strong>内存会自动地在拥有它的变量离开作用域后进行释放</strong></p>
<p>审视上面的代码，有一个很适合用来回收内存给操作系统的地方：变量s离开作用域的地方。Rust在变量离开作用域时，会调用一个叫作drop的特殊函数。String类型的<strong>作者</strong>可以在这个函数中编写释放内存的代码(仍然是要手动书写drop函数的)。记住，Rust会在作用域结束的地方（即“}”处）自动调用drop函数。</p>
<p>其实<code>String</code>本身就是智能指针，这将在本blog的第14章讲解，对于结构体而言，自身被析构时会调用自己内部成员的drop，这和cpp也没啥区别，当然结构体也是后话了，主要是目前我们没有cpp指针的概念，这些而<strong>默认智能指针的存在，使得析构一个栈对象和堆对象差别不大了</strong>(智能指针这个栈对象drop时，堆对象也会随之drop)</p>
<h2 id="变量和数据交互的方式-移动"><a href="#变量和数据交互的方式-移动" class="headerlink" title="变量和数据交互的方式:移动"></a>变量和数据交互的方式:移动</h2><p>为保证重复释放内存不会出现，rust采用一种方法，即默认状态下赋值语句是<strong>移动</strong>而非拷贝赋值<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, world!&quot;</span>, s1);</span><br></pre></td></tr></table></figure><br>像这样的代码，最终会输出一个错误，s1已经是无效的了<br>当移动发生时，值的所有权已经不在原本的所有者手上了，这意味着原本的s1不是任何数据的所有者，故而不在作用域结束时调用drop，而s2接管了s1的数据，成为了所有者，就会在出作用域的时候进行drop<br>只对所有者(具有所有权的变量)进行drop，是通过编译器在编译时检查与推导实现的，一个变量是否在作用域结束时触发drop，在编译期就能够知道</p>
<h2 id="变量和数据交互的方式-克隆"><a href="#变量和数据交互的方式-克隆" class="headerlink" title="变量和数据交互的方式:克隆"></a>变量和数据交互的方式:克隆</h2><p>当你确实需要去<strong>深度拷贝</strong>String堆上的数据，而不仅仅是栈数据时，就可以使用一个名为clone的方法<br>下面是一个实际使用clone方法的例子：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure><br>这段代码在Rust中完全合法，它显式复制了堆上的数据</p>
<h2 id="trait-COPY"><a href="#trait-COPY" class="headerlink" title="trait: COPY"></a>trait: COPY</h2><p>Rust提供了一个名为Copy的trait，它可以用于整数这类完全存储在栈上的数据类型（我们会在第10章详细地介绍trait）。一旦某种类型拥有了Copy这种trait，那么它的变量就可以在赋值给其他变量之后保持可用性。<strong>如果一种类型本身或这种类型的任意成员实现了Drop这种trait，那么Rust就不允许其实现Copy这种trait</strong>。尝试给某个需要在离开作用域时执行特殊指令的类型实现Copy这种trait会导致编译时错误</p>
<h2 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h2><p>将值传递给函数在语义上<strong>类似于对变量进行赋值</strong>。将变量传递给函数将会触发移动或复制，就像是赋值语句一样</p>
<p>可以通过函数的返回值的移动来转移所有权，可以直接将实参返回来将其所有权重新移交给原变量。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    a: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Drop</span> <span class="keyword">for</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">drop</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, <span class="keyword">self</span>.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>() <span class="punctuation">-&gt;</span> Foo &#123;</span><br><span class="line">    Foo &#123;</span><br><span class="line">        a: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;test&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="title function_ invoke__">test</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Running!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果如下：</span></span><br><span class="line"><span class="comment">//test</span></span><br><span class="line"><span class="comment">//Running!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据上面这个例子，如果说函数返回值没被接受，所有权没被转移，则在被调用者函数末尾被析构</p>
</blockquote>
<p>当然这种返回参数的所有权的方法是不推荐的，由于函数参数的移动问题，就产生了引用。</p>
<h2 id="和C-的对比"><a href="#和C-的对比" class="headerlink" title="和C++的对比"></a>和C++的对比</h2><p>其实在作用域结束后发生drop和C++的析构函数没有什么区别，只是由于Rust存在所有权机制，可以在编译期就检查出它为你添加的drop函数应该放在何处<br>C++对于析构函数的态度是，每个局部变量在出作用域之后都会发生语义上的析构，而Rust利用所有权机制，同一时刻只存在一个所有者具有值的所有权，同时只有所有者出作用域时drop，使得不会发生额外的析构。这意味着编译器检查时不会出现drop俩两次，释放两次内存的情况<br>C++对于变量处理的态度是一致的，而Rust区分是否具有所有权，是否为所有者。事实上即使是对于C++11添加的<strong>移动语义</strong>，其也只是在移动构造函数等地方把移动的对象内部的指针变成<code>nullptr</code>，实质上在作用域最后<strong>仍然需要对移动后的对象进行析构</strong>，只不过C++允许delete nullptr罢了<br>对于C++中指针/引用空悬等问题，是交由后面会提到的Rust的<strong>生命周期</strong>来解决的</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>这个概念应该是来自于C/C++</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;&#125;&#x27; is &#123;&#125;.&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用是获取变量使用权但不获取其所有权的一种方式，引用指向的是被引用变量的地址，而不是内存中数据的地址，实际上我们拥有的是引用的所有权，所以 Drop 的也是引用变量而已。和C++一致可以用&amp;引用，用*解引用。</p>
<p>借用是指：当没有定义引用变量，而是直接使用&amp;var，将变量的引用作为参数传入函数时，此时就发生了借用。</p>
<p>我们可以声明可变引用，但可变引用在使用上有一个很大的限制：<strong>对于特定作用域中的特定数据来说，一次只能声明一个可变引用</strong>，利用这个性质，我们可以避免数据竞争，安全的写入原本的数据</p>
<h2 id="引用的规则"><a href="#引用的规则" class="headerlink" title="引用的规则"></a>引用的规则</h2><p>让我们简要地概括一下本节对引用的讨论：</p>
<ul>
<li>在任何一段给定的时间里，你要么只能拥有一个可变引用，要<br>么只能拥有任意数量的不可变引用。</li>
<li>引用总是有效的。</li>
</ul>
<h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p><strong>slice是对数据类型中一部分值的不可变引用</strong><br>小小用一下书里给的一些例子展示一下</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">len</span> = s.<span class="title function_ invoke__">len</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..len];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[<span class="number">3</span>..];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;s[..];</span><br></pre></td></tr></table></figure>
<p>由于slice本身就是引用，所以在定义了slice后，对原本值的修改都会被 Rust 编译器检查到。</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_4_结构体</title>
    <url>/posts/ae9548c.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-4-结构体"><a href="#Rust-Chapter-4-结构体" class="headerlink" title="Rust_Chapter_4_结构体"></a>Rust_Chapter_4_结构体</h1><p>对于早期学习了C++的我来说，OOP是很重要的东西，因而同理Rust里的结构体也是极其重要的</p>
<span id="more"></span>
<h2 id="结构体的定义与实例化"><a href="#结构体的定义与实例化" class="headerlink" title="结构体的定义与实例化"></a>结构体的定义与实例化</h2><p>和元组不一样的是，结构体需要给每个数据赋予名字以便清楚地表明它们的意义。正是由于有了这些名字，结构体的使用要比元组更加灵活：你不再需要依赖顺序索引来指定或访问实例中的值。</p>
<h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><p>关键字struct被用来定义并命名结构体，一个良好的结构体名称应当能够反映出自身数据组合的意义。除此之外，我们还需要在随后的花括号中声明所有数据的名字及类型，这些数据也被称作字段。如下代码展示了一个用于存储账户信息的结构体定义：<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  username: <span class="type">String</span>,</span><br><span class="line">  email: <span class="type">String</span>,</span><br><span class="line">  sign_in_count: <span class="type">u64</span>,</span><br><span class="line">  active: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意到这里与C++不同的语法，首先类型后置不必多言，所有类型结尾都要接上一个逗号<code>,</code>，而且结构体声明的最后也不需要加上一个在C/C++中很容易忘掉的分号<code>;</code></p>
<h3 id="结构体的实例化"><a href="#结构体的实例化" class="headerlink" title="结构体的实例化"></a>结构体的实例化</h3><p>直接看代码，和C++很不一样，这里首先要<strong>加上成员变量的名字</strong>，再把Rust结构体的定义中的类型名换成具体的名字。注意到这里是一条语句，所以语句的结尾要加上分号<code>;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User &#123;</span><br><span class="line">  email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">  active: <span class="literal">true</span>,</span><br><span class="line">  sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在获得了结构体实例后，我们可以通过<strong>点号</strong>来访问实例中的特定字段(熟悉的语法)。<br>如果你想获得某个用户的电子邮件地址，那么可以使用<code>user1.email</code>来获取。另外，<strong>假如</strong>这个结构体的<strong>实例是可变</strong>的(结构体的定义当然无关可不可变)，那么我们还可以通过点号来修改字段中的值。示例5-3展示了如何修改一个<strong>可变</strong><code>User</code>实例中<code>email</code>字段的值</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User &#123;</span><br><span class="line">  email: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@example.com&quot;</span>),</span><br><span class="line">  username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someusername123&quot;</span>),</span><br><span class="line">  active: <span class="literal">true</span>,</span><br><span class="line">  sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user1.email = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;anotheremail@example.com&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>需要注意的是，一旦实例可变，那么实例中的所有字段都将是可变的。<strong>Rust不允许我们单独声明某一部分字段的可变性</strong>。如同其他表达式一样，我们可以在函数体的最后一个表达式中构造结构体实例，来隐式地将这个实例作为结果返回。</p>
<p>下面这个例子中的<code>build_user</code>函数会使用传入的邮箱和用户名参数构造并返回<code>User</code>实例。另外两个字段<code>active</code>和<code>sign_in_count</code>则分别被赋予了值true和1。<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">build_user</span>(email: <span class="type">String</span>, username: <span class="type">String</span>) <span class="punctuation">-&gt;</span> User &#123;</span><br><span class="line">  User &#123;</span><br><span class="line">    email: email,</span><br><span class="line">    username: username,</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_5_枚举与模式匹配</title>
    <url>/posts/28bcc6be.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-5-枚举与模式匹配"><a href="#Rust-Chapter-5-枚举与模式匹配" class="headerlink" title="Rust_Chapter_5_枚举与模式匹配"></a>Rust_Chapter_5_枚举与模式匹配</h1><p><code>enums</code>，一个很有用的东西，使用枚举可以简化很多东西</p>
<span id="more"></span>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>关于枚举，书上给出的一个例子是这样的</p>
<blockquote>
<p>假设我们要处理 IP 地址。目前被广泛使用的两个主要 IP 标准：IPv4(version four)和 IPv6(version six)。这是我们的程序可能会遇到的所有可能的 IP 地址类型：所以可以 <strong>枚举</strong> 出所有可能的值，这也正是此枚举名字的由来</p>
</blockquote>
<p>例子和代码都很简单，正如和常见语言都是一致的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddrKind</span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h3><p>可以像下面这样创建<code>IpAddrKind</code>两个不同成员的实例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">four</span> = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">six</span> = IpAddrKind::V6;</span><br></pre></td></tr></table></figure>
<p>也可以像C++那样作为函数参数传递给函数</p>
<h3 id="枚举值绑定变量"><a href="#枚举值绑定变量" class="headerlink" title="枚举值绑定变量"></a>枚举值绑定变量</h3><p>这是Rust enum强于C++的地方，其允许枚举值去绑定一个变量，能够有效减少一些事情，比如像我最近写的一个<a href="https://github.com/feipiao594/telegram_rust_charge_bot">telegram_bot</a>，如果一个command需要传递，我们通常不仅仅需要command的类型，还有更多的信息需要被传递。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">IpAddr</span> &#123;</span><br><span class="line">    <span class="title function_ invoke__">V4</span>(<span class="type">String</span>),</span><br><span class="line">    <span class="title function_ invoke__">V6</span>(<span class="type">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">home</span> = IpAddr::<span class="title function_ invoke__">V4</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;127.0.0.1&quot;</span>));</span><br><span class="line"><span class="keyword">let</span> <span class="variable">loopback</span> = IpAddr::<span class="title function_ invoke__">V6</span>(<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;::1&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>我们直接将数据附加到枚举的每个成员上，这样就不需要一个额外的结构体了。这里也很容易看出枚举工作的另一个细节：每一个我们定义的枚举成员的名字也变成了一个构建枚举的实例的函数。也就是说，<code>IpAddr::V4()</code> 是一个获取<code>String</code>参数并返回<code>IpAddr</code>类型实例的函数调用。作为定义枚举的结果，这些构造函数会<strong>自动被定义</strong>。</p>
<p><strong>让我们分析这样做的好处</strong>，对于C++ enum来说，从数学上看，一个类型我们可以声明为一个集合里的元素，称这个集合为一个类型，集合内的元素是一个具体的值，比如int类型就是一个有限长的集合，而枚举类就相当于设定一个新类型，或者说叫新集合，其中的元素或者说叫做枚举值是固定的</p>
<p>但是Rust高明之处就是将枚举值绑定了一个变量，它可以扩展其中的概念，让枚举的名称与枚举所带的变量构成的笛卡尔积内的元素成为了枚举的元素，大大提高了灵活度</p>
<p>从这点看来union其实是一个非安全的enum，它没有标签，读取时也容易发生错误</p>
<h3 id="Option"><a href="#Option" class="headerlink" title="Option\"></a>Option\<T\></h3><p><code>Option&lt;T&gt;</code>是那么有用以至于它其实被很多语言内嵌在语言当中，其表示一个值可以为空，这其实是一个很常见的东西</p>
<p>在对<code>Option&lt;T&gt;</code>进行运算之前必须将其转换为T。通常这能帮助我们捕获到空值最常见的问题之一：假设某值不为空但实际上为空的情况。</p>
<p>消除了错误地假设一个非空值的风险，会让你对代码更加有信心。为了拥有一个可能为空的值，你必须要显式的将其放入对应类型的<code>Option&lt;T&gt;</code>中。接着，当使用这个值时，必须明确的处理值为空的情况。只要一个值不是<code>Option&lt;T&gt;</code>类型，你就可以安全的认定它的值不为空。这是Rust的一个经过深思熟虑的设计决策，来限制空值的泛滥以增加Rust代码的安全性。</p>
<h2 id="match控制流结构"><a href="#match控制流结构" class="headerlink" title="match控制流结构"></a>match控制流结构</h2><p>只要一个例子便可以解释这个东西，模式匹配我个人认为就是更为强大的switch case</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 这样可以立刻看到州的名称</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">UsState</span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// --snip--</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Coin</span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    <span class="title function_ invoke__">Quarter</span>(state),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">value_in_cents</span>(coin: Coin) <span class="punctuation">-&gt;</span> <span class="type">u8</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;Lucky penny!&quot;</span>);</span><br><span class="line">            <span class="number">1</span></span><br><span class="line">        &#125;,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::<span class="title function_ invoke__">Quarter</span>(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;State quarter from &#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>语法结构就是<code>match</code>关键字后写要进行匹配的那个变量，当<code>match</code>表达式执行时，它将这个变量按从上到下的顺序与每一个分支的模式相比较。如果模式匹配了这个值，这个模式相关联的代码将被执行，也就是说<code>=&gt;</code>后面跟着的不一定非要是一个数字，也可以是一个<code>&#123;&#125;</code>里的一串语句，最后整个表达式输出一个值，这意味着你可以在模式匹配时做一些事情</p>
<p>模式匹配也能拆解一个复杂的类型，比如获取到上面提到的enum内部的<code>state</code>类型</p>
<p>注意，匹配表达式匹配结果将通过匹配到的<code>=&gt;</code>返回，整个<code>match</code>是一个表达式，它有具体的值与其对应的数据</p>
<h3 id="通配模式与-占位符"><a href="#通配模式与-占位符" class="headerlink" title="通配模式与_占位符"></a>通配模式与<code>_</code>占位符</h3><p>我们可以在match表达式匹配无法被穷尽的时候，加入一个类似switch case里default的东西，比如在上面的例子里添加一个<code>_ =&gt; 594</code>，当当你仍然要用这个无法被匹配到的值做一些事情(比如你确信它实现了display traits，打算匹配不到就输出其中的内容)，那么你就可以使用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">other =&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">do_someting</span>();</span><br><span class="line">    return_value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很合理对吧</p>
<h2 id="if-let简洁控制流"><a href="#if-let简洁控制流" class="headerlink" title="if let简洁控制流"></a><code>if let</code>简洁控制流</h2><p>可以用下面的例子仅仅匹配一个单独的模式，<code>if let</code>既是<code>match</code>的一个简单使用时的简化版本</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">count</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Coin</span>::<span class="title function_ invoke__">Quarter</span>(state) =coin &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;State quarter from&#123;:?&#125;!&quot;</span>, state);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    count += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_6_包与crate</title>
    <url>/posts/23fc5c90.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-6-包与crate"><a href="#Rust-Chapter-6-包与crate" class="headerlink" title="Rust_Chapter_6_包与crate"></a>Rust_Chapter_6_包与crate</h1><p>相比于C++，Rust最吸引我得就是其强大的包管理与调用，cargo实在是太好用了。现在，我们来讨论包与crate相关的内容</p>
<span id="more"></span>
<h2 id="包与crate"><a href="#包与crate" class="headerlink" title="包与crate"></a>包与crate</h2><p><code>crate</code>是Rust在编译时最小的代码单位。其分为两种，一种是<strong>二进制项</strong>，一种是<strong>库</strong>，其中库crate不包括<code>main</code>函数</p>
<p>包(package)是提供一系列功能的一个或者多个crate。一个包会包含一个<code>Cargo.toml</code>文件，阐述如何去构建这些 crate。Cargo就是一个包含构建你代码的二进制项的包。Cargo也包含这些二进制项所依赖的库。其他项目也能用Cargo库来实现与Cargo命令行程序一样的逻辑。</p>
<p>包中可以包含<strong>至多一个库</strong>crate(library crate)。包中可以包含<strong>任意多个二进制</strong>crate(binary crate)，但是必须至少包含一个crate(无论是库的还是二进制的)。</p>
<p>一个标准的项目目录如下，来自Rust语言圣经(Rust Course):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── src</span><br><span class="line">│   ├── main.rs</span><br><span class="line">│   ├── lib.rs</span><br><span class="line">│   └── bin</span><br><span class="line">│       └── main1.rs</span><br><span class="line">│       └── main2.rs</span><br><span class="line">├── tests</span><br><span class="line">│   └── some_integration_tests.rs</span><br><span class="line">├── benches</span><br><span class="line">│   └── simple_bench.rs</span><br><span class="line">└── examples</span><br><span class="line">    └── simple_example.rs</span><br></pre></td></tr></table></figure>
<ul>
<li>唯一库包：<code>src/lib.rs</code></li>
<li>默认二进制包：<code>src/main.rs</code>，编译后生成的可执行文件与Package同名</li>
<li>其余二进制包：<code>src/bin/main1.rs</code>和<code>src/bin/main2.rs</code>，它们会分别生成一个文件同名的二进制可执行文件</li>
<li>集成测试文件：<code>tests</code>目录下</li>
<li>基准性能测试benchmark文件：<code>benches</code>目录下</li>
<li>项目示例：<code>examples</code>目录下</li>
</ul>
<p>要注意的是上面的这些是Cargo的默认规范，但你可以不跟据规范来，比如你想在一个自定义的文件夹底下放一个<code>main3.rs</code>，你可以在<code>Cargo.toml</code>内用<code>[[bin]]</code>来指定一个二进制项的包。就像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[[bin]]</span><br><span class="line">name =&quot;myproject&quot;</span><br><span class="line">path =&quot;src/myproject/bin/main3.rs&quot;</span><br></pre></td></tr></table></figure>
<p>但我们一般不会这么做，使用规范肯定要更加合适。</p>
<p>上面我们这样定义的<code>src/lib.rs</code>也好<code>src/main.rs</code>也好，其实是一个crate的一个<strong>根文件</strong>，编译器在编译时，会通过这个根文件里写的<code>use</code>语句按照一定的规则查找相对路径底下的一些crate的其他文件，并且将文件共同串联组成一个crate的树，这棵树叫做<strong>模块树</strong></p>
<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> my_mod &#123;</span><br><span class="line">  <span class="keyword">fn</span> <span class="title function_">private_function</span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;called `my_mod::private_function()`&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">function</span>() &#123;</span><br><span class="line">      <span class="built_in">println!</span>(<span class="string">&quot;called`my_mod::function()`&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用<code>mod</code>关键字声明了一个名叫<code>my_mod</code>的一个<strong>模块/module</strong></p>
<h3 id="引用模块内的东西"><a href="#引用模块内的东西" class="headerlink" title="引用模块内的东西"></a>引用模块内的东西</h3><p>类似于C++的namespace，你可以使用相对路径，绝对路径来访问模块内的东西(前提是下面提到的可见性要符合)</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">fn</span> <span class="title function_">add_to_waitlist</span>() &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">eat_at_restaurant</span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::hosting::<span class="title function_ invoke__">add_to_waitlist</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>绝对路径：以crate(会指向当前所在包名)或者包名起手开始逐级下来，使用crate作为开始就和使用<code>/</code>作为开始一样。</li>
<li>相对路径：相比绝对路径少了crate根到当前module</li>
</ul>
<p>还有一些小点子<br><code>super</code>关键字，在相对路径中可以作为相对路径的开头，它代表的是当前module的父module，你可以连着使用<code>super</code><br><code>self</code>关键字，在相对路径中可以作为相对路径的开头，它代表的就是当前module</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>模块内的东西具有可见性，默认为私有，加上<code>pub</code>关键字可以使得其内部的函数，结构体之类的东西能够被外部访问，但在模块内部，是可以访问的，模块本身可以嵌套，我们可以在这个<code>my_mod</code>内同样的写一个<code>my_mod2</code></p>
<p>但注意：</p>
<ul>
<li>将结构体设置为<code>pub</code>，但它的所有字段依然是私有的</li>
<li>将枚举设置为<code>pub</code>，它的所有字段也将对外可见</li>
</ul>
<h3 id="模块内容存于文件-夹-中"><a href="#模块内容存于文件-夹-中" class="headerlink" title="模块内容存于文件(夹)中"></a>模块内容存于文件(夹)中</h3><p>当你使用在某个文件中使用<code>mod something</code>定义一个模块时，你可以在这个文件的相对路径下方创建一个文件或者文件夹来将花括号<code>&#123;&#125;</code>中的内容放到文件/文件夹下的<code>mod.rs</code>中，但要求这个文件就叫<code>something.rs</code>或者文件夹名字<code>something</code>(显然是一种规范)，如此，模块的声明和实现是分离的</p>
<p>看看下面这个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── Cargo.toml</span><br><span class="line">├── Cargo.lock</span><br><span class="line">└── src</span><br><span class="line">    ├── main.rs</span><br><span class="line">    ├── something1.rs</span><br><span class="line">    └── something2</span><br><span class="line">        └── mod.rs</span><br><span class="line">        └── something3.rs</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---src/main.rs---*/</span></span><br><span class="line"><span class="keyword">mod</span> something1;</span><br><span class="line"><span class="keyword">mod</span> something2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">  something2::something3::<span class="title function_ invoke__">fun</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---src/something2/something3.rs---*/</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun</span>()&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;call something3&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---src/something2/mod.rs---*/</span></span><br><span class="line"><span class="keyword">mod</span> something3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">fun</span>()&#123;</span><br><span class="line">  <span class="built_in">println!</span>(<span class="string">&quot;call something2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用use引用模块"><a href="#使用use引用模块" class="headerlink" title="使用use引用模块"></a>使用use引用模块</h2><p>嗯，有一种python import的感觉</p>
<ul>
<li>可以用与module定义一致的相对引用与绝对引用的方式来减少写一长串的引用，减少<code>::</code>的个数(尽管某些C++程序员觉得很多的<code>::</code>很酷)<br>减少的方式就是，像上面这个<a href="#模块内容存于文件(夹">模块内容存于文件(夹)中</a>中)所给出的例子来看，你可以使用<code>use something2::something3::fun;</code>令你以后使用fun的时候可以不用输入前面的一串，当然你也可以只引入一个module，即<code>use something2::something3;</code>，那么你使用时就要<code>something3::fun();</code>了<br>总之就是，什么在use那一串的最后就拿他起手</li>
<li>解决冲突，当你use了两个相同的函数，这必然会导致和C++命名空间污染一样的编译期错误，这要求你尽量避免这种引用，当然即使你这么做了，你仍然可以在函数前面加上<code>mod_name::</code>的前缀去修正这个冲突</li>
<li>对于同名冲突问题，还可以使用 as 关键字来解决，它可以赋予引入项一个全新的名称：<code>use std::io::Result as IoResult;</code></li>
<li>用花括号减少写多行的引用：<code>use std::&#123;cmp::Ordering, io&#125;;</code></li>
<li>使用<code>*</code>引入模块下的所有项，就像我们在python中做的那样</li>
</ul>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_7_错误处理</title>
    <url>/posts/d7b468f6.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-7-错误处理"><a href="#Rust-Chapter-7-错误处理" class="headerlink" title="Rust_Chapter_7_错误处理"></a>Rust_Chapter_7_错误处理</h1><p>Rust 没有异常。相反，它有 <code>Result&lt;T, E&gt;</code> 类型，用于处理可恢复的错误，还有 <code>panic!</code> 宏，在程序遇到不可恢复的错误时停止执行。</p>
<span id="more"></span>
<h2 id="panic"><a href="#panic" class="headerlink" title="panic!"></a><code>panic!</code></h2><p><code>panic!</code> 针对的是不可恢复的操作</p>
<p>执行会造成代码 <code>panic</code> 的操作（比如访问超过数组结尾的内容）或者显式调用 <code>panic!</code> 宏。这两种情况都会使程序 <code>panic</code>。通常情况下这些 panic 会打印出一个错误信息，展开并清理栈数据，然后退出。</p>
<p>在错误信息中，通常会提示你设置 <code>RUST_BACKTRACE</code> 环境变量已得到错误发生时的函数调用栈，以帮助你定位错误发生的位置</p>
<h2 id="使用-Result"><a href="#使用-Result" class="headerlink" title="使用 Result"></a>使用 Result</h2><p>现如今，很多语言都引入了 Result 的概念，将错误和结果打包成一个枚举返回有助于错误的传递<br>当结果无误时，返回 Ok(something)，在结果有错误时，返回一个 Err(some_error)</p>
<p>可以利用模式匹配来处理这些枚举</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::ErrorKind;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = <span class="keyword">match</span> greeting_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(error) =&gt; <span class="keyword">match</span> error.<span class="title function_ invoke__">kind</span>() &#123;</span><br><span class="line">            ErrorKind::NotFound =&gt; <span class="keyword">match</span> File::<span class="title function_ invoke__">create</span>(<span class="string">&quot;hello.txt&quot;</span>) &#123;</span><br><span class="line">                <span class="title function_ invoke__">Ok</span>(fc) =&gt; fc,</span><br><span class="line">                <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="built_in">panic!</span>(<span class="string">&quot;Problem creating the file: &#123;e:?&#125;&quot;</span>),</span><br><span class="line">            &#125;,</span><br><span class="line">            other_error =&gt; &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(<span class="string">&quot;Problem opening the file: &#123;other_error:?&#125;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但模式匹配仍然会导致代码长度很长，你也可以使用一些相对来说更简单易用的函数，例如 <code>unwrap_or_else</code></p>
<p>比较常用的另一组是 <code>unwarp</code> 和 <code>expect</code>，他们两作为 Result 的函数，会获取 Ok 内部的值，如果获取不到，则陷入 panic，区别在于 expect 有自己的参数，你填写的字符串作为报错信息显示</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>).<span class="title function_ invoke__">unwarp</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">greeting_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)</span><br><span class="line">        .<span class="title function_ invoke__">expect</span>(<span class="string">&quot;hello.txt should be included in this project&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="传播可恢复的错误"><a href="#传播可恢复的错误" class="headerlink" title="传播可恢复的错误"></a>传播可恢复的错误</h2><p>当编写一个其实先会调用一些可能会失败的操作的函数时，除了在这个函数中处理错误外，还可以选择让调用者知道这个错误并决定该如何处理。这被称为<strong>传播</strong>错误，这样能更好的控制代码调用，因为比起你代码所拥有的上下文，调用者可能拥有更多信息或逻辑来决定应该如何处理错误。</p>
<p>你可以使用下面的方法手动把获取到的 Result 拆开，生成你自己函数要返回的 Result<br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">username_file_result</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = <span class="keyword">match</span> username_file_result &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(file) =&gt; file,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(_) =&gt; <span class="title function_ invoke__">Ok</span>(username),</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; <span class="title function_ invoke__">Err</span>(e),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为这种错误传播效果比较明显，所以会被大量使用，但每次都这么写太冗余了</p>
<h2 id="传播错误的简写：-运算符"><a href="#传播错误的简写：-运算符" class="headerlink" title="传播错误的简写：? 运算符"></a>传播错误的简写：? 运算符</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fs::File;</span><br><span class="line"><span class="keyword">use</span> std::io::&#123;<span class="keyword">self</span>, Read&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">read_username_from_file</span>() <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">String</span>, io::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username_file</span> = File::<span class="title function_ invoke__">open</span>(<span class="string">&quot;hello.txt&quot;</span>)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">username</span> = <span class="type">String</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    username_file.<span class="title function_ invoke__">read_to_string</span>(&amp;<span class="keyword">mut</span> username)?;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(username)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Result 的值是 Ok，这个表达式将会返回 Ok 中的值而程序将继续执行。如果值是 Err，Err 将作为整个函数的返回值，就好像使用了 return 关键字一样，这样错误值就被传播给了调用者。</p>
<p>? 运算符所使用的错误值被传递给了 from 函数，它定义于标准库的 From trait 中，其用来将错误从一种类型转换为另一种类型。当 ? 运算符调用 from 函数时，收到的错误类型被转换为由当前函数返回类型所指定的错误类型。这在当函数返回单个错误类型来代表所有可能失败的方式时很有用，即使其可能会因很多种原因失败。</p>
<p>例如，我们可以将示例中的 <code>read_username_from_file</code> 函数修改为返回一个自定义的 <code>OurError</code> 错误类型。如果我们也定义了 <code>impl From&lt;io::Error&gt; for OurError</code> 来从 <code>io::Error</code> 构造一个 <code>OurError</code> 实例，那么 <code>read_username_from_file</code> 函数体中的 ? 运算符调用会调用 from 并转换错误而无需在函数中增加任何额外的代码。</p>
<p>关于 ? 运算符还有以下几点</p>
<ul>
<li>? 运算符只能被用于返回值与 ? 作用的值相兼容的函数。</li>
<li>? 运算符也可用于 <code>Option&lt;T&gt;</code> 值。</li>
</ul>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_8_泛型</title>
    <url>/posts/bdd7a1b0.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-8-泛型"><a href="#Rust-Chapter-8-泛型" class="headerlink" title="Rust_Chapter_8_泛型"></a>Rust_Chapter_8_泛型</h1><p>泛型是用来缩减重复书写的代码的优良工具，Rust 如同 C++ 一样引入了这样的一个工具</p>
<span id="more"></span>
<blockquote>
<p>关于: 这个系列一开始是帮我学习 Rust 的，但时间拖的有些长了，我也不再是初学者了，但我没有将事情做好一半就停下的习惯，就慢慢把它写完吧，说不定到时候还能在前面的内容添加一些自己的理解，不过短期内还是以学习笔记为主吧</p>
</blockquote>
<h2 id="在函数定义中使用泛型"><a href="#在函数定义中使用泛型" class="headerlink" title="在函数定义中使用泛型"></a>在函数定义中使用泛型</h2><p>同 C++ 中的泛型一样，如果要在函数体中使用参数，就必须在函数签名中声明它的名字，好让编译器知道这个名字指代的是什么。同理，当在函数签名中使用一个类型参数时，必须在使用它之前就声明它。类型参数声明位于函数名称与参数列表中间的尖括号 &lt;&gt; </p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">largest</span>&lt;T&gt;(list: &amp;[T]) <span class="punctuation">-&gt;</span> &amp;T &#123;...&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体，枚举中的泛型"><a href="#结构体，枚举中的泛型" class="headerlink" title="结构体，枚举中的泛型"></a>结构体，枚举中的泛型</h2><p><strong>结构体&amp;方法的泛型</strong><br><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">x</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;p.x = &#123;&#125;&quot;</span>, p.<span class="title function_ invoke__">x</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然定义方法时你也可以针对一个具体的从泛型确定的类型来定义，专业术语为<strong>泛型指定限制</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Point</span>&lt;<span class="type">f32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">distance_from_origin</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>) + <span class="keyword">self</span>.y.<span class="title function_ invoke__">powi</span>(<span class="number">2</span>)).<span class="title function_ invoke__">sqrt</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>结构体定义中的泛型类型参数并不总是与结构体方法签名中使用的泛型是同一类型。</p>
</blockquote>
<p><strong>枚举的泛型</strong></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Result 就是一个很好的例子</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(T),</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(E),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于实现"><a href="#关于实现" class="headerlink" title="关于实现"></a>关于实现</h2><p>仍然和 C++ 的模板一致，在编译期 Rust 编译器会根据具体使用到的代码，根据泛型实例化一个具体的实现</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>Rust_Chapter_9_Trait</title>
    <url>/posts/fa0fbc5d.html</url>
    <content><![CDATA[<h1 id="Rust-Chapter-9-Trait"><a href="#Rust-Chapter-9-Trait" class="headerlink" title="Rust_Chapter_9_Trait"></a>Rust_Chapter_9_Trait</h1><p>Trait 是我认为 Rust 中最好用最有特色的特性之一，它和 C++20 的 Concept 很像，trait 也类似于其他语言中的常被称为<strong>接口</strong>(interfaces)的功能，虽然有一些不同。</p>
<span id="more"></span>
<h2 id="定义一个-Trait"><a href="#定义一个-Trait" class="headerlink" title="定义一个 Trait"></a>定义一个 Trait</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">trait</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pub</code> 字段说明了其对外部 crate 的可见性，在这里不重要<br>这里我们定义了一个签名为 <code>Summary</code> 的 Trait，当然 Trait 体中可以有多个方法：一行一个方法签名且都以分号结尾。在大括号中声明描述实现这个 trait 的类型所需要的行为的方法签名，在这个例子中是 <code>fn summarize(&amp;self) -&gt; String</code>。在定义了 Trait 后我们就可以为类型实现 Trait 了</p>
<h3 id="为类型实现-Trait"><a href="#为类型实现-Trait" class="headerlink" title="为类型实现 Trait"></a>为类型实现 Trait</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> headline: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> location: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> author: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">NewsArticle</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;, by &#123;&#125; (&#123;&#125;)&quot;</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> username: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> content: <span class="type">String</span>,</span><br><span class="line">    <span class="keyword">pub</span> reply: <span class="type">bool</span>,</span><br><span class="line">    <span class="keyword">pub</span> retweet: <span class="type">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Summary</span> <span class="keyword">for</span> <span class="title class_">Tweet</span> &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">summarize</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们为两个类型 <code>NewsArticle</code>、<code>Tweet</code> 分别 <code>impl</code> 了 <code>Summary Trait</code>，也就是需要提供一个 summarize 的函数定义</p>
<p>可以看到它的语义像是：一个可以 <strong>summarize</strong> 的东西是一个 <strong>Summary</strong></p>
<h2 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h2><p>我们可以在定义 Trait 时给予函数一个定义，是为默认定义，如果后面 <code>impl</code> 时没有被显式覆盖，则使用默认定义，当然就像函数默认值那样，你可以不在 <code>impl</code> 时具体声明它，这样就使用的是默认定义</p>
<h2 id="Trait-作为参数"><a href="#Trait-作为参数" class="headerlink" title="Trait 作为参数"></a>Trait 作为参数</h2><p>知道了如何定义 Trait 和在类型上实现这些 Trait 之后，我们可以探索一下如何使用 Trait 来接受多种不同类型的参数。下面的示例中为 <code>NewsArticle</code> 和 <code>Tweet</code> 类型实现了 <code>Summary</code> Trait，用其来定义了一个函数 notify 来调用其参数 item 上的 <code>summarize</code> 方法，该参数是实现了 <code>Summary</code> Trait 的某种类型。为此可以使用 <code>impl</code> Trait 语法，像这样：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>(item: &amp;<span class="keyword">impl</span> <span class="title class_">Summary</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>item</code> 参数，我们指定了 <code>impl</code> 关键字和 Trait 名称，而不是具体的类型。该参数支持任何实现了指定 Trait 的类型。在 <code>notify</code> 函数体中，可以调用任何来自 <code>Summary</code> trait 的方法，比如 <code>summarize。我们可以传递任何</code> <code>NewsArticle</code> 或 <code>Tweet</code> 的实例来调用 <code>notify</code>。任何用其它如 <code>String</code> 或 <code>i32</code> 的类型调用该函数的代码都不能编译，因为它们没有实现 <code>Summary</code></p>
<h2 id="Trait-Bound"><a href="#Trait-Bound" class="headerlink" title="Trait Bound"></a>Trait Bound</h2><p>上面的示例其实更像下面代码的语法糖</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">notify</span>&lt;T: Summary&gt;(item: &amp;T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Breaking news! &#123;&#125;&quot;</span>, item.<span class="title function_ invoke__">summarize</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Trait Bound</strong> 这种写法的适用性更强</p>
<p>下面的两个例子分别展示了使用 <code>+</code> 表示一个同时实现了  <code>Display</code> 和 <code>Clone</code> 的类型，这意味着 <code>some_function</code> 接受的类型必须同时实现 <code>Display</code> 和 <code>Clone</code> </p>
<p>其中前者写进了尖括号&lt;&gt;<br>后者写在 <code>where</code> 从句中</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T: Display + <span class="built_in">Clone</span>, U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">some_function</span>&lt;T, U&gt;(t: &amp;T, u: &amp;U) <span class="punctuation">-&gt;</span> <span class="type">i32</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">    U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span>,</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在返回值中使用 <code>impl</code> Trait 语法，来返回实现了某个 trait 的类型：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">returns_summarizable</span>() <span class="punctuation">-&gt;</span> <span class="keyword">impl</span> <span class="title class_">Summary</span> &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;horse_ebooks&quot;</span>),</span><br><span class="line">        content: <span class="type">String</span>::<span class="title function_ invoke__">from</span>(</span><br><span class="line">            <span class="string">&quot;of course, as you probably already know, people&quot;</span>,</span><br><span class="line">        ),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意此处要求返回确定的类型，如果你这个函数可能返回不止一种类型那么也是不行的</p>
</blockquote>
<h2 id="有条件的实现方法"><a href="#有条件的实现方法" class="headerlink" title="有条件的实现方法"></a>有条件的实现方法</h2><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(x: T, y: T) <span class="punctuation">-&gt;</span> <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">cmp_display</span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is x = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">&quot;The largest member is y = &#123;&#125;&quot;</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这有点像 C++ 偏特化，可以对任何实现了特定 trait 的类型有条件地实现 trait。对任何满足特定 trait bound 的类型实现 trait 被称为 blanket implementations，它们被广泛的用于 Rust 标准库中。</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Rust</category>
      </categories>
  </entry>
  <entry>
    <title>CMake的使用</title>
    <url>/posts/3c5e47f1.html</url>
    <content><![CDATA[<h1 id="CMake的使用"><a href="#CMake的使用" class="headerlink" title="CMake的使用"></a>CMake的使用</h1><p><strong>Feipiao</strong>前段时间在做csapp的lab使用到了linux，最近把linux虚拟机换成了wsl，在vscode下进行 <strong>code &amp; study</strong><br>对于在vscode上，或者直接就是在linux内进行开发，使用make这种编译配置工具就跑不了了。<br>在这样的情况下，使用cmake进行<strong>跨平台</strong>的高级编译配置也就免不了了。<br><span id="more"></span></p>
<h2 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h2><p>我们先用单文件的helloworld练练手，首先创建一个文件为main.cpp<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;Hello world&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>再创建一个CMakeLists.txt的文本文件注意这个文本文件的名字大小写是<strong>敏感</strong>的，在这个文本文件当中，我们就会进行cmake的书写与使用<br>CMakeLists.txt 的语法比较简单，由<strong>命令、注释和空格</strong>组成，其中命令是<strong>不区分</strong>大小写的</p>
<p>在这个文件中输入几个重要的，每个CMakeLists.txt都不可或缺的指令：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目名称信息</span><br><span class="line">project (Helloworld)</span><br><span class="line"># 指定生成目标的名字</span><br><span class="line">add_executable(main main.cpp)</span><br></pre></td></tr></table></figure></p>
<p>以“#”开头的为<strong>注释</strong><br>运行cmake需要输入<code>cmake .</code>这里的<code>.</code>是指在当前文件夹内进行搜索CMakeLists.txt，执行完成后，会生成Makefile文件，再运行make就可以进行编译了。</p>
<h2 id="更深一步，对于多个源文件"><a href="#更深一步，对于多个源文件" class="headerlink" title="更深一步，对于多个源文件"></a>更深一步，对于多个源文件</h2><p>如果在当前文件夹下再创建一个cpp文件和头文件<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*---myfun.cpp---*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfun</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*---myfun.h---*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfun</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><br>我们可以在原来的CMakeList.txt中的<code>add_executable</code>命令后面加上一个文件名，改为<code>add_executable(main main.cpp myfun.cpp)</code>，但显然这样一个一个加东西也不是个事，所以更省事的方法是使用<code>aux_source_directory</code>命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><br>这个命令会把dir下所有源文件统合，把名称存进variable这个位置的变量中，如下例：<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Helloworld)</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(main $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure></p>
<p>对于复杂的文件结构，有如下俩条指令<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加 dir 子目录</span><br><span class="line">add_subdirectory(dir)</span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(main myfun)</span><br></pre></td></tr></table></figure><br>前者会使得dir子目录下的CMakeList.txt会一并处理，后者将指出main需要myfun的链接库</p>
<p>而在子目录中可以使用<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成myfun链接库</span><br><span class="line">add_library (myfun &lt;choice&gt; &lt;filename&gt;)</span><br></pre></td></tr></table></figure><br>其中<code>&lt;choice&gt;</code>为<code>STATIC</code>则为静态链接库，<code>SHARDED</code>则为动态链接库</p>
<h2 id="更多的重要指令"><a href="#更多的重要指令" class="headerlink" title="更多的重要指令"></a>更多的重要指令</h2><p>对于<strong>Feipiao</strong>来说，暂时只要能编译运行就行了，所以我们并不需要完成非常多的事情，因此这就到这里就可以结束了<br>有些指令还需要进行补充<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 支持cpp14</span><br><span class="line">set(CMAKE_CXX_STANDARD 14)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Another</category>
      </categories>
  </entry>
  <entry>
    <title>n重积分转n次积分问题</title>
    <url>/posts/622309a6.html</url>
    <content><![CDATA[<h1 id="n重积分转n次积分问题"><a href="#n重积分转n次积分问题" class="headerlink" title="n重积分转n次积分问题"></a>n重积分转n次积分问题</h1><p>我们在进行n重积分转n次积分时，会遇见积分上下限的问题，我们需要对此进行更为好算的转化。<br><span id="more"></span></p>
<hr>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在$ \mathbb{R^n} $中，n重积分转n次积分直观上是把<strong>一个维度拍扁</strong>，其上的值通过一重积分拍扁在投影上的一个过程<br>我们需要研究的是拍扁所形成的<strong>投影上的积分区域</strong>，以及被拍扁那维的<strong>一次积分的积分上下限</strong></p>
<hr>
<h2 id="一次积分的上下限"><a href="#一次积分的上下限" class="headerlink" title="一次积分的上下限"></a>一次积分的上下限</h2><p>由于是把一个维拍扁，其实我们可以想象有无穷个与$x_n=0$这个坐标轴<strong>平行</strong>的直线与积分区域<strong>截交</strong>，交出来的，处在积分区域内部就是我们要积分的区域啦。</p>
<p>可以想见这个区域是x的一个区间，<strong>广义的</strong>，我们这边说的上下限可以<strong>包括区间之并</strong>，具体落实在计算中可能要写成两个<strong>积分的和式</strong></p>
<hr>
<h2 id="投影上的积分区域"><a href="#投影上的积分区域" class="headerlink" title="投影上的积分区域"></a>投影上的积分区域</h2><p>留下的积分区域是指拍扁这个被拍扁的维度后剩下的投影，可以想见投影比定义域的约束会少一些咯</p>
<hr>
<h2 id="三重积分的“细棒法”和“切片法”"><a href="#三重积分的“细棒法”和“切片法”" class="headerlink" title="三重积分的“细棒法”和“切片法”"></a>三重积分的“细棒法”和“切片法”</h2><p>本质上与上面的n重积分类似，“细棒法”就是说的这种方法，而“切片法”不过就是一下次拍扁两个维度而已。</p>
<hr>
<h2 id="任意坐标系"><a href="#任意坐标系" class="headerlink" title="任意坐标系"></a>任意坐标系</h2><p>可以把原空间中的坐标映射到曲纹坐标系的伴生的$ \mathbb{E^n} $的笛卡尔坐标系上的函数，再进行计算(其实就是把图形也就是点集进行转换)</p>
<hr>
<h2 id="关于n重积分可以拆成n次积分"><a href="#关于n重积分可以拆成n次积分" class="headerlink" title="关于n重积分可以拆成n次积分"></a>关于n重积分可以拆成n次积分</h2><p>这是由<strong>Fubini定理</strong>决定的，定理内容如下：<br>设$f:\mathbb{R}^{2}\rightarrow\mathbb{R}$是绝对可积函数、那么对于几乎每个$y\in\mathbb{R}$，$f(x,y)$是关于$r$在$\mathbb{R}^{2}$上绝对可积的，而且对于几乎每个$z\in\mathbb{R}$，$f(x,y)$是关于，在$\mathbb{R}$上绝对可积的、并且存在绝对可积函数$f:\mathbb{R}\rightarrow\mathbb{R}$以及绝对可积函数$G:\mathbb{R}\rightarrow\mathbb{R}$使得</p>
<script type="math/tex; mode=display">
F(x)=\int_{\mathbb{R}}f(x,y)\mathrm{d}y</script><p>对于几乎每个$x\in\mathbb{R}$成立，并且</p>
<script type="math/tex; mode=display">
G(y)=\int_{\mathbb{R}}f(x,y)\mathrm{d}x</script><p>对于几乎每个$y\in\mathbb{R}$成立，最后</p>
<script type="math/tex; mode=display">
\int_{\mathbb{R}}F(x)\mathrm{d}x=\int_{\mathbb{R}^{2}}f=\int_{\mathbb{R}}G(y)\mathrm{d}y</script>]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>stokes公式</title>
    <url>/posts/7fc7eed7.html</url>
    <content><![CDATA[<h1 id="stokes公式"><a href="#stokes公式" class="headerlink" title="stokes公式"></a>stokes公式</h1><p>我先前对stokes公式了解不够深入，导致使用时出现了一定的问题，就把它单独列出来吧</p>
<span id="more"></span>
<h2 id="stokes定理表述"><a href="#stokes定理表述" class="headerlink" title="stokes定理表述"></a>stokes定理表述</h2><p>For any <strong>smooth</strong> (n-1)-form $\omega$ with <strong>compact support</strong> on the <strong>oriented</strong> n-dimensional manifold $M$</p>
<script type="math/tex; mode=display">\int_{\partial \Omega}\omega=\int_{\Omega}d\omega</script><h2 id="之前遇到的问题"><a href="#之前遇到的问题" class="headerlink" title="之前遇到的问题"></a>之前遇到的问题</h2><blockquote>
<p>之前我将stokes公式用于降低微分n形式的n，我解释它需要求解一个PDE，但我遇到了一些问题，关于三重积分变为闭曲面二重积分，再将闭曲面分离开，再用斯托克斯公式继续降为曲线积分，但发现最后结果变成0了，这是什么原因？</p>
</blockquote>
<h2 id="分析一下"><a href="#分析一下" class="headerlink" title="分析一下"></a>分析一下</h2><p>其实已知的所有定理，包括可加性包括stokes都是正确的，但微分n形式不一定能对应一个微分n-1形式的积分，这里降级的过程不一定成功，自然也就不存在对应关系，不存在对应关系stokes定理绝对是用不了的</p>
<p>事实上我发现有一个降级的<strong>必要条件</strong>，如下图<br><img src="/images/微分流形公式整理_图1.jpg" width="50%" height="50%"></p>
<p>上图即证明，如果能降两级，除非最顶上函数恒为0，不然函数肯定是不存在的，也就无法降级了</p>
<p>而这样一个结论其实就是曲面积分只与边界曲线有关</p>
<h2 id="整理一下"><a href="#整理一下" class="headerlink" title="整理一下"></a>整理一下</h2><ul>
<li>一个曲面积分若能用stokes公式转化为曲线积分，那么把它补齐，在转化为三重积分，微分形式为0($x - x = 0$)(后面的$-x$就是补的面)</li>
<li>一个曲面积分若$d\omega$不为0，不能化到曲线积分($d^2\omega$=0所导致的限制)，若补全并转化为三重积分不为0，也就是说不满足曲面积分只取决于边界曲线，不再是$x-x=0$，而是$x-y\ne0$了</li>
</ul>
<p>stokes公式给出的前提条件是用来把低一级转化为高一级的，其中自然没有障碍，但是要想反推出把高一级转化为低一级的stokes公式，式子当然是没有变化，但是前提条件自然是会发生变化的</p>
<h2 id="进一步"><a href="#进一步" class="headerlink" title="进一步"></a>进一步</h2><p><strong>整理如下表</strong><br><img src="/images/微分流形公式整理_图2.jpg" width="100%" height="100%"></p>
<p>补充一点，这里还有一个<strong>积分区域维度不高于整体维度的约束条件</strong>，即当$\omega$为n维流形的微分n形式时，无法向更高一级转化</p>
<p>直观感受就是一个低一级的积分能被高一级的积分所囊括，但是高一级的积分不一定之和它的边界条件有关，要满足一定的更加苛刻的条件(对于$\int_{\Omega}\omega$想要向低一级转化必须满足$d\omega = 0$)，这是符合直觉的(高维能包含低维，低维包含高维需要制约条件的直觉)</p>
<blockquote>
<p><strong>关键点就是只有$d\omega$等于0时候才能做到“以偏概全”，其它时候只能“高维表达低维”</strong></p>
</blockquote>
<h2 id="闭形式与恰当形式"><a href="#闭形式与恰当形式" class="headerlink" title="闭形式与恰当形式"></a>闭形式与恰当形式</h2><p>引用wiki上<strong>闭形式与恰当形式</strong><br>在数学，特别是向量分析与微分拓扑中，一个<strong>闭形式</strong>$\alpha$是微分算子$d$的核，即$d\alpha=0$(注意这里是<strong>恒成立</strong>，如果是某些项出现除以0导致的不存在，那也不算)的微分形式；而<strong>恰当形式</strong>(恰当微分形式)$\alpha$是微分算子$d$的像，即存在某个微分形式$\beta$使得$\alpha=d\beta$，$\beta$称为关于$\alpha$的一个“本原”。<br>有如下两个<strong>结论</strong>：</p>
<ul>
<li>恰当形式<strong>一定是</strong>闭形式</li>
<li>闭形式<strong>不一定</strong>是恰当形式<blockquote>
<p>展开来说，依据<strong>庞加莱引理</strong>，如果整体的流形$\omega$是单联通的(可以连续的缩为一个点)则闭形式为恰当形式<br>但如果整体的流形$\omega$不是单连通的，那么闭形式就<strong>不一定</strong>是了(而且甚至要用stokes定理<strong>反证</strong>它不是，就是证明如果存在和stokes计算结果不一致)，当然，我们也无需考虑这一种情况了(需要利用deRham定理，还需要计算流形的Betti数)，相关内容 陈维恒《微分流形初步》P195</p>
</blockquote>
</li>
</ul>
<p>如此，$d\omega=0$不能说明它是恰当形式，只有上述情况已被证明闭形式是恰当形式，这些情况也不覆盖所有的可能，因而还得具体问题具体分析<br>对于这些已经被证明的情况之外的情况，$d\omega=0$仍然得<strong>找到一个在规定区域上均有定义</strong>的”原微分形式”才能说明一切</p>
<p>即使是deRham定理也只是叙述了光滑紧致流形上的情况。不过根据庞加莱引理，在任意球状邻域内闭微分式都是恰当的，那么证明一般来说都可以解，只不过解出来的是否都是覆盖到整体，就不一定了</p>
<p>证明不成立，可以用闭合$(p+1)$维曲面的环路积分为$0$，这个stokes推论去反证</p>
<p>总之判断一个闭形式是否是恰当形式非常困难，DeRham定理也只是判断是否闭形式就是恰当形式，而在上述命题时也不能确定一个闭形式是否就是恰当形式</p>
<p>可以利用子流形上的积分是把微分形式限制在一个子流形上的区域，再在区域的微分流形上利用子流形相对于原流形的制约方程，可以对子流形的微分形式进行更换，再匹配到更大的微分流形上，通过联系stokes，实现更大范围的运算。这里用到了流形之间的光滑映射诱导的形式场的映射用来转化，更专业一点的术语叫拉回</p>
<h2 id="边界的小问题"><a href="#边界的小问题" class="headerlink" title="边界的小问题"></a>边界的小问题</h2><p>Stokes公式在需要微分形式有<strong>紧致支撑集</strong>，这就相当于在紧致流形上进行计算。</p>
<p>我们思考一个流形是哪个流形的边界时，<strong>应该去凑谁的边界是它，或者是它的一部分，而不是看它围成的区域</strong>，因为我们的这个计算的流形，不能超过整个流形</p>
<p>如果说人为规定流形为$\{(x,y)|x^2+y^2\le 2\}-\{0,0\}$，上面定义了微分形式，要求一个$\{(x,y)|x^2+y^2= 1\}$的积分，如果微分形式在上面<strong>没有紧支撑</strong>(整个流形的闭包还是整个流形，因为拓扑空间$X$即是开集也是闭集)，stokes不能使用，有紧支撑的话，能使用(计算方法同下一段)。因而stokes还是有相当的限制在其中的，不是全部都能计算的</p>
<p>stokes没有规定流形一定要有边界，但是一定要有<strong>紧致支撑集</strong>，当然要是纯纯的开集，还有紧致支撑集的话，使用stokes肯定是0(开的部分是不算边界的)</p>
<script type="math/tex; mode=display">\int_{(0,1)}\omega=\int_{\partial (0,1)\omega}=0</script><p>这很好理解，因为有紧致支撑集说明函数导数在0，1处为0了，根据微积分基本定理肯定为0<br>同理半开半闭区间，就是只能算一边，另一边为0的情况</p>
<p>但是显然正常来说，嵌入在$\mathbb{R}^n$中的stokes定理的推论<strong>无需关注</strong>这点，因为一般来说函数覆盖整个$\mathbb{R}^n$或者其中很大的区域，题目也从不对其设置限制</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先复盘一下流形上的积分定义，要求微分形式必须拥有紧致支撑集，所以流形上的积分其实是不考虑在$\mathbb{R}^1$上的广义积分的，那一种情况是根据微积分基本定理的延拓，显然我们这里不需要考虑这种问题。<br>仔细阅读一下stokes公式，可以看到其相当重要的限制有如下的两条</p>
<ul>
<li>$\partial \omega$与$\omega$均需要是在整个流形上的<strong>光滑</strong>张量场，这是来自于微分形式的定义</li>
<li>在上一条成立后，$\partial \omega$与$\omega$必须在整个流形上有一个<strong>紧致支撑集</strong></li>
</ul>
<p>注意这里没有要求流形的紧致性与连通性，因为微分形式有<strong>紧致支撑集</strong>可以规避这个问题，积分必然有意义<br>我们可以根据这两条去观察是否正确的使用stokes，并以此可以去<strong>凑</strong>出一个带着微分形式的流形可以达到我们的目的，格林公式，高斯公式，斯托克斯公式都是在$\mathbb{R}^n$帮你找出了一种<strong>凑</strong>好的格式罢了</p>
<h4 id="如果要把微分形式阶数降下来"><a href="#如果要把微分形式阶数降下来" class="headerlink" title="如果要把微分形式阶数降下来"></a>如果要把微分形式阶数降下来</h4><ul>
<li>首先$d\omega$必须恒为0，不然绝对不存在</li>
<li>降下来需要求解一个PDE，但PDE解完之后结果必须满足张量场是定义在<strong>整个被积分的流形</strong>上的光滑张量场 <strong>(而不是边界，这点需要看公式)</strong></li>
<li>有可能因为闭形式不是恰当形式而导致解不出，这时候要想证伪就可以使用stokes推论闭合超曲面积分为0反证证伪</li>
<li>下一步即得到stokes公式</li>
</ul>
<h4 id="如果要把微分形式阶数升上去"><a href="#如果要把微分形式阶数升上去" class="headerlink" title="如果要把微分形式阶数升上去"></a>如果要把微分形式阶数升上去</h4><ul>
<li>选定以自己这个流形$\partial \Omega$作为边界或者边界的一部分的“母”流形，抑或是再通过和其它区域相加补全后寻找(因为要升一阶微分形式)</li>
<li>由于$\omega$是光滑张量场，那么$d\omega$也是在原边界的流形上的光滑的张量场(这点由外微分算子的定义来保证)，不需要考虑光滑的问题</li>
<li>根据<strong>外微分算子的局部性</strong>与<strong>子流形上的积分定义</strong>，需要选择一个合理的微分形式，使得这个选择的微分形式$\beta$满足$f^{\ast}\beta=f^{\ast}\omega$(既是使用子流形在“母”流形上的约束方程与之联立，得到相关的微分形式组，以达到换微分形式，使得方便运算的结果)</li>
<li>(关于这个子流形上的微分形式，必须要微分形式和约束方程同时出现，并且<strong>消去才算</strong>作真正子流形上的微分形式，最次也得留着后面跟个括号，约束方程就是用来消去子流形和“母”流形之间的维度差数的，所以，不同的微分形式加以相同的约束方程，可能不一样的微分形式能计算出相同的结果，自然就可以得到一个原微分形式的集合，即求解$i^\ast\omega = i^\ast\alpha$，好比求解限制函数在应该定义域内的相等)，并且使得这个微分形式也要满足最基本的在$\Omega$上的<strong>光滑</strong>(stokes里暗含一个<strong>包含映射</strong>，来自于子流形用“母”流形的微分形式积分的定义)</li>
<li>进一步，要考虑$\beta$是否在<strong>选定的母流形内</strong>存在<strong>紧致支撑集</strong>，像格林公式，高斯公式，斯托克斯公式都已经帮你选好了函数处处有定义的闭集了，就不需要考虑这个问题了</li>
<li>下一步即得到stokes公式</li>
</ul>
<p>总之最主要是判断stokes定理是否使用正确<br>以上这俩一个低一阶微分形式难取，一个“母”流形难取，倒是对称了，这也许就是数学的<strong>对称美感</strong>吧</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>从LFS构建中习得的交叉编译</title>
    <url>/posts/c858dee6.html</url>
    <content><![CDATA[<h1 id="从LFS构建中习得的交叉编译"><a href="#从LFS构建中习得的交叉编译" class="headerlink" title="从LFS构建中习得的交叉编译"></a>从LFS构建中习得的交叉编译</h1><p>在2024年寒假的过程中，我构建了LFS(<strong>L</strong>inux <strong>F</strong>rom <strong>S</strong>cratch)，其中有介绍了最基本的GNU/Linux环境的编译构建，这些的第一步即是gcc的交叉编译链的搭建，其对于开发者的重要性毋庸置疑</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>该blog只适用于基于autoconf的构建系统，autoconf是GNU构建系统的一部分，与Automake、Libtool等工具一起被广泛用于自动化软件的构建和配置。</p>
<h2 id="简单介绍交叉编译"><a href="#简单介绍交叉编译" class="headerlink" title="简单介绍交叉编译"></a>简单介绍交叉编译</h2><p>和我们平时将本机的源代码通过编译器生成跑在本机上的可执行文件的编译器不同，交叉编译就是在一个平台上生成另一个平台上的可执行代码。例如在x86_64的windows平台利用源代码编译源代码生成arm的linux平台下的可执行文件，这种行为称之为交叉编译，而实现这种编译过程的特殊编译器成为交叉编译器(Cross Complier)，与之相对我们之前常用的即是本地编译器</p>
<h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><p>对于交叉编译器有一些常用的术语</p>
<ul>
<li><strong>build</strong>: 指构建程序时使用的机器。</li>
<li><strong>host</strong>: 指将来会运行被构建的程序的机器。</li>
<li><strong>target</strong>: 编译器为这台机器产生代码。</li>
</ul>
<p>对于”在x86_64的windows平台利用源代码编译源代码生成arm的linux平台下的可执行文件”这个例子来说，<strong>build</strong>为x86_64的windows,<strong>host</strong>为arm的linux,<strong>target</strong>为arm的linux。具体来说，我们需要这个最终可执行文件的源代码，以及一个交叉编译器，这个交叉编译器是运行在x86_64的，OS为windows机子上的一个可执行程序，它的作用是将这份源代码编译为在arm的linux运行的可执行程序</p>
<p>而本地编译器就是build，host和target三个都是相同的，是你本机这个平台的一个特例</p>
<h3 id="三元组"><a href="#三元组" class="headerlink" title="三元组"></a>三元组</h3><p>我们上面用了一种比较口语化的说法，就是我们将这类平台称为如x86_64的windows，其实平台专业的可以用<strong>三元组</strong>去描述(基于autoconf的构建系统),形如CPU-供应商-内核-操作系统，由于供应商字段<strong>通常无关紧要</strong>，autoconf允许省略它(事实上根据我的使用相当程度上是随意取名的)。<br>例如x86_64-w64-mingw32-gcc即指target为x86_64的windows的编译器</p>
<h3 id="上面术语与编译器的关系"><a href="#上面术语与编译器的关系" class="headerlink" title="上面术语与编译器的关系"></a>上面术语与编译器的关系</h3><p>搜索gcc官网，进入其中的<a href="https://gcc.gnu.org/install/">Installation部分</a>，选择Configuration，会看到这一步构建有相当多的参数，其中有一个部分<code>Host, Build and Target specification</code>具体阐释了上方所指的三个术语。没错，在gcc自身被编译之时你就可以选择这三个编译参数，就能得到相对应的编译器，而gcc几乎对现代所有的平台都进行了适配</p>
<blockquote>
<p><strong>NOTE</strong>: 这里不对GNU构建系统进行进一步的阐释，只是声明可以从gcc的源代码构建出其支持的交叉编译的平台</p>
</blockquote>
<p>当然gcc只是交叉编译工具链的其中一个组成部分，其他的工具也有这样的参数，例如binutils(提供了汇编器和链接器等)</p>
<p>注意这里这三个参数实际上的行为，./configure脚本会根据<code>--build</code>，<code>--host</code>这两个参数去决定使用什么编译器，具体来说，当<code>--build</code>和<code>--host</code>相同时，为本地编译模式，使用本地编译器编译，而当<code>--build</code>和<code>--host</code>不同时，则进入交叉编译模式，此时将调用<code>--host</code>所指向的那个编译器</p>
<p><code>--target</code>只在gcc这种特定的源码的configure里有实际意义，它即规定编译之后的gcc的平台是什么</p>
<p>也就是说对于普通软件，这几个参数决定了编译出的结果是跑在哪上的，而对于gcc这类，不仅决定了跑在什么平台，还决定了用它编译的结果跑在哪上，总结下来只有这俩属性</p>
<h2 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h2><p>先来看看下面这张表格(来源于lfs中的工具链技术说明)</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>阶段</th>
<th>Build</th>
<th>Host</th>
<th>Target</th>
<th>操作描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>A</td>
<td>A</td>
<td>B</td>
<td>在平台A上，使用ccA构建交叉编译器cc1</td>
</tr>
<tr>
<td>2</td>
<td>A</td>
<td>B</td>
<td>B</td>
<td>在平台A上，使用cc1构建编译器ccB</td>
</tr>
<tr>
<td>3</td>
<td>B</td>
<td>B</td>
<td>B</td>
<td>在平台B上，使用ccB重新构建并测试其本身</td>
</tr>
</tbody>
</table>
</div>
<p>我们来看这个过程，首先这里的A，B均指一个<strong>三元组所描述的一个平台</strong><br>首先阐释一下这个表所描述的过程，我们假设平台B是一个没有编译器的平台，而A是一个有本地编译器ccA，我们的目的是让这个平台B具有编译代码的能力，也就是让它获得本地编译器ccB</p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>看看我们做了什么，首先我们在第一步，通过使用ccA编译交叉工具链(包括gcc，binutils)的源码，通过设定上文提到的gcc构建时的参数，要求其生成参数build为A，host为A，target为B的交叉编译工具，我们将其称之为cc1，推导下来它被A上本地编译器编译，跑在A上，为B生成代码</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>那么我们在第二步再次利用cc1编译交叉工具链，规定configure参数build为A，host为B，target为B，就将调用这时候我们得到了ccB，推导下来它被A上(给B生成代码的)交叉编译器(即cc1)编译，跑在B上，为B生成代码，这就是B上的本地编译器</p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>在第三步再次利用ccB编译gcc，规定configure参数build为B，host为B，target为B，就将调用这时候我们得到了ccB，推导下来它被B上本地编译器(即ccB)编译，跑在B上，为B生成代码，这就是最终验证的B上的本地编译器</p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>现在，关于交叉编译，还有更多要处理的问题：C语言并不仅仅是一个编译器；它还规定了一个标准库。在本书中，我们使用GNU C运行库，即glibc(除此之外，还有名为 “musl” 的另一种C运行库实现)。它必须为lfs目标机器使用交叉编译器cc1编译。但是，编译器本身使用一个库，实现汇编指令集并不支持的一些复杂指令。这个内部库称为libgcc，它必须链接到 glibc 库才能实现完整功能。另外，C++标准库(libstdc++)也必须链接到glibc。为了解决这个“先有鸡还是先有蛋”的问题，只能先构建一个降级的cc1，它的libgcc缺失线程和异常等功能，再用这个降级的编译器构建glibc(这不会导致glibc缺失功能)，再构建libstdc++。但是这种方法构建的libstdc++会缺失一些依赖于libgcc的功能。</p>
<p>可以看到这是一种类似于自举(bootstrap)的过程，这些功能的实现也是如上面调整交叉编译工具链的configure参数实现的</p>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="LFS"><a href="#LFS" class="headerlink" title="LFS"></a>LFS</h3><p>关于这一部分这里略过，<a href="https://lfs.xry111.site/zh_CN/12.1-systemd/index.html">lfs的手册</a>中相关的命令都详细描述了其中的过程，而且lfs的构建的三元组理论上来说几乎是相同相容的(因为就是在本机已有的系统上新建一个全新的系统)，我当时使用的宿主系统是Debian，最后我实践得到了一个真正的最小操作系统</p>
<p><img src="/images/从LFS构建中习得的交叉编译_图1.png" width="100%" height="100%"></p>
<h3 id="Linux-gt-Windows-x86-64"><a href="#Linux-gt-Windows-x86-64" class="headerlink" title="Linux -&gt; Windows (x86_64)"></a>Linux -&gt; Windows (x86_64)</h3><p>由于windows下从源码编译交叉工具链必然遭遇极其麻烦的库，链接等问题，我们略过编译构建的部分，直接使用已有的二进制gcc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># archlinux:</span></span><br><span class="line">$ sudo pacman -S mingw-w64-toolchain </span><br><span class="line">$ x86_64-w64-mingw32-gcc -o hello.exe hello.c</span><br></pre></td></tr></table></figure>
<p>成功获得hello.exe，传到windows中，正常运行！</p>
<p>对于Raspberry Pi这样的也是一致的，我们使用如下的命令，可以得到运行在树莓派上的程序(需要非常注意依赖的版本问题，如glibc，相对来说更加推荐在容器中进行编译)<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># archlinux:</span></span><br><span class="line">$ paru arm-none-linux-gnu-gcc </span><br><span class="line">$ arm-none-linux-gnu-gcc -o hello hello.c</span><br></pre></td></tr></table></figure></p>
<h3 id="Linux-x86-64-gt-Stm32"><a href="#Linux-x86-64-gt-Stm32" class="headerlink" title="Linux(x86_64) -&gt; Stm32"></a>Linux(x86_64) -&gt; Stm32</h3><p>针对这个部分我们略微多提一点，相对来说这个比较特殊，在我周围的嵌入式开发者使用两种工具，一是使用keil/stm32cubeIDE这类闭源的集成开发环境；二是使用arm-none-eabi-gcc。而作为一个开源爱好者，我们更希望使用gcc这样的开源编译器。而且最好了解arm-none-eabi-gcc这个工具的构建过程(当然你也可以像上面那样直接包管理下载交叉编译器)</p>
<p>一开始考虑这个问题的时候，我遇到了不小的障碍，原因是arm-none-eabi-gcc可以找到的官方资料是来源于arm官网而非来自于gcc官网，而写过嵌入式开发的朋友们都知道stm32的makefile里编译时有极其丰富编译参数，虽然不需要链接到标准库，不过链接到其他的库反而使得这个问题变得更加复杂</p>
<p>通过互联网搜索与询问学长们，我在一开始尝试去arm官网寻找答案<br><a href="https://developer.arm.com/downloads/-/gnu-rm">https://developer.arm.com/downloads/-/gnu-rm</a></p>
<p>我发现了网上给出最多次数的这个页面是被废弃的页面，而链接到的新页面确实给出了一些source code，但似乎由于其使用了特殊的构建工具(ABE)，且教程的陈旧，导致了我无法进一步从源码构建</p>
<p>最终我在下面这个问题中找到了构建arm-none-eabi-gcc的解决方案，关于完整的探索过程我们按下不表，详情留到下一篇文档中继续讨论</p>
<p><a href="https://stackoverflow.com/questions/72440601/arm-none-eabi-toolchain-compile-from-source">https://stackoverflow.com/questions/72440601/arm-none-eabi-toolchain-compile-from-source</a></p>
<p>在StackOverflow的这个问题的最后一条回答中Peter Frost给出了<a href="https://gist.github.com/badcf00d/2f6054441375d9c94896aaa8e878ab4f">脚本</a>与使用说明</p>
<blockquote>
<p><strong>NOTE</strong>：需要按照回答中的方法更改<code>nano.specs</code></p>
</blockquote>
<p>紧接着就可以使用编译得到编译器编译stm32项目了，利用openocd烧录进入stm32，完美运行</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>使用说明之qblog批处理</title>
    <url>/posts/64b84f95.html</url>
    <content><![CDATA[<h1 id="使用说明之qblog批处理"><a href="#使用说明之qblog批处理" class="headerlink" title="使用说明之qblog批处理"></a>使用说明之qblog批处理</h1><p>在整个博客构建中，我使用了批处理以方便在保留文件目录的情况下上传文件，这篇文档在仓库里是以<code>README.md</code>显示的，在这里再发一遍，写成一篇blog</p>
<span id="more"></span>
<blockquote>
<p>注意：该批处理文件已处于<strong>DEPRECATED</strong>状态，新的python脚本已在使用</p>
</blockquote>
<h2 id="放置并修改批处理文件"><a href="#放置并修改批处理文件" class="headerlink" title="放置并修改批处理文件"></a>放置并修改批处理文件</h2><p>将<code>qblog.bat</code>置于note文件夹下<br>请根据实际你note根目录与博客的文件(注意是要source文件夹的位置)<strong>绝对地址</strong>修改两个bat的变量设置<br>note文件夹中不会读取README.md，除此以外均会与blog位置判断是否修改，并覆盖，如果删除note文件夹下内容，对应的blog内也会删除，防止直接误操作blog导致崩坏(笑)<br>注意note文件夹下的images文件夹名字<strong>必须是images</strong>，该文件夹将直接与hexo中的images文件夹对应</p>
<h2 id="批处理命令使用方法"><a href="#批处理命令使用方法" class="headerlink" title="批处理命令使用方法"></a>批处理命令使用方法</h2><p>qblog使用方法如下</p>
<ol>
<li><code>qblog -n &lt;相对路径&gt;</code><br> 在相对路径下生成example.md新markdown文件，并在example.md中写好样例头<br> 注意这里的相对路径开头不包含<code>.\</code><br> 相对路径样例<code>Mathematic\Calculus_on_manifolds</code><br> 在vscode里可以通过对资源管理器中的文件夹右键，选择“复制相对路径”获得 </li>
<li><code>qblog -s</code><br> 快速将文件搬运，生成博客，并检查，并打开本地服务器</li>
<li><code>qblog -d</code><br> 快速将文件搬运，生成博客，并检查，并推送到github服务器</li>
<li><code>qblog -sd</code><br> 单独推送当前已经移动的博客到github服务器</li>
<li><code>qblog -ss</code><br> 单独推送当前已经移动的博客并打开本地服务器</li>
<li><code>qblog -c</code><br> 将当前文件夹git commit，附带信息为上传时间</li>
<li><code>qblog -p</code><br> 将当前文件夹git push</li>
<li><code>qblog -r</code><br> 更新当前文件夹里的内容和博客文件夹同步，只同步同名文件，<strong>如果存在文件未被同步将会报waring</strong>，主要用于递归调用检查，<strong>不推荐使用者直接使用该参数</strong></li>
<li><code>qblog -m</code><br> 只进行移动生成博客与检查，不进行打开服务器等操作，即<code>qblog -s</code>或<code>qblog -d</code>去掉<code>hexo s</code>或者<code>hexo d</code>这一步操作</li>
</ol>
<h2 id="样例头"><a href="#样例头" class="headerlink" title="样例头"></a>样例头</h2><p>这里是md文件需要加入的样例头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: NoteName</span><br><span class="line">mathjax: false</span><br><span class="line">categories:</span><br><span class="line">- First-level catalog</span><br><span class="line">- Second-level catalog</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>顺带一提，<code>.gitignore</code>中存放了未提交的本地加密博客文件夹名字，对于这个文件夹，其中新建文件需要在原来的文件夹下创建，并且手动搬运到这个未提交的文件夹中</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Another</category>
      </categories>
  </entry>
  <entry>
    <title>仿3b1b朱丽娅集</title>
    <url>/posts/17b8fba5.html</url>
    <content><![CDATA[<h1 id="仿-3b1b-朱丽娅集"><a href="#仿-3b1b-朱丽娅集" class="headerlink" title="仿 3b1b 朱丽娅集"></a>仿 3b1b 朱丽娅集</h1><p>很久很久以前，我欣赏了 3b1b 关于分型的视频，当时我在高中，也尝试使用 matlab 绘制过许许多多的分形图样，今天我成功复刻出了其在网页上显示的效果</p>
<span id="more"></span>
<h2 id="有一些话"><a href="#有一些话" class="headerlink" title="有一些话"></a>有一些话</h2><p>下面那个效果其实是复刻了 3b1b “How a Mandelbrot set arises from Newton’s work” 这期视频中提到的一些概念</p>
<p>关于视频，你可以在 bilibili 找到它: <a href="https://www.bilibili.com/video/BV1nh411x78S/">https://www.bilibili.com/video/BV1nh411x78S/</a></p>
<p>在 3b1b 官网上有与下面这个效果所复刻的实现 <a href="https://www.3blue1brown.com/lessons/holomorphic-dynamics#title">https://www.3blue1brown.com/lessons/holomorphic-dynamics#title</a></p>
<p>我个人对 3b1b 非常崇拜，可视化效果做的很好，但是当我实际上手 manim 之后我觉得，这个工具并不是非常适合制作复杂视频的视频工作者使用 </p>
<p>在很久很久以前，久到我还没有听说过 GPU 与渲染管线时，我曾用过各种工具绘制过 mandelbort 集，但是效率相当感人。渲染 18s mandelbort 集的放大视频当时在 python 上使用 CPU 渲染，花了我 10h。现在我才发现，调用 webgl 就能相当快速的绘制出这样的效果</p>
<p>我还在许久之前，这个博客上做过一些其他的 <a href="https://blog.feipiao.xyz/posts/ebf347fe.html">https://blog.feipiao.xyz/posts/ebf347fe.html</a></p>
<p>也是感谢 @xjzsq (github)，如果不是他只是在我提了一嘴 3b1b，就帮我去稍稍逆向了一下这个网页的 js，我也许至今都不知道我也有复刻这玩意的能力了(笑)</p>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><style>
  /* 最外层容器 */
  .scale-wrapper {
    position: relative;
    margin-top: 20px;
    width: 100%;
    display: flex;
    flex-direction: row;
    justify-content: center;
    background: black;
    color: white;
    font-family: sans-serif;
    overflow-x: hidden;
  }

  .fullscreen-btn {
    position: absolute;
    top: 0;
    right: 0;
    width: 2vw;
    height: 2vw;
    padding: 0;
    background: rgba(0,0,0,0.7);
    color: white;
    border: 1px solid #666;
    border-radius: 0 0 0 4px;
    cursor: pointer;
    font-size: 1.5vw;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
  }

  .fullscreen-btn:hover {
    background: rgba(255,255,255,0.2);
  }

  .panel {
    position: relative;
    width: 100%;
    height: 0;
    padding-bottom: 100%;
  }

  .panel canvas {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
  }

  .middle {
    width: 10%;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .scale-wrapper:fullscreen {
    margin-top: 0;
    padding-top: 60px;
  }

  .panel-container {
    display: flex;
    flex-direction: column;
    width: 48%;
    align-items: center;
    justify-content: center;
  }

  .panel-label {
    color: white;
    font-size: 1.2vw;
    text-align: center;
    margin-bottom: 5px;
  }

  .mid-text {
    color: white;
    text-align: center;
    font-size: 1vw;
    user-select: none;
    line-height: 1.3;
  }

  .mid-text span {
    font-size: 1.2vw;
  }
</style>

<!-- 会被 JS 动态缩放 -->
<div id="scaleWrapper" class="scale-wrapper">
  <button id="fullscreenBtn" class="fullscreen-btn">⛶</button>

  <!-- 左侧 Mandelbrot -->
  <div class="panel-container">
    <div class="panel-label">c <-> Pixel<br>z0 = 0</div>
    <div class="panel">
      <canvas id="mandelGL"   width="600" height="600"></canvas>
      <canvas id="mandelAxis" width="600" height="600"></canvas>
      <canvas id="pickerCanvas" width="600" height="600"></canvas>
    </div>
  </div>

  <!-- 中间栏 -->
  <div class="middle">
    <div class="mid-text" id="midText">
      Iterate<br>
      <span>z² + c</span>
    </div>
  </div>

  <!-- 右侧 Julia -->
  <div class="panel-container">
    <div class="panel-label">c = <span id="cValue">0.43 + -0.27i</span><br>z0 <-> Pixel</div>
    <div class="panel">
      <canvas id="juliaGL"   width="600" height="600"></canvas>
      <canvas id="juliaAxis" width="600" height="600"></canvas>
    </div>
  </div>
</div>

<script>


/* ------------------------------------------
   WebGL 公共函数
--------------------------------------------- */
function createShader(gl, type, src){
  let s = gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}
function createProgram(gl, vs, fs){
  let p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS))
    console.error(gl.getProgramInfoLog(p));
  return p;
}

/* ------------------------------------------
   顶点着色器（全屏）
---------------------------------------------*/
const VS = `
attribute vec2 aPosition;
varying vec2 vPos;
void main() {
  vPos = aPosition;
  gl_Position = vec4(aPosition,0.0,1.0);
}
`;

// Matplotlib inferno(256) -> #RRGGBB
const INFERNO_256 = [
  '#000004', '#010005', '#010106', '#010108', '#02010a', '#02020c', '#02020e', '#030210', '#040312', '#040314', '#050417', '#060419', '#07051b', '#08051d', '#09061f', '#0a0722',
  '#0b0724', '#0c0826', '#0d0829', '#0e092b', '#10092d', '#110a30', '#120a32', '#140b34', '#150b37', '#160b39', '#180c3c', '#190c3e', '#1b0c41', '#1c0c43', '#1e0c45', '#1f0c48',
  '#210c4a', '#230c4c', '#240c4f', '#260c51', '#280b53', '#290b55', '#2b0b57', '#2d0b59', '#2f0a5b', '#310a5c', '#320a5e', '#340a5f', '#360961', '#380962', '#390963', '#3b0964',
  '#3d0965', '#3e0966', '#400a67', '#420a68', '#440a68', '#450a69', '#470b6a', '#490b6a', '#4a0c6b', '#4c0c6b', '#4d0d6c', '#4f0d6c', '#510e6c', '#520e6d', '#540f6d', '#550f6d',
  '#57106e', '#59106e', '#5a116e', '#5c126e', '#5d126e', '#5f136e', '#61136e', '#62146e', '#64156e', '#65156e', '#67166e', '#69166e', '#6a176e', '#6c186e', '#6d186e', '#6f196e',
  '#71196e', '#721a6e', '#741a6e', '#751b6e', '#771c6d', '#781c6d', '#7a1d6d', '#7c1d6d', '#7d1e6d', '#7f1e6c', '#801f6c', '#82206c', '#84206b', '#85216b', '#87216b', '#88226a',
  '#8a226a', '#8c2369', '#8d2369', '#8f2469', '#902568', '#922568', '#932667', '#952667', '#972766', '#982766', '#9a2865', '#9b2964', '#9d2964', '#9f2a63', '#a02a63', '#a22b62',
  '#a32c61', '#a52c60', '#a62d60', '#a82e5f', '#a92e5e', '#ab2f5e', '#ad305d', '#ae305c', '#b0315b', '#b1325a', '#b3325a', '#b43359', '#b63458', '#b73557', '#b93556', '#ba3655',
  '#bc3754', '#bd3853', '#bf3952', '#c03a51', '#c13a50', '#c33b4f', '#c43c4e', '#c63d4d', '#c73e4c', '#c83f4b', '#ca404a', '#cb4149', '#cc4248', '#ce4347', '#cf4446', '#d04545',
  '#d24644', '#d34743', '#d44842', '#d54a41', '#d74b3f', '#d84c3e', '#d94d3d', '#da4e3c', '#db503b', '#dd513a', '#de5238', '#df5337', '#e05536', '#e15635', '#e25734', '#e35933',
  '#e45a31', '#e55c30', '#e65d2f', '#e75e2e', '#e8602d', '#e9612b', '#ea632a', '#eb6429', '#eb6628', '#ec6726', '#ed6925', '#ee6a24', '#ef6c23', '#ef6e21', '#f06f20', '#f1711f',
  '#f1731d', '#f2741c', '#f3761b', '#f37819', '#f47918', '#f57b17', '#f57d15', '#f67e14', '#f68013', '#f78212', '#f78410', '#f8850f', '#f8870e', '#f8890c', '#f98b0b', '#f98c0a',
  '#f98e09', '#fa9008', '#fa9207', '#fa9407', '#fb9606', '#fb9706', '#fb9906', '#fb9b06', '#fb9d07', '#fc9f07', '#fca108', '#fca309', '#fca50a', '#fca60c', '#fca80d', '#fcaa0f',
  '#fcac11', '#fcae12', '#fcb014', '#fcb216', '#fcb418', '#fbb61a', '#fbb81d', '#fbba1f', '#fbbc21', '#fbbe23', '#fac026', '#fac228', '#fac42a', '#fac62d', '#f9c72f', '#f9c932',
  '#f9cb35', '#f8cd37', '#f8cf3a', '#f7d13d', '#f7d340', '#f6d543', '#f6d746', '#f5d949', '#f5db4c', '#f4dd4f', '#f4df53', '#f4e156', '#f3e35a', '#f3e55d', '#f2e661', '#f2e865',
  '#f2ea69', '#f1ec6d', '#f1ed71', '#f1ef75', '#f1f179', '#f2f27d', '#f2f482', '#f3f586', '#f3f68a', '#f4f88e', '#f5f992', '#f6fa96', '#f8fb9a', '#f9fc9d', '#fafda1', '#fcffa4'
];

// Function to convert hex to RGB
function hexToRgb(hex) {
  const r = parseInt(hex.slice(1, 3), 16) / 255;
  const g = parseInt(hex.slice(3, 5), 16) / 255;
  const b = parseInt(hex.slice(5, 7), 16) / 255;
  return [r, g, b];
}

// Create palette texture data
const paletteData = new Uint8Array(256 * 3);
for (let i = 0; i < 256; i++) {
  const [r, g, b] = hexToRgb(INFERNO_256[i]);
  paletteData[i * 3] = Math.floor(r * 255);
  paletteData[i * 3 + 1] = Math.floor(g * 255);
  paletteData[i * 3 + 2] = Math.floor(b * 255);
}

/* ------------------------------------------
   公共调色板 (纹理查找)
---------------------------------------------*/
const PALETTE = `
uniform sampler2D uPalette;
float round(float x) { return floor(x + 0.5); }
vec3 palette(float t){
  t = clamp(t, 0.0, 1.0);
  t = t * t;
  float index = t * 255.0;
  float frac = fract(index);
  int i = int(floor(index));
  vec3 color1 = texture2D(uPalette, vec2((float(i) + 0.5) / 256.0, 0.5)).rgb;
  vec3 color2 = texture2D(uPalette, vec2((float(i + 1) + 0.5) / 256.0, 0.5)).rgb;
  return mix(color1, color2, frac);
}
vec3 getAxisColor(vec3 color, float x0, float y0, float stepX, float stepY, float threshold){
  float dx = abs(x0 - round(x0 / stepX) * stepX);
  float dy = abs(y0 - round(y0 / stepY) * stepY);
  if (dx < threshold || dy < threshold) {
    float brightness = (color.r + color.g + color.b) / 3.0;
    vec3 axisColor = brightness > 0.5 ? vec3(0,0,0) : vec3(1,1,1);
    return mix(color, axisColor, 0.08); // 半透明叠加
  }
  return color;
}
`;

/* ------------------------------------------
   Mandelbrot Shader
---------------------------------------------*/
const FS_MAN = `
precision mediump float;
varying vec2 vPos;

const int MAX_ITER = 300;
const float ESCAPE = 4.0;

${PALETTE}

void main(){
  float x0 = mix(-1.3,0.7,(vPos.x+1.0)/2.0);
  float y0 = mix(-1.0,1.0,(vPos.y+1.0)/2.0);

  float x=0.0, y=0.0;
  int iter=MAX_ITER;
  float r2;

  for(int i=0;i<MAX_ITER;i++){
    float nx = x*x - y*y + x0;
    float ny = 2.0*x*y + y0;
    x=nx; y=ny;
    r2 = x*x+y*y;
    if(r2>ESCAPE){ iter=i; break; }
  }

  if(iter==MAX_ITER){ 
    gl_FragColor=vec4(getAxisColor(vec3(0.9882,1.0,0.6431), x0, y0, 0.25, 0.25, 0.002), 1);
    return;
  }

  float s = float(iter);

  float t = s / float(MAX_ITER);
  t = pow(t,0.4);

  vec3 color = palette(t);
  gl_FragColor = vec4(getAxisColor(color, x0, y0, 0.25, 0.25, 0.002),1);
}
`;

/* ------------------------------------------
   Julia Shader
---------------------------------------------*/
const FS_JUL = `
precision mediump float;
varying vec2 vPos;
uniform float cRe;
uniform float cIm;
const int MAX_ITER = 300;
const float ESCAPE = 4.0;
${PALETTE}
void main(){
  float x0 = mix(-2.0,2.0,(vPos.x+1.0)/2.0);
  float y0 = mix(-2.0,2.0,(vPos.y+1.0)/2.0);
  float x = x0;
  float y = y0;
  int iter=MAX_ITER;
  float r2;
  for(int i=0;i<MAX_ITER;i++){
    float nx = x*x - y*y + cRe;
    float ny = 2.0*x*y + cIm;
    x=nx; y=ny;
    r2 = x*x+y*y;
    if(r2>ESCAPE){ iter=i; break; }
  }
  vec3 setColor = vec3(0.9882,1.0,0.6431);
  if(iter==MAX_ITER){ 
    gl_FragColor = vec4(getAxisColor(setColor, x0, y0, 0.5, 0.5, 0.006), 1);
    return;
  }
  float t = pow(float(iter)/float(MAX_ITER), 0.4);
  vec3 color = palette(t);
  gl_FragColor = vec4(getAxisColor(color, x0, y0, 0.5, 0.5, 0.006),1);
}
`;

/* ------------------------------------------
   WebGL 初始化（Mandelbrot & Julia）
---------------------------------------------*/
function initGL(canvas, fragShader){
  const gl = canvas.getContext("webgl");
  const vs = createShader(gl, gl.VERTEX_SHADER, VS);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fragShader);
  const p = createProgram(gl, vs, fs);
  gl.useProgram(p);

  const quad = new Float32Array([
    -1,-1, 1,-1, -1,1,
    -1,1, 1,-1, 1,1
  ]);
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);

  const loc = gl.getAttribLocation(p,"aPosition");
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);

  // Create palette texture
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, 256, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, paletteData);

  // Set texture uniform
  const texLoc = gl.getUniformLocation(p, "uPalette");
  gl.uniform1i(texLoc, 0);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);

  return { gl, program:p };
}

const mandel = initGL(mandelGL, FS_MAN);
const julia  = initGL(juliaGL, FS_JUL);

let currentC = {re: 0.43, im: -0.27};

// 像素缓冲区
const mandelPixels = new Uint8Array(600 * 600 * 4);
const juliaPixels = new Uint8Array(600 * 600 * 4);

function drawMandel(){
  mandel.gl.viewport(0,0,600,600);
  mandel.gl.drawArrays(mandel.gl.TRIANGLES,0,6);
  mandel.gl.readPixels(0, 0, 600, 600, mandel.gl.RGBA, mandel.gl.UNSIGNED_BYTE, mandelPixels);
}
function drawJulia(cRe,cIm){
  const gl=julia.gl;
  gl.useProgram(julia.program);
  gl.uniform1f(gl.getUniformLocation(julia.program,"cRe"),cRe);
  gl.uniform1f(gl.getUniformLocation(julia.program,"cIm"),cIm);
  gl.viewport(0,0,600,600);
  gl.drawArrays(gl.TRIANGLES,0,6);
  gl.readPixels(0, 0, 600, 600, gl.RGBA, gl.UNSIGNED_BYTE, juliaPixels);
}

drawMandel();
drawJulia(currentC.re, currentC.im);
drawAxes(mandelAxis, mandelPixels, -1.3,0.7,-1,1,0.25);
drawAxes(juliaAxis, juliaPixels, -2.0,2.0,-2.0,2.0,0.5);

/* ------------------------------------------
   获取像素亮度
---------------------------------------------*/
function getBrightness(pixels, x, y) {
  const idx = (Math.floor(y) * 600 + Math.floor(x)) * 4;
  const r = pixels[idx], g = pixels[idx+1], b = pixels[idx+2];
  return (r + g + b) / 3;
}

/* ------------------------------------------
   坐标轴文本（自适应颜色）
---------------------------------------------*/
function drawAxes(canvas, pixels, reMin,reMax,imMin,imMax,step){
  const ctx = canvas.getContext("2d");
  const W=600, H=600;
  function toXY(re,im){
    return {
      x:(re-reMin)/(reMax-reMin)*W,
      y:(imMax-im)/(imMax-imMin)*H
    };
  }
  ctx.clearRect(0,0,W,H);
  ctx.font = "14px sans-serif";

  const origin = toXY(0,0);

  // 垂直文本
  for(let r=-2;r<=2;r+=step){
    if(r>=reMin && r<=reMax && Math.abs(r) > 1e-6){
      let p=toXY(r,0);
      // 文本颜色基于其位置
      const textBrightness = getBrightness(pixels, p.x, origin.y+4);
      ctx.fillStyle = textBrightness > 128 ? "black" : "white";
      ctx.textAlign="center"; ctx.textBaseline="top";
      ctx.fillText(r.toString(), p.x, origin.y+4);
    }
  }

  // 水平文本
  for(let i=-2;i<=2;i+=step){
    if(i>=imMin && i<=imMax && Math.abs(i) > 1e-6){
      let p=toXY(0,i);
      // 文本颜色基于其位置
      const textBrightness = getBrightness(pixels, origin.x+4, p.y);
      ctx.fillStyle = textBrightness > 128 ? "black" : "white";
      ctx.textAlign="left"; ctx.textBaseline="middle";
      ctx.fillText(i+"i", origin.x+4, p.y);
    }
  }

  // 原点标记
  if(0 >= reMin && 0 <= reMax && 0 >= imMin && 0 <= imMax){
    const textBrightness = getBrightness(pixels, origin.x+4, origin.y+4);
    ctx.fillStyle = textBrightness > 128 ? "black" : "white";
    ctx.textAlign="left"; ctx.textBaseline="top";
    ctx.fillText("O", origin.x+4, origin.y+4);
  }
}

/* 轴已在shader中绘制，无需2D绘制 */

// 初始黄点位置 (0,0)
let currentX = 390;
let currentY = 300;
updateYellowPoint();

function updateYellowPoint() {
  const ctx = pickerCanvas.getContext("2d");
  ctx.clearRect(0,0,600,600);
  ctx.beginPath();
  ctx.arc(currentX, currentY, 8, 0, 6.28);
  ctx.fillStyle="yellow";
  ctx.fill();
  ctx.lineWidth=3;
  ctx.strokeStyle="black";
  ctx.stroke();

  // 计算复平面坐标
  const re = currentX/600*(0.7+1.3)-1.3;
  const im = (1-currentY/600)*2 - 1;

  // 更新 currentC
  currentC.re = re;
  currentC.im = im;

  // 更新显示
  document.getElementById("cValue").textContent = `${re.toFixed(2)} + ${im.toFixed(2)}i`;

  // 更新 Julia
  drawJulia(re, im);
  drawAxes(juliaAxis, juliaPixels, -2.0,2.0,-2.0,2.0,0.5);
}

/* ------------------------------------------
   左侧拖动选择 c
---------------------------------------------*/
let isDragging = false;

pickerCanvas.addEventListener("mousedown", e=>{
  const rect = pickerCanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width * 600;
  const y = (e.clientY - rect.top) / rect.height * 600;
  const dist = Math.sqrt((x - currentX) ** 2 + (y - currentY) ** 2);
  if (dist <= 15) { // 黄点半径8，阈值15
    isDragging = true;
  }
});

pickerCanvas.addEventListener("mousemove", e=>{
  if (isDragging) {
    updatePosition(e);
  }
});

pickerCanvas.addEventListener("mouseup", e=>{
  isDragging = false;
});

// 手机端触摸支持
pickerCanvas.addEventListener("touchstart", e=>{
  const rect = pickerCanvas.getBoundingClientRect();
  const touch = e.touches[0];
  const x = (touch.clientX - rect.left) / rect.width * 600;
  const y = (touch.clientY - rect.top) / rect.height * 600;
  const dist = Math.sqrt((x - currentX) ** 2 + (y - currentY) ** 2);
  if (dist <= 15) { // 黄点半径8，阈值15
    isDragging = true;
  }
});

pickerCanvas.addEventListener("touchmove", e=>{
  if (isDragging) {
    e.preventDefault();
    updatePosition(e.touches[0]);
  }
});

pickerCanvas.addEventListener("touchend", e=>{
  isDragging = false;
});

function updatePosition(e) {
  const canvas = e.target;
  const rect = canvas.getBoundingClientRect();
  currentX = Math.max(0, Math.min(600, (e.clientX - rect.left) / rect.width * 600));
  currentY = Math.max(0, Math.min(600, (e.clientY - rect.top) / rect.height * 600));
  updateYellowPoint();
}

/* ------------------------------------------
   全屏功能
---------------------------------------------*/
const fullscreenBtn = document.getElementById("fullscreenBtn");

fullscreenBtn.addEventListener("click", toggleFullscreen);

function toggleFullscreen() {
  const wrapper = document.getElementById("scaleWrapper");
  if (!document.fullscreenElement) {
    wrapper.requestFullscreen().catch(err => console.error(err));
  } else {
    document.exitFullscreen();
  }
}

document.addEventListener("fullscreenchange", () => {
  if (document.fullscreenElement) {
    screen.orientation.lock('landscape').catch(err => console.log('Orientation lock failed:', err));
    fullscreenBtn.textContent = "⛶";
  } else {
    fullscreenBtn.textContent = "⛶";
  }
});
</script>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Math_modeling</category>
      </categories>
  </entry>
  <entry>
    <title>关于51单片机移植u8g2失败经历</title>
    <url>/posts/572ad35a.html</url>
    <content><![CDATA[<h1 id="关于51单片机移植u8g2失败经历"><a href="#关于51单片机移植u8g2失败经历" class="headerlink" title="关于51单片机移植u8g2失败经历"></a>关于51单片机移植u8g2失败经历</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为没买stm32的单片机，但是用了SSD1306的OLED显示屏，想着既然移植u8g2库到stm32很简单，那自然也能移植到51单片机吧，看来还是我太年轻了</p>
<blockquote>
<p>前排提示，据我的研究，移植u8g2库到51并非一个理智的行为，至于为什么如此，下面我们就来讨论一下</p>
</blockquote>
<span id="more"></span>
<h2 id="关于C51的关键字"><a href="#关于C51的关键字" class="headerlink" title="关于C51的关键字"></a>关于C51的关键字</h2><p>C51有一些<strong>特殊的关键字</strong>，如<code>data</code>，<code>xdata</code>这类，其实是规定一个变量在数据中是如何存储的，我遇到的第一个问题就是，u8g2中有不少的代码都使用到了<code>data</code>作为变量名，这导致了许多代码的识别直接出现了问题，因为编译器只把它当成关键字</p>
<h2 id="关于数组超限的问题"><a href="#关于数组超限的问题" class="headerlink" title="关于数组超限的问题"></a>关于数组超限的问题</h2><p>这个方便解决，用C51新添加的关键字，在数组声明前写上<code>code</code>关键字，将其移至<code>flash</code>中即可</p>
<h2 id="关于8051对函数指针not-well-suit"><a href="#关于8051对函数指针not-well-suit" class="headerlink" title="关于8051对函数指针not well suit"></a>关于8051对函数指针not well suit</h2><blockquote>
<p>Basically, the 8051 is not “just another processor” that you can program as you would a PC, etc.The 8051 architecture has some very specific optimisations that make it very good for some things,and very poor for others - and <strong>function pointer</strong> is one of those things to which it is <strong>not well suited</strong>!</p>
</blockquote>
<p>这段话打破了我一整天的努力，因为u8g2库里重要的结构体有好几个成员变量都是函数指针，<strong>这意味着移植它到51单片机并非良构</strong>，虽然可以使用规定变量存储位置的方法解决一部分错误，终究还是不能解决所有的问题，也正是因为如此，这一个大坑直接扼杀了我移植的道路</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>终究还是只能是随便玩玩，还不如自己写呢<br>现在我已经成功的让<strong>字符</strong>在上面显示了，也算是曲折的完成了原先任务(的1/10)了吧<br>图中使用的开发板是普中的51开发板<br><img src="/images/关于51单片机移植u8g2失败经历_图1.jpg" width="70%" height="70%"></p>
]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>单片机</category>
      </categories>
  </entry>
  <entry>
    <title>关于三维流形上一般旋度公式</title>
    <url>/posts/3a0f394b.html</url>
    <content><![CDATA[<h1 id="关于三维流形上一般旋度公式"><a href="#关于三维流形上一般旋度公式" class="headerlink" title="关于三维流形上一般旋度公式"></a>关于三维流形上一般旋度公式</h1><p>本文主要介绍Hodge星算子($\star$)下旋度定义式和在公式整理一部分中得到的旋度公式之间的<strong>等价性</strong></p>
<span id="more"></span>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p><img src="/images/关于三维流形上一般旋度公式_图1.jpg" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>关于多元复合函数的困惑与思考</title>
    <url>/posts/15db3d47.html</url>
    <content><![CDATA[<h1 id="关于多元复合函数的困惑与思考"><a href="#关于多元复合函数的困惑与思考" class="headerlink" title="关于多元复合函数的困惑与思考"></a>关于多元复合函数的困惑与思考</h1><p>导读:偏导数是相对某个具体的坐标系才有意义的。</p>
<span id="more"></span>
<h2 id="问题的来源"><a href="#问题的来源" class="headerlink" title="问题的来源"></a>问题的来源</h2><p>我的学习过程比较复杂，因为对知识的渴求，想对问题做出解答，我学习了高数，线代，微分几何，微分流形；还接触了一些分析力学的部分。<br>我对分析学十分感兴趣，但我也经常产生许多的困惑。<br>关于多元复合函数的困惑主要是偏导数的问题，尤其是关于多元函数嵌套之后的偏导数的问题。</p>
<p>当时的我提出了与这个问题类似的问题<br>已知$ z＝f(u, x, y) $， $ u＝ψ(x, y) $，$ f $ 对$ x $的偏导需要$ u $和$ y $不变，那么我可以找出一个函数(比如令$ u＝x+y $)，$ u $、$ y $不变时，$ x $也不能变，那么这时$ f $对$ x $偏导还存在吗？意义又是什么？</p>
<p>而我在学习拉格朗日力学的时候又遇到了更多的问题，即广义坐标与广义速度之间的函数关系为什么在求导时候不需要考虑。</p>
<h2 id="对第一个问题的解释"><a href="#对第一个问题的解释" class="headerlink" title="对第一个问题的解释"></a>对第一个问题的解释</h2><p>如果使用坐标系$ (u,x,y) $的话，那么求出的3个偏导数$ (f_u,f_x,f_y) $是一个整体($ f_u $代表$ f $对$ u $的偏导，下同)，那么你就得把$ (u,x,y) $当成3个独立的变量，你就不能把$ u $看成$ \phi(x，y)$。如果要把u看成$ \psi(x,y) $, 那么实际上求得就是$ z=f(\psi(x,y),x,y) $这个复合函数在坐标系$(x,y)$下面的偏导数。这两件事情是有区别的，<strong>实际上偏导数必须要先选取函数所对应的坐标(选取所有待求偏导的变量)以后才有意义</strong>。</p>
<p>而这里要提出一点是，由于<strong>一阶微分的形式不变性</strong>的存在，使得全微分并不存在这个问题，毕竟全微分是一层一层下来的，如果到达了可以求值的层数就熔断了(hahaha)</p>
<h2 id="第二个问题是个乌龙"><a href="#第二个问题是个乌龙" class="headerlink" title="第二个问题是个乌龙"></a>第二个问题是个乌龙</h2><p>第二个问题关键在于，其实本身对拉格朗日量求那个偏导，拉格朗日量所用的那个映射，已经明确规定了它的参数是什么，而偏导也是对外函数求的，其实根本不会有时间$ t $牵扯进来的可能。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>偏导数之前是必须要确定所求函数参考的坐标系。<br>从自由度考虑，如果恒等式对两边求偏导，不能认为所有的变量都是独立变量，其实在两边求偏导前需要确定独立变量，才可以进行求偏导，不进行这一步操作会误以为所有变量独立，与原恒等式会发生矛盾<br>从一元函数的复合里有一种方式来记复合后的函数，即$ f\circ g $，对于多元函数这样的记法肯定不对，但是本质上求偏导还是对函数进行的，对于隐函数求导，在心里我们要明确左右两边求偏导时候，左边函数的性质:</p>
<ul>
<li>它是个复合函数</li>
<li>它的参数列表已经变掉了</li>
<li>它的函数名没有显式的给出</li>
</ul>
<p>至于偏导数还有没有可能会有更多的歧义之类的事情，要等我的物理学的更多，在下次对两边求偏导这件事再度发生时候，再考虑这个问题吧</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>关于思考第一类曲面积分时的发现</title>
    <url>/posts/951a7cd2.html</url>
    <content><![CDATA[<h1 id="关于思考第一类曲面积分时的发现"><a href="#关于思考第一类曲面积分时的发现" class="headerlink" title="关于思考第一类曲面积分时的发现"></a>关于思考第一类曲面积分时的发现</h1><p>声明:本文是对<strong>知乎答主@李治林</strong>的回答的个人总结，原链接如下，侵权删<br><a href="https://www.zhihu.com/question/48421749/answer/134203246">https://www.zhihu.com/question/48421749/answer/134203246</a><br><span id="more"></span></p>
<h2 id="从线元到面元"><a href="#从线元到面元" class="headerlink" title="从线元到面元"></a>从线元到面元</h2><p>首先我们知道在弧微分里的线元是长成这样的，我们在当时微分流形公式里也有写到</p>
<script type="math/tex; mode=display">ds^2=g_{ij}dx^i dx^j</script><p>其实它可以是由下面这个式子经过坐标变换得到</p>
<script type="math/tex; mode=display">ds^2=(dx^i)^2</script><p>这个式子其实就是二维空间里经典的勾股定理，那么要想把它推广到三维，从第一类曲线积分推广到第一类曲面积分，那么我们需要找到所谓三维的勾股定理</p>
<h2 id="关于开根号后的方向"><a href="#关于开根号后的方向" class="headerlink" title="关于开根号后的方向"></a>关于开根号后的方向</h2><p>我们默认规定了平面正向就是和直角坐标系一致，或者说是相同的<strong>轮换序</strong>，本质上是定向相同，故而对于一个正向的平面这边只要保证开平方后结果是轮换序就好了，就能保证满足微分形式和积分同向<br>顺带一提，第一类积分无方向性就是这个开根号来的，$ds$与$dS$显然是无方向的，那么它就会自适应当前是在哪个流形上计算，这种自适应其实就是开根号取正还是取负，<strong>取正理由是几何意义</strong>，如果和原式定向相符，所谓的积分函数为1，结果就是正的，因而就<strong>规定</strong>取正也就是流形定向相符的顺序了(我是这么理解的，但并不一定正确，但从结果上来说无可反驳)，开根号就正好从逻辑上消除了方向，总之开完根号方向需要与子流形的定向一致，从整体来说，即使积分区域反向，也可以把它掰回正向，用轮换序去套</p>
<h2 id="三维的勾股定理"><a href="#三维的勾股定理" class="headerlink" title="三维的勾股定理"></a>三维的勾股定理</h2><p>这个只给出，但我不做证明，其实还是挺简单的，当然在链接里，李老师还是给出了证明</p>
<script type="math/tex; mode=display">S_4^2=S_1^2+S_2^2+S_3^2</script><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><p>由上面这个<strong>三维勾股定理</strong>就可以导出这个</p>
<script type="math/tex; mode=display">ds^2=(dydz)^2+(dzdx)^2+(dxdy)^2</script><p>首先注意，两个对偶矢量之间的符号是楔积，但平方代表的是张量积<br>这点和弧微分是对应的，如果说这个平方代表的是楔积的话，$ds$直接就是0了，那显然不对<br>提出因子$dxdy$就可以得到</p>
<script type="math/tex; mode=display">ds^2=(dxdy)^2((\frac{dydz}{dxdy})^2+(\frac{dzdx}{dxdy})^2+1)\\=(dxdy)^2(z_x^2+z_y^2+1)</script><p>开根号就能得到直角坐标系下把面元转换为微分形式的式子</p>
<h2 id="关于评论区说的规范化"><a href="#关于评论区说的规范化" class="headerlink" title="关于评论区说的规范化"></a>关于评论区说的规范化</h2><p>看到评论区里有人问这里的$\frac{dydz}{dxdy}=z_x$规范化是什么样的，我仔细思考了一下给出了我的答案<br>其实这个式子是不正确的，完整的写法是这样的</p>
<script type="math/tex; mode=display">(\frac{dydz}{dxdy})^2=(z_x)^2</script><p>首先这里$dydz$中间是楔积，只需把$dz$展开</p>
<script type="math/tex; mode=display">\frac{dydz}{dxdy} = \frac{dy(\frac{z}{x}dx+\frac{z}{y}dy)}{dxdy}\\=\frac{\frac{\partial z}{\partial x}dy\wedge dx+\frac{\partial z}{\partial y}dy\wedge dy}{dx\wedge dy}\\=\frac{\frac{\partial z}{\partial x}dy\wedge dx}{dx\wedge dy}\\=\frac{-\frac{\partial z}{\partial x}dx\wedge dy}{dx\wedge dy}\\=-\frac{\partial z}{\partial x}</script><p>发现了么，这里居然还有一个负号在呢，所以那个平方是不能少的，存在那个张量积，这个负号就无所谓了</p>
<h2 id="一般坐标系下面元"><a href="#一般坐标系下面元" class="headerlink" title="一般坐标系下面元"></a>一般坐标系下面元</h2><p>上面推导了直角坐标系下面元的来源，那么我们就可以直接使用<strong>源头的式子</strong>来求解一般坐标系下，只需要把坐标系变换的式子往这里一代</p>
<script type="math/tex; mode=display">ds^2=(dydz)^2+(dzdx)^2+(dxdy)^2</script><p>就可以得到柱坐标，球坐标乃至任意坐标系下的式子啦<br>如下，展示一个柱坐标下的</p>
<script type="math/tex; mode=display">ds^2=r^2(drd\theta)^2+(d\theta dz)^2+r^2(dzdr)^2</script><p>按理来说，应该可以写成<strong>度规的形式</strong>，但是本人有些懒惰，在写这篇blog时未完成这个工作</p>
<h2 id="参数方程法"><a href="#参数方程法" class="headerlink" title="参数方程法"></a>参数方程法</h2><script type="math/tex; mode=display">ds^2=(dydz)^2+(dzdx)^2+(dxdy)^2</script><p>将这个式子代入参数方程的转化式，将直接可以将其简单化，可以省去转化坐标系的方法，因为参数方程包含了完整的曲面信息<br>注意参数方程和坐标系转化是<strong>不一样的</strong>方法，坐标系转化只代入了坐标系转化的方程，而参数方程则是一步到位</p>
<h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><p>求$I=\iint_{\Sigma}{\frac{d S}{x^{2}+y^{2}+Z^{2}}}$，其中$\Sigma$是介于平面$z=0$和$z=H$之间的曲面柱$x^2+y^2 = R^2$</p>
<h3 id="更换坐标系"><a href="#更换坐标系" class="headerlink" title="更换坐标系"></a>更换坐标系</h3><script type="math/tex; mode=display">ds^2=r^2(drd\theta)^2+(d\theta dz)^2+r^2(dzdr)^2</script><p>由该式子可得到面元，此时式子已经变化为了</p>
<script type="math/tex; mode=display">\left\{\begin{matrix} r=R\\  \theta = \theta\\z=z\end{matrix}\right.</script><p>这是一个子流形的浸入映射，将其代入原微分形式，可以得到</p>
<script type="math/tex; mode=display">ds^2=r^2(d\theta dz)^2</script><h3 id="参数方程法-1"><a href="#参数方程法-1" class="headerlink" title="参数方程法"></a>参数方程法</h3><script type="math/tex; mode=display">\left\{\begin{matrix} x=Rcos\theta\\y = Rsin\theta\\z=z\end{matrix}\right.</script><p>直接代入也可以得到</p>
<script type="math/tex; mode=display">ds^2=r^2(d\theta dz)^2</script><p>其实他俩是在同一个坐标系下的</p>
<h2 id="放到流形当中进行思考"><a href="#放到流形当中进行思考" class="headerlink" title="放到流形当中进行思考"></a>放到流形当中进行思考</h2><p>第二类积分即对子流形上的积分，需要把整个微分形式按照子流形的映射，即把其映射成子流形上的坐标卡，那么这种具体就体现为约束的方程，其中参数方程就属于这一类，不管上面使用了什么方法，其实都首先把第一类积分的元变为了微分形式，进而使用参数方程进行代换，转化为第二类积分，那么是否进行坐标系的转化对它进行简化并不重要，但求取定向是否相符是一个计算量较大的问题<br>已知定向，当然可以随意构造一种坐标系，在欧式空间当中最简单的就是在切平面方向构造一个定向相符的直角坐标系，正好，它和我们之前提到的那张判断stokes诱导定向完全一致，可以细细品味一下，接着再用雅可比矩阵的东西计算同向的定义，似乎也只有这种办法进行进行计算，别的什么去求和代换前坐标系的坐标的排列顺序都不靠谱<br>故而平时就使用直角坐标系中转，即可直观确定方向，即使是常见坐标系如球坐标系也得来算个定向相符的事情，整体的概念如下图，看上去好像坐标系被扭曲了，但由于函数也被扭曲了，整体的积分是不变的</p>
<blockquote>
<p>再次提醒，换坐标系或者代入并非高数书，也就是下一段我们提到的这个特殊的变换以外，其它要取定向是否相符的微分形式都是需要算的，不然只能取得绝对值的相等没有什么好办法，目前我还没见到需要进行坐标系变换或者代入参数方程是必须的，暂时保留这些方法</p>
</blockquote>
<p><img src="/images/关于思考第一类曲面积分时的发现_图1.jpg" width="70%" height="70%"></p>
<p>对于常见的二重积分，用$z(x,y)$代换$z$，其实是变化为了这样的一个流形上的曲纹坐标系(粉色线为曲纹坐标为<strong>常值</strong>的线)，如下图，其实在这种情况下，$x$，$y$早就不是原来那俩了，它已经是新的子流形上的坐标了，严格来说可以加个上撇来区分他们，在反向的平面内，注意类似球面这样的流形，它并不能被一个坐标卡覆盖，而我没上面这种特殊的坐标卡其实也只能覆盖上半球面，覆盖不了下半球面(理由是这种映射(x,y)显然对应流形上的两个点，显然只覆盖了上半)，所以下半和上半要分开考虑，而分开考虑后，下半就会因为和原坐标系定向不相符而导致产生一个负号，这就是为什么第二类曲面积分投影下侧投影时会产生负号的原因</p>
<blockquote>
<p>同广义积分之理，从直觉上去掉有限个相对于积分区域低维的间断区域不会影响整体的积分，该说法可以修正其无法完全覆盖的障碍，或某些低维区域覆盖有限遍的障碍(该理论<strong>存疑</strong>，但暂且能大致解释)</p>
</blockquote>
<p><img src="/images/关于思考第一类曲面积分时的发现_图2.png" width="70%" height="70%"></p>
<p>子流形其实除了等式<strong>还有不等式</strong>，这俩也就是约束方程，不等式包括自由变量的范围，而这种不等式的约束在映射为子流形前后<strong>也会发生变化</strong>，所以我们考虑第二类曲面积分，在把它变成子流形上的二重积分时，对于直角坐标系下的情况，如把第二类曲面积分，积分区域为圆心在坐标原点的上半球面，它包含两个约束，一个是$z=\sqrt{R^2-x^2-y^2}$，另一个是$x^2+y^2\le R^2$，我们<strong>不能忽略</strong>在变换时后面这一个不等式，不然无法得到正确的积分区域，在变换后不等式即变为积分区域</p>
<h2 id="向未来更高维的展望"><a href="#向未来更高维的展望" class="headerlink" title="向未来更高维的展望"></a>向未来更高维的展望</h2><p>我猜测更高维也首先得知晓高维下的<strong>勾股定理</strong>，再同理可得，想必也就只是计算<strong>麻烦亿点点</strong>罢了</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>初入Linux的一些感想</title>
    <url>/posts/13c32592.html</url>
    <content><![CDATA[<h1 id="初入Linux的一些感想"><a href="#初入Linux的一些感想" class="headerlink" title="初入Linux的一些感想"></a>初入Linux的一些感想</h1><p>这半年来没怎么更新东西，原因是这一个学期都在折腾Linux，想着在博客里交代一下自己最近干的事情，以及即将要在博客里写的一些东西</p>
<span id="more"></span>
<h2 id="使用Linux的契机"><a href="#使用Linux的契机" class="headerlink" title="使用Linux的契机"></a>使用Linux的契机</h2><p>想我一开始使用Linux直接就是使用的虚拟机，而不是使用WSL，作为以C/C++为主要语言的我来说，我发现有太多太多的东西环境硬性要求Linux平台了，逐渐我发现单纯的Windows完全是不可能满足我的需求的。一些比赛和项目促使我使用了Ubuntu</p>
<h2 id="尝试各种发行版"><a href="#尝试各种发行版" class="headerlink" title="尝试各种发行版"></a>尝试各种发行版</h2><p>我一开始借由做csapp的几个lab的契机，认识到了linux，并且一开始我使用的发行版也是Ubuntu，但是经过一段时间的使用，我发现Ubuntu是真的容易崩溃，而且让我不满的是，虽然是一个面向搜索引擎的系统，但是其实ubuntu的资料并不是那么的充足，基于lts的ubuntu能搜到的很多都是一些相当过时的资料，当它在搜索引擎里以一大堆和你所问的问题毫无关系的形态展现在你的面前的时候，你还兴高采烈的点进去查看，结果发现，要么版本不对应，要么怎么改镜像源apt install都没这个包，更何况互相抄来抄去的现状，简直太乱了有没有，对于当时需要“菜就多练”的我来说，其实反而就没有那么美好(当然对于现在的我来说，即使是ubuntu也不会像当初一样狼狈了(枯)，不管何时使用合适的搜索引擎，合适的网站查找信息都是相当重要的事情)</p>
<p>后来我使用了Debian，作为Ubuntu的祖宗，Debian确实让我省心了不少，Debian的稳定版本如同其名，不过这种稳定完全基于它经过长期验证的软件源，或者换句话来说，它的软件也太老了一点，完全不能满足我的日常使用好不好，现在看来我还是属于激进的，而Debian更加适合用来当server跑服务</p>
<p>后来我换到了ArchLinux，Arch的软件是我用过最丰富最便于获取的，pacman的包管理也是相当好用，除了有一次一不小心把它滚挂了，其他都是不错的体验</p>
<p>就在这篇博客写的这两天(2024.2.10)，我正在构建Linux From Scratch，从中我学会了交叉编译，个人感觉整个过程还是挺有意思的，首先是搭建一个交叉编译的环境，这个过程需要我们以一种自举的方式去获得在目标机器上完整的gcc功能。然后一个一个包从源码编译，搭建起最基本的系统应用。chroot(change root directory)进系统之后，接着完成基本应用的搭建，直到最后通过配置内核选项进行内核裁剪，手动配置Grub2，整体的过程都让我学到了不少</p>
<h2 id="经验的积累"><a href="#经验的积累" class="headerlink" title="经验的积累"></a>经验的积累</h2><p>就我个人而言，我至今为止使用linux的都在于我经验的积累，比如了解到各种各样的工具，arch wiki和周围的朋友们为我提供了许多的帮助。</p>
<p>我觉得首先你得了解linux底下那些系统级的基础软件，像gcc，binutils两个与我主要研究的c/c++相关的自不必说，还要熟悉vim，nano等相关的文本编辑器，还有例如archlinux要学会自己打快照。</p>
<p>没有社区环境等的帮助，了解这些相关的软件其实也是很缓慢的过程，作为从常年用Windows转到使用linux，本身就是跳出了舒适圈，要接受一定的考验</p>
<h2 id="长期使用linux作为开发环境后"><a href="#长期使用linux作为开发环境后" class="headerlink" title="长期使用linux作为开发环境后"></a>长期使用linux作为开发环境后</h2><p>在包管理，cmake等的帮助下，c/c++的开发确实变得容易很多，而且linux api也更加容易调用，能搜到的资料也会变多，这都是开源带给我的。正式学习两年c++，也使过不少其他语言，我现在看来，对于真正要做什么的场景，也许把复杂性完整的展现出来更加有利于我们真正的习得有用的东西，而不是一味的逃避，一味的封装</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>初见流形上的微积分</title>
    <url>/posts/1a81a4ab.html</url>
    <content><![CDATA[<h1 id="初见流形上的微积分"><a href="#初见流形上的微积分" class="headerlink" title="初见流形上的微积分"></a>初见流形上的微积分</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以本篇笔记记录时我大一的数理能力是无法去完全阅读流形相关的内容的，因此，我只能在此做一个<strong>科普性的导论</strong>。我们会从一个工科生的角度，从流形之前的知识到stokes公式的引出，从而拓展出一个完整的流形上的微积分的概念。<br><span id="more"></span><br>前排提示：文章内容<strong>完全不严谨</strong>，纯粹是出于个人的理解。想要系统学习，建议阅读<strong>Loring W. Tu</strong>的《An Introduction to Manifolds》一书，同时关于本篇文档的排版<strong>措辞仍需修饰</strong>，仍然是一个<strong>不完整</strong>版本</p>
<hr>
<h2 id="向量空间"><a href="#向量空间" class="headerlink" title="向量空间"></a>向量空间</h2><p>首先，向量空间本身的定义和一些性质是高代里的内容，在这里不进行详细的说明。</p>
<h3 id="向量空间的同构"><a href="#向量空间的同构" class="headerlink" title="向量空间的同构"></a>向量空间的同构</h3><p>向量空间的同构本应该也是属于向量空间里的内容，之所以要拿出来单独的讲一讲是因为，正是由于它所引导出来的概念让我困惑了许久。</p>
<p>如果有两个向量空间 $V$ 和 $W$ ，线性变换 $T(V)=W$ 使得 $V$ 中的每一个元素有且仅有一个在 $W$ 中的元素与之对应，则该线性变换称为从 $V$ 到 $W$ 上的一个同构。这两个向量空间只是名字不一样， $V$ 或者 $W$ 所进行的所有<strong>计算</strong>都可以完全的在另一个<strong>完全相同的进行</strong>。</p>
<p>那么这就意味着，这两个向量空间 $V$ 和 $W$ ，其实在<strong>结构上</strong>没有任何的差别，是<strong>等价</strong>的，在不引起歧义的情况下完全可以相互代换。</p>
<h3 id="对偶空间-dual-space"><a href="#对偶空间-dual-space" class="headerlink" title="对偶空间(dual space)"></a>对偶空间(dual space)</h3><p>设 $V$ 是域 $\mathbb{F}$ 上的线性空间，则可以验证所有从 $V$ 到 $\mathbb{F}$ 的线性映射(称为<strong>线性泛函</strong>)也<strong>构成一个线性空间</strong>。记作 $V^{*}$ (证明略)</p>
<p>可以证明 $(V^{*})^{*}$ 同构于 $V$ ，那么就可以利用 $V^{**}$ <strong>扩展</strong> $V$ 的定义，$V$ 同时也就成为了 $V^{*}$ 上的线性泛函。这样的对计算的扩展对其他本身的含义并不影响，却铸就了张量这样有效的计算工具。</p>
<p><strong><em>注意</em></strong>：我们应当非常小心的区分<strong>同构</strong>与<strong>等同</strong>之间的差别</p>
<hr>
<h2 id="欧氏空间"><a href="#欧氏空间" class="headerlink" title="欧氏空间"></a>欧氏空间</h2><p>为了把我们手头已经有的微积分拓展到普遍的流形上，必须得回来康康我们手头有的东西的性质。<br>要想开始微积分，我们需要定义导数，而在导数定义之前，我们其实要先考虑一个东西，叫做切向量。<br>其实导数或者说叫做微分定义完了基本上这篇导论也就结束了。</p>
<h3 id="切向量"><a href="#切向量" class="headerlink" title="切向量"></a>切向量</h3><p>我们手头的东西往往都依赖于欧氏空间的线性性质，抑或是我们曾经把一些流形嵌入到欧式空间进行研究，但往往不是所有情况都允许我们这样做的。切向量正是这样。<br>在欧式空间中，对于一个嵌入到 $\mathbin{R}^{n}$ 中的曲线，求导，其实就是求一个切向量嘛，那么它的定义其实很简单，用 $f(t):\mathbin{R}\to\mathbin{R^{n}}$ 代表一个曲线，其切向量为：</p>
<script type="math/tex; mode=display">
f'(t)=\lim_{\Delta t \to 0}\frac{f(t+\Delta t)-f(t)}{\Delta t}</script><p>但是这种几何直观下的切向量其实并不能自然的拓展到流形当中，因为这样的定义依赖于这样的曲线是嵌入在一个欧式空间当中的，而我们要拓展的对象并不能保证这一点，所以我们要用别的方法寻找到一个切向量。</p>
<p>我们灵机一动。发现切向量和方向导数具有美好的<strong>一一对应关系</strong>(这里显然和高数中的方向导数是不一样的，其实方向导数可以不一定非要是单位向量的方向导数)，因此我们不妨扩展切向量的定义，把切向量当成一种函数，它可以输入一个空间上定义的函数，输出一个实数，其实这种函数在欧氏空间里最好的例子就是方向导数。</p>
<p>而在流形上，自然也就不存在几何性质的切向量了，那我们扩展的定义就自然而然成为了它原本的定义。</p>
<script type="math/tex; mode=display">v:=\vec{v}(f),\vec{v}:\mathbin{C^{\infty}_{P}}\to\mathbin{R}</script><p>同时</p>
<ul>
<li>$\forall f$,$g\in\mathbin{C^{\infty}_{P}}$，有$v(f+g)=v(f)+v(g)$</li>
<li>$\forall f\in\mathbin{C^{\infty}_{P}}$，$\forall \lambda \in \mathbin{R}$,有$v(\lambda f)=\lambda \cdot v(f)$</li>
<li>$\forall f$,$g\in\mathbin{C^{\infty}_{P}}$，有$v(f\cdot g)=f(x)\cdot v(g)+g(x) \cdot v(f)$</li>
</ul>
<p>然后接下来就是证明这样所有的切向量组成的集合是一个向量空间了，在此证明略去，不过我要提一提这样的切向量其<strong>形式</strong>的证明<br>首先由这样的一个引理(带积分余项的Taylor定理)：<br>在$n$维欧式空间$\mathbin{E^n}$中选定直角坐标系，设$g\in\mathbin{C^{\infty}_{P}}$,且点P的坐标为$(x^1_0,\cdots,x^n_0)$,则$g$可以表示为：</p>
<script type="math/tex; mode=display">
g(x^1,\cdots,x^n)=g(x^1_0,\cdots,x^n_0)+\sum^{n}_{i=1}(x^i-x^i_0)h_i(x^1,\cdots,x^n)</script><p>其中$h_i\in\mathbin{C^{\infty}_{P}}$，并且</p>
<script type="math/tex; mode=display">
h_i(x^1_0,\cdots,x^n_0)=\frac{\partial g}{\partial x_i}(x^1_0,\cdots,x^n_0)</script><p>可以证明切向量作用在常数上得到的值是0<br>那么把切向量$v$作用在$f$上可以得到</p>
<script type="math/tex; mode=display">
v(f)=v(\sum^{m}_{i=1}(x^i-x^i_0)g_i)
\\=\sum^{m}_{i=1}v(x^i)g_i(x_0)
\\=\sum_{i=1}^{m}v(x^i)\frac{\partial }{\partial x^i}(f),
\\v=\sum^m_{i=1}v^i\frac{\partial}{\partial x^i}</script><p>如此，切向量的形式就可以确定下来了，而且它的基向量也可以确定下来了，那就是$\{\frac{\partial}{\partial x^1},\cdots,\frac{\partial}{\partial x^n}\}$<br>那有了切向量对应的切空间，自然就会去想它的对偶空间也就是称为余切空间是什么样子的<br>利用类似的方法我们可以确定余切空间的基向量是$\{dx_1,\cdots,dx_n\}$<br>余切向量的形式也就自然而然的定下来了($df$)<br>所以说$dx$其实是余切向量而非$\Delta x$</p>
<hr>
<h2 id="张量"><a href="#张量" class="headerlink" title="张量"></a>张量</h2><p>张量也是一种函数，并且是一个分级的函数，并且所有$(p,q)$型张量也同样形成向量空间。张量本身也是一个<strong>线性变换</strong></p>
<p>所谓$V$上的一个$(p,q)$型张量是指$\underbrace{V^*\times \cdots \times V^*}_{p个}\times \underbrace{V\times \cdots \times V}_{q个}$上的一个$p+q$重线性函数，其中$p$为反变阶数，$q$为协变阶数。全体$V$上的$(p,q)$型张量的集合记作$V^p_q$<br>张量相同的上下指标可以相消，这是建立在相互作用上的，写在左边就是作用者，写在右边就是被作用者。<strong>与张量缩并无关</strong></p>
<p>张量积的定义如下<br>一般的，设$V_1,\cdots,V_p$，$W_1,\cdots W_q$是$p+q$个向量空间，$\alpha \in \mathscr{L}(V_1,\cdots,V_p;\mathbf{R})$，$\beta \in \mathscr{L}(W_1,\cdots,W_q;\mathbf{R})$，则张量积$\alpha \otimes \beta$是$V_1\times \cdots \times V_p \times W_1\times \cdots \times W_q$上的$p+q$重线性函数，定义为</p>
<script type="math/tex; mode=display">
\alpha \otimes \beta(v_1,\cdots,v_p,w_1,\cdots,w_q)\\=\alpha(v_1,\cdots,v_p)\cdot\beta(w_1,\cdots,w_q)</script><p>其中$v_r\in V_r$，$1\le r \le p$，$w_s\in W_s$， $1\le s\le q$<br>张量积满足结合律与分配律，是一种把低阶张量转换为高阶张量的运算</p>
<p>$V$上的$k$重线性函数也被称为$V$上的$k$阶张量。可证$V$上的$k$重线性函数构成一个向量空间，符号记作$L_k(V)$</p>
<h3 id="楔积"><a href="#楔积" class="headerlink" title="楔积"></a>楔积</h3><p>要想定义楔积，得先知道别的一些概念。</p>
<p>$k$重线性函数$f:V^k\to \mathbb{R}$称为是<strong>对称的</strong>，如果对任何置换 $\sigma \in S_k$有 $f(v_{\sigma (1)},\cdots v_{\sigma (k)})=f(v_1,\cdots,v_k)$<br>$k$重线性函数$f:V^k\to \mathbb{R}$称为是<strong>交错的</strong>，如果对任何置换$\sigma \in S_k$有$f(v_{\sigma (1)},\cdots v_{\sigma (k)})=(sgn \sigma)f(v_1,\cdots,v_k)$</p>
<p>$sgn \sigma$为判断置换是奇是偶，在行列式定义中也有出现</p>
<p>将所有$k$重线性函数构成集合记作$A_k(V)$，可以证明$A_k(V)$是一个<strong>向量空间</strong>，而且是$L_k(V)$的子空间</p>
<p>现在，任给$V$上的$k$重线性函数$f$，可以按照以下方法构造一个<strong>对称的</strong>$k$重线性函数$Sf$:</p>
<script type="math/tex; mode=display">
(Sf)(v_1,\cdots,v_k)=\sum_{\sigma \in S_k}f(v_{\sigma (1)},\cdots v_{\sigma (k)})</script><p>或简写成$Sf=\sum_{\sigma \in S_k}\sigma f$<br>与之相同，任给$V$上的$k$重线性函数$f$，可以按照以下方法构造一个<strong>交错的</strong>$k$重线性函数$Af$:</p>
<script type="math/tex; mode=display">
(Af)(v_1,\cdots,v_k)=\sum_{\sigma \in S_k}(sgn \sigma)f(v_{\sigma (1)},\cdots v_{\sigma (k)})</script><p>或简写成$Af=\sum_{\sigma \in S_k}(sgn \sigma)\sigma f$</p>
<p>设$f$，$g$是两个交错线性函数,我们希望它们的”积”也是交错的,然而张量积却不能保证这一点.因而我们给出一种全新运算楔积来满足这一点。<br>对于任意$f\in A_k(V)$，$g\in A_l(V)$，定义楔积如下</p>
<script type="math/tex; mode=display">
\alpha\wedge\beta:= \frac{1}{k!l!}A(\alpha\otimes\beta)</script><p>楔积有如下的<strong>运算性质</strong><br>设$f\in A_k(V)$，$g\in A_l(V)$，$h\in A_m(V)$</p>
<ul>
<li>楔积$\wedge$关于$f$和$g$是双线性的</li>
<li>对于任意常数$c$，有$c\wedge f=cf$</li>
<li>反交换性：$f\wedge g=(-1)^{kl}g\wedge f$</li>
<li>结合性：$(f\wedge g)\wedge h=f\wedge (g\wedge h)$</li>
</ul>
<hr>
<h2 id="微分形式"><a href="#微分形式" class="headerlink" title="微分形式"></a>微分形式</h2><h3 id="定义微分形式"><a href="#定义微分形式" class="headerlink" title="定义微分形式"></a>定义微分形式</h3><p>这一段我并不是很能理解原因，但是其具有的数学美感确实打动了我，直接看定义吧<br>$\mathbb{R^n}$开集$U$上的<strong>微分$k$-形式</strong>(简称$k$-形式)是一个映射$\omega$，他将$U$里的每一个点p赋予一个切空间$T_p\mathbb{R^n}$上的交错$k$重线性函数($k$阶余向量)，即$\omega \in A_k(T_p\mathbb{R^n})$</p>
<p>一阶微分形式有形式不变性，这在多元函数微积分中有提及，即无论 $u$ ，$v$ 是自变量还是中间变量，函数 $z=f(u,v)$ 的全微分形式是一样的。</p>
<h3 id="外导数"><a href="#外导数" class="headerlink" title="外导数"></a>外导数</h3><p><strong>外导数算子</strong>，或叫<strong>外微分算子</strong>是一个映射，记作 $d$ ，它将一个 $k$ -形式映射成一个 $(k+1)$ -形式，即 $d:\Omega^k(U)\to \Omega^{k+1}(U)$</p>
<p>在定义 $\mathbb{R^n}$ 开集$U$上的任意$(k)$-形式，要定义 $0$ -形式的外导数，接着再定义$k\ge 1$形式的外导数</p>
<p><strong>( $0$ -形式的外导数)</strong><br>设 $f\in C^\infty_a$ ，则 $f$ 的<strong>外导数</strong>或叫<strong>外微分</strong>定义为它的微分 $df\in \Omega^1(U)$ ，写成分量形式即是，$df=\sum \frac{\partial f}{\partial x^i}dx^i$</p>
<p><strong>($k$-形式的外导数)</strong><br>设 $k\ge 1$ ，若 $\omega = \sum_I a_Idx^I\in \Omega^k(U)$ ，则 $\omega$ 的<strong>外导数</strong>或<strong>外微分</strong>定义为</p>
<script type="math/tex; mode=display">
d\omega = \sum_Ida_I\wedge dx^I =\sum_I(\sum_j\frac{\partial a_I}{\partial x_j}dx^j)\wedge dx^I \in \Omega^{k+1}(U)</script><p>所以常见的重积分中 $dxdy$ 中间的运算其实是楔积而不是乘积</p>
<p>外导数算子 $d$ 有如下计算性质</p>
<ul>
<li>作为线性算子的性质</li>
<li>$d(\omega\wedge\tau)=(d\omega)\wedge\tau+(-1)^{\omega 阶数}\omega\wedge d\tau$</li>
<li>$d^2=0$</li>
</ul>
<hr>
<h2 id="Stokes公式"><a href="#Stokes公式" class="headerlink" title="Stokes公式"></a>Stokes公式</h2><p>这一阶段要详细讲述可能需要较大篇幅，我们就从一个角度引入，初窥门径就行了，中间证明也不是现阶段的我能够看懂的</p>
<p>首先我们必须先定义积分是什么<br>既然我们最终想研究的是流形上的<strong>微积分</strong>，我们就一定会想到<strong>微积分基本定理</strong>，这对我们来说再熟悉不过了</p>
<script type="math/tex; mode=display">\int_{a}^{b}f(x)dx=F(a)-F(b)</script><p>我们看到，这样的一个定理是把 $[a,b]$ 上一段的积分变为计算边界条件的两个差，由计算一个集合<strong>内部</strong>转为计算它的<strong>边界条件</strong>，就是微积分基本定理所起到的作用</p>
<p>在流形上，函数可以用好几种表达形式(坐标卡都不同)，如果积分，是有歧义的，只有微分形式，可以进行积分的变元，在流形上积分是不会有歧义的</p>
<p>综合上面两点，可以证明出stokes公式<br>对于 $n$ 维微分流形 $M$ ，$\Omega\subset M$ ，$\partial\Omega$ 是一个 $n-1$ 维微分流形，为 $M$ 的边界，$\omega$ 为 $(n-1)$ -形式，$d\omega$ 为 $n$ -形式，可得</p>
<script type="math/tex; mode=display">\int_{\partial \Omega}\omega=\int_{\Omega}d\omega</script><p>可以很自然的看到，格林公式，斯托克斯公式(狭义)，高斯公式都是stokes公式在特定条件下的导出结论</p>
<hr>
<h2 id="partial-Omega-的方向"><a href="#partial-Omega-的方向" class="headerlink" title="$\partial \Omega$的方向"></a>$\partial \Omega$的方向</h2><p>当$p \in \partial M$时，我们可以选择一个局部坐标系$(x_1,\ldots,x_{n-1})$和坐标域$U$，使得$\partial M$在这个坐标系下可以表示为：</p>
<script type="math/tex; mode=display">x_1=0,x_2=0,\ldots,x_{n-1}=0</script><p>然后，我们定义向量场</p>
<script type="math/tex; mode=display">v(p)=\dfrac{\partial}{\partial x_1}\bigg|_p</script><p>在$p$处的值是$T_p \partial M$的正向基。重复对$\partial M$上每个点进行这样的选择，即可得到$\partial M$上的一个自然定向。</p>
<p>需要注意的是，$\partial M$的自然定向取决于$M$的定向以及在构造局部坐标系时的选择。在某些情况下，不同的选择可能会得到不同的自然定向。但是，如果我们要使用定向的$\partial M$来计算积分或者应用斯托克斯公式，我们需要选择一种确定的自然定向，并且在整个计算过程中都要保持这种定向的一致性。如果<strong>所有自然定向和M的定向相同</strong>，那么就是有向流形M边界自然诱导定向了</p>
<p>而定向相同就是<strong>两个坐标系的转换方程的雅可比行列式大于0</strong></p>
<p>对于$R^n$，可以把自然诱导定向拓展为内法向量</p>
<p>在欧式空间中直观的观察可以归结如下图<br><img src="/images/初见流形上的微积分_图1.jpg" width="100%" height="100%"><br>$\omega$的顶端那个面肯定是算作正的嘛，确实按照这样的算法也是正的了。<br>对于二重积分，利用green公式转化为的曲线积分也是逆时针的，和这张图中的$\partial\psi$计算一致，证明我们的思路正确<br>xyz要根据顺序从高到低消去，这是由原本的<strong>笛卡尔坐标系赋予</strong>的</p>
<p>至于第二类积分和第一类积分的差别，我发现，第一类积分往往都是正的，有物理意义的特例，在计算上往往会化归为第一类，而且由于它是物理意义的，所以默认$dxdy$，$\omega$它都是方向与坐标系一致</p>
<p>之后也就沿袭这种默认了，可以用计算验证，重积分也默认区域和坐标系同向</p>
<p>如果说不是欧式空间，那必然会<strong>知道</strong>流形<strong>预设</strong>的方向，而利用之前的微分公式，列出微分方程，可以做到积分的需求，stokes向上的过程不管积分的是标量场还是向量场都是需要解PDE的(可以替代积分哦)</p>
<p>至此在任意坐标系下积分都成为流形上的运算了，已经都能算了</p>
<hr>
<h2 id="流形上广义积分"><a href="#流形上广义积分" class="headerlink" title="流形上广义积分"></a>流形上广义积分</h2><p>其实对于一维的广义积分，其写法也不是直接运用的牛顿莱布尼茨公式(本来牛顿莱布尼茨也<strong>不支持开区间</strong>)，而是写成了极限与普通积分的形式，如下，所以其实流形上广义积分也不是通过stokes来延拓的，主要还是写成区间的极限形式，于是便可以使用stokes公式了，这里我们<strong>不写出</strong>广义积分的定义，因为我手头的书上居然都没有给出这个东西(笑)</p>
<script type="math/tex; mode=display">
\int_{0}^{+\infty}f(t)dt=\lim_{x \to +\infty} \int_{0}^{x}f(t)dt=\lim_{x \to +\infty} F(x)-F(0)</script><hr>
<h2 id="拓展到流形"><a href="#拓展到流形" class="headerlink" title="拓展到流形"></a>拓展到流形</h2><p>为什么我们讲了那么久都没有怎么讲到流形呢，因为我觉得微分流形本身不复杂，我个人没有在这个概念上卡很久，流形本身就是一个特殊的集合，找了一个一一到上的光滑映射使得和 $\mathbb{R^n}$ 构建关系，让流形上的问题<strong>回归</strong>常见的直角坐标系<br>我还是用一个小例子引出：<br>流形上的积分定义如下：<br>设 $(O,\psi)$ 是<strong>n维定向流形</strong> $M$ 上的<strong>右手坐标系</strong>(应当是和流形方向一致)，$w$ 是开子集 $G\subset O$ 上的 $C^\infty n$ 形式场，则 $w$ 在 $G$ 上的<strong>积分</strong>定义为</p>
<script type="math/tex; mode=display">\int_G w:=\int_{\psi(G)}w_{1\cdots n}(x^1,\cdots,x^n)dx^1\cdots dx^n</script><p>可以看到这样的定义是十分自然的过渡，几乎就是从流形一一对应的那个空间来研究流形本身了，这也是化归思想和抽象思想完美结合的体现吧</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>初识stm32</title>
    <url>/posts/fc4ef914.html</url>
    <content><![CDATA[<h1 id="初识stm32"><a href="#初识stm32" class="headerlink" title="初识stm32"></a>初识stm32</h1><p>其实本人是通信工程专业的学生，应该一早就开始学习单片机的，奈何我在大一的时候其实只接触过一点点的编程，所以走偏了，而且51单片机的c语言是真的用着很难受啊</p>
<span id="more"></span>
<h2 id="板子已到"><a href="#板子已到" class="headerlink" title="板子已到"></a>板子已到</h2><p>我买的实验板是意法半导体的<code>STM32F411RET6</code>，它太颜值太高了啊啊啊</p>
<h2 id="施工中"><a href="#施工中" class="headerlink" title="施工中"></a>施工中</h2>]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>单片机</category>
      </categories>
  </entry>
  <entry>
    <title>初识量子计算</title>
    <url>/posts/fe2da916.html</url>
    <content><![CDATA[<h1 id="初识量子计算"><a href="#初识量子计算" class="headerlink" title="初识量子计算"></a>初识量子计算</h1><p>考试周瞎学，写一份初见的文档，量子计算确实很有意思<br><span id="more"></span></p>
<h2 id="关于使用的Python库-Qiskit"><a href="#关于使用的Python库-Qiskit" class="headerlink" title="关于使用的Python库:Qiskit"></a>关于使用的Python库:Qiskit</h2><p>可以看一手<a href="https://qiskit.org/">官网的介绍</a>:</p>
<blockquote>
<p>Qiskit [kiss-kit] is an open-source SDK for working with quantum computers at the level of pulses, circuits, and application modules.</p>
</blockquote>
<p>我主要就使用Qiskit库进行量子计算的学习</p>
<h2 id="量子计算的基础知识"><a href="#量子计算的基础知识" class="headerlink" title="量子计算的基础知识"></a>量子计算的基础知识</h2><p>这一部分讲一些基础的东西</p>
<h3 id="量子比特"><a href="#量子比特" class="headerlink" title="量子比特"></a>量子比特</h3><p>量子比特属于叠加态，其可以表达成基础的几个状态的线性组合，而且线性组合的系数都是复数</p>
<p>原因是其可以组成向量空间，其实是复希尔伯特空间，这很trival</p>
<p>具体的表达如下</p>
<script type="math/tex; mode=display">
\langle\psi|=a\langle 1|+b \langle 0|、|\psi\rangle = a|1\rangle + b|0 \rangle</script><h3 id="左矢和右矢"><a href="#左矢和右矢" class="headerlink" title="左矢和右矢"></a>左矢和右矢</h3><p>右矢就是普通的向量<br>看起来左矢就是对偶向量</p>
<h3 id="点乘"><a href="#点乘" class="headerlink" title="点乘"></a>点乘</h3><p>如果$|\psi\rangle$是某个例子的初始状态，则$|\langle\phi|\psi\rangle|^2$代表在$|\phi\rangle$这个状态找到$|\psi\rangle$这个状态的概率</p>
<p>点乘具有<strong>正交性和归一性</strong>，即</p>
<script type="math/tex; mode=display">\langle i|j \rangle = \delta_{ij}</script><h3 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h3><p>张量分析当中的基本运算</p>
<script type="math/tex; mode=display">|\psi\rangle\otimes|\phi\rangle\equiv|\psi\rangle|\phi\rangle\equiv|\psi,\phi\rangle\equiv|\psi\phi\rangle</script><p>注意，张量积不满足交换律感觉这里的张量积主要用于将qubit合成为张量进矩阵格式的运算</p>
<p>运算满足如下方法</p>
<script type="math/tex; mode=display">
\langle\phi_1\phi_2|\psi_1\psi_2\rangle = \langle\phi_1|\psi_1\rangle_1\langle\phi_2|\psi_2\rangle_2</script><h3 id="外积"><a href="#外积" class="headerlink" title="外积"></a>外积</h3><p>外积是一种用于产生算符的运算，其定义为</p>
<script type="math/tex; mode=display">|\psi\rangle\langle\phi|=|\psi\rangle\otimes\langle\phi|</script><h3 id="纯态与混合态"><a href="#纯态与混合态" class="headerlink" title="纯态与混合态"></a>纯态与混合态</h3><p>纯态是指可以被一个简单向量表示的量子态<br>位于布洛赫球上的向量是纯态，因为他们可以被书写成</p>
<script type="math/tex; mode=display">
|\psi\rangle=\begin{bmatrix}\cos\frac{\theta}{2}\\ e^{i\phi}\sin\frac{\theta}{2}\end{bmatrix}</script><p>而混合态就是在布洛赫球内的向量</p>
<h3 id="密度矩阵"><a href="#密度矩阵" class="headerlink" title="密度矩阵"></a>密度矩阵</h3><p>给定一个纯态$|\psi\rangle$，其密度算符(矩阵)定义为</p>
<script type="math/tex; mode=display">
\rho=|\psi \rangle \langle \psi|</script><h2 id="量子逻辑门"><a href="#量子逻辑门" class="headerlink" title="量子逻辑门"></a>量子逻辑门</h2><p>对量子的逻辑运算可以被理解为<strong>张量乘法</strong>，即可以把量子逻辑门理解为一个矩阵运算，利用量子逻辑门计算一次的计算，由于叠加态的存在，可以同时处理很多情况，因此达到快于经典计算机的速度</p>
<p>量子电路要求总是可逆电路</p>
<p>量子逻辑门的物理实现中经常提到了一个结构，约瑟夫森结，这是组成量子逻辑门的一个重要元件</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> QuantumCircuit</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> qiskit <span class="keyword">import</span> Aer</span><br><span class="line"><span class="keyword">from</span> qiskit.visualization <span class="keyword">import</span> plot_state_city</span><br><span class="line"></span><br><span class="line">circ = QuantumCircuit(<span class="number">3</span>)</span><br><span class="line">circ.h(<span class="number">0</span>)</span><br><span class="line">circ.cx(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">circ.cx(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">circ.h(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">backend = Aer.get_backend(<span class="string">&quot;statevector_simulator&quot;</span>)</span><br><span class="line">job = backend.run(circ)</span><br><span class="line">result = job.result()</span><br><span class="line">outputstate = result.get_statevector(circ, decimals=<span class="number">3</span>)</span><br><span class="line">plot_state_city(outputstate)</span><br><span class="line"><span class="comment"># 注意，生成的是密度矩阵而不是直接告诉我值的虚实部</span></span><br><span class="line"><span class="comment"># 注意，|\psi| = a|1&gt;+b|0&gt;的系数a，b是复数而非实数</span></span><br><span class="line"><span class="comment"># 因为这个是在一个复希尔伯特空间上</span></span><br><span class="line"><span class="comment"># 右矢是向量，左矢是对偶向量</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p><strong>上述代码对应的量子电路图如下</strong><br><img src="/images/初识量子计算_图2.png" width="100%" height="100%"></p>
<p><strong>输出的结果图如下</strong><br><img src="/images/初识量子计算_图1.png" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Programming_Language</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>南京邮电大学交换技术与通信网实验自动执行脚本</title>
    <url>/posts/57f25e7f.html</url>
    <content><![CDATA[<h1 id="南京邮电大学交换技术与通信网实验自动执行脚本"><a href="#南京邮电大学交换技术与通信网实验自动执行脚本" class="headerlink" title="南京邮电大学交换技术与通信网实验自动执行脚本"></a>南京邮电大学交换技术与通信网实验自动执行脚本</h1><p>这个作业要一行一行输入 GNS3 的 Solar-PuTTy，挺麻烦的，于是就写了一个脚本用来一键执行，当然这个脚本并不能帮你解决你的作业，只是可以很方便执行指令，让你专注于具体内容罢了</p>
<blockquote>
<p>这个脚本只用于完成作业，如果要实际使用可以在此基础上使用 GNS3 提供的 api 接口来进行二次开发</p>
</blockquote>
<span id="more"></span>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="安装-Python"><a href="#安装-Python" class="headerlink" title="安装 Python"></a>安装 Python</h3><p>安装 Python 在此不做赘述，这个 Python 脚本也不需要 pip 任何的库<br>我使用的 Python 版本为 3.12，由于 <code>telnetlib</code> 库本身是一个 Deprecated 的库，python 版本应该低于 3.13</p>
<h3 id="写下指令"><a href="#写下指令" class="headerlink" title="写下指令"></a>写下指令</h3><p>在<strong>Python文件相同的目录下的</strong> <code>commands.txt</code> 内写下你需要的指令，允许使用 <code>//</code> 进行行注释，注意需要先切换到一个具体的路由器上，例子如下:<br><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// commands.txt</span><br><span class="line"></span><br><span class="line">// 切换至 R1</span><br><span class="line">switch_router localhost 5000 // 伪指令，切换到localhost:5000</span><br><span class="line">// 根据 server_settings localhost:5000 是指第1个路由器，即为 R1</span><br><span class="line">config t </span><br><span class="line">int s1/0 </span><br><span class="line">ip address 11.11.88.1 255.255.255.252</span><br><span class="line">no shutdown</span><br><span class="line">exit</span><br><span class="line">int loopback0 </span><br><span class="line">ip address 11.11.0.1 255.255.255.255</span><br><span class="line">end</span><br><span class="line">write</span><br><span class="line">show ip int b</span><br><span class="line"></span><br><span class="line">// 切换至 R2</span><br><span class="line">switch_router localhost 5001</span><br><span class="line">config t</span><br><span class="line">int s1/1</span><br><span class="line">ip address 11.11.88.2 255.255.255.252</span><br><span class="line">no shutdown</span><br><span class="line">exit</span><br><span class="line">int s1/0</span><br><span class="line">ip address 11.11.88.5 255.255.255.252</span><br><span class="line">no shutdown</span><br><span class="line">exit</span><br><span class="line">int loopback0</span><br><span class="line">ip address 11.11.0.2 255.255.255.255</span><br><span class="line">end</span><br><span class="line">write</span><br><span class="line">show ip int b</span><br></pre></td></tr></table></figure></p>
<p>注意添加了一个伪指令 <code>switch_router &lt;IP address&gt; &lt;Port&gt;</code>，这个指的是你在软件里拖的路由器标记的那个的地址，在 GNS3 的设置里是可以更改的<br>不建议修改 GNS3 安装时默认监听的 IP地址 与端口号<br>默认的 IP 地址是 localhost<br>路由器的端口号默认时 5000-10000，第1个路由器就是 5000，第2个是5001，如果你修改了，请自己更改上面这条伪指令里的值</p>
<h3 id="启动你的路由器"><a href="#启动你的路由器" class="headerlink" title="启动你的路由器"></a>启动你的路由器</h3><p><img src="/images/南京邮电大学交换技术与通信网实验自动执行脚本_图1.png" width="100%" height="100%"><br>一定要启动路由器，而且路由器一定要是 R1、R2…这样的命名(即默认命名)，否则脚本无法连接上，并且注意脚本运行时不要打开你 GNS3 里自带的终端，否则有可能卡住</p>
<blockquote>
<p>如果因此不慎卡住，请关闭脚本并关掉 GNS3 的所有路由器，可以解决问题</p>
</blockquote>
<h3 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure>
<p>运行脚本会<strong>逐行</strong>读取你 <code>commands.txt</code> 内的指令，遇到 <code>switch_router</code> 会切换到对应路由器环境下，遇到空行和注释会跳过，遇到具体指令就会发送给<strong>当前路由器</strong>进行执行，总之免去了一行一行输入的麻烦</p>
<p>运行大致能得到如下结果，输出的内容有回显<br><img src="/images/南京邮电大学交换技术与通信网实验自动执行脚本_图2.png" width="100%" height="100%"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> telnetlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">HOSTNAME = <span class="string">&quot;&quot;</span></span><br><span class="line">FILENAME = <span class="string">&#x27;commands.txt&#x27;</span></span><br><span class="line">FIRSTFLAG = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">telnet_login_and_wait_for_prompt</span>(<span class="params">host, port=<span class="number">23</span>, delay=<span class="number">0.5</span>, timeout=<span class="number">5</span></span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tn = telnetlib.Telnet(host, port, timeout)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[NOTE] Waiting for <span class="subst">&#123;delay&#125;</span> seconds to allow the device to initialize...&quot;</span>)</span><br><span class="line">        time.sleep(delay)</span><br><span class="line">        tn.write(<span class="string">b&quot;\r&quot;</span>)</span><br><span class="line">        output = tn.read_very_eager().decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">        tn.write(<span class="string">b&quot;\r&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> tn</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;[Error] question occurred while connecting: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_telnet_command</span>(<span class="params">tn, command, timeout=<span class="number">10</span></span>):</span><br><span class="line">    <span class="keyword">global</span> FIRSTFLAG</span><br><span class="line">    <span class="comment"># print(f&quot;[Debug] command: &#123;command&#125;&quot;)</span></span><br><span class="line">    tn.write(command.encode(<span class="string">&#x27;ascii&#x27;</span>) + <span class="string">b&quot;\r&quot;</span>)</span><br><span class="line"></span><br><span class="line">    prompt_patterns = [</span><br><span class="line">            <span class="string">fr&quot;<span class="subst">&#123;HOSTNAME&#125;</span>\(config-[\w-]+\)#&quot;</span>,  </span><br><span class="line">            <span class="string">fr&quot;<span class="subst">&#123;HOSTNAME&#125;</span>\(config\)#&quot;</span>,         </span><br><span class="line">            <span class="string">fr&quot;<span class="subst">&#123;HOSTNAME&#125;</span>#&quot;</span>,                   </span><br><span class="line">        ]</span><br><span class="line">    output_cache = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        </span><br><span class="line">        output = tn.read_some().decode(<span class="string">&#x27;ascii&#x27;</span>)</span><br><span class="line">        output_cache += output</span><br><span class="line">        <span class="built_in">print</span>(output, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        output_cache = output_cache.splitlines()[-<span class="number">1</span>] <span class="keyword">if</span> <span class="string">&quot;\n&quot;</span> <span class="keyword">in</span> output_cache <span class="keyword">else</span> output_cache</span><br><span class="line">        <span class="keyword">if</span> re.search(<span class="string">r&quot;--More--&quot;</span>, output_cache):</span><br><span class="line">            tn.write(<span class="string">b&quot;\r&quot;</span>)</span><br><span class="line">            output_cache = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> re.search(<span class="string">r&quot;#&quot;</span>, output):</span><br><span class="line">            <span class="keyword">if</span> FIRSTFLAG:</span><br><span class="line">                FIRSTFLAG = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># print(f&quot;[Debug] output_cache: &#123;output_cache&#125;&quot;)</span></span><br><span class="line">            <span class="keyword">for</span> pattern <span class="keyword">in</span> prompt_patterns:</span><br><span class="line">                <span class="keyword">if</span> re.search(pattern, output_cache):</span><br><span class="line">                    <span class="comment"># print(f&quot;[Debug] find patterns &#123;pattern&#125;&quot;)</span></span><br><span class="line">                    output_cache = <span class="string">&quot;&quot;</span></span><br><span class="line">                    <span class="keyword">return</span> tn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_commands_from_file</span>(<span class="params">filename</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        commands = [line.strip() <span class="keyword">for</span> line <span class="keyword">in</span> file.readlines() <span class="keyword">if</span> line.strip()]</span><br><span class="line">    <span class="keyword">return</span> commands</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_commands</span>(<span class="params">commands</span>):</span><br><span class="line">    <span class="keyword">global</span> HOSTNAME, FIRSTFLAG</span><br><span class="line">    tn = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">for</span> command <span class="keyword">in</span> commands:</span><br><span class="line">        command = command.split(<span class="string">&#x27;//&#x27;</span>)[<span class="number">0</span>].strip()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> command:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="comment"># 伪指令：切换路由器 switch_router</span></span><br><span class="line">        <span class="keyword">if</span> command.startswith(<span class="string">&#x27;switch_router&#x27;</span>):</span><br><span class="line">            _, new_host, new_port = command.split()</span><br><span class="line">            HOSTNAME = <span class="string">f&quot;R<span class="subst">&#123;<span class="built_in">int</span>(new_port) - <span class="number">4999</span>&#125;</span>&quot;</span></span><br><span class="line">            FIRSTFLAG = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> tn:</span><br><span class="line">                tn.write(<span class="string">b&quot;exit\r&quot;</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">                tn.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;\n[NOTE] Switching to router <span class="subst">&#123;new_host&#125;</span> on port <span class="subst">&#123;new_port&#125;</span>&quot;</span>)</span><br><span class="line">            tn = telnet_login_and_wait_for_prompt(new_host, <span class="built_in">int</span>(new_port))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> tn:</span><br><span class="line">                send_telnet_command(tn, command)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;[Error] No active Telnet session. Skipping command.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> tn</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">configure_router</span>():</span><br><span class="line">    commands = load_commands_from_file(FILENAME)</span><br><span class="line">    tn = process_commands(commands)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> tn:</span><br><span class="line">        tn.write(<span class="string">b&quot;exit\r&quot;</span>)</span><br><span class="line">        tn.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="comment">#     with open(&quot;output.txt&quot;, &quot;w&quot;) as file:</span></span><br><span class="line"><span class="comment">#     # 重定向标准输出到文件</span></span><br><span class="line"><span class="comment">#         sys.stdout = file</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#         # 示例打印内容</span></span><br><span class="line"><span class="comment">#         print(&quot;This will be written to the file.&quot;)</span></span><br><span class="line"><span class="comment">#         print(&quot;Another line in the file.&quot;)</span></span><br><span class="line"><span class="comment">#         configure_router()</span></span><br><span class="line"><span class="comment">#         print(&quot;exit\n[Success] Configure finished&quot;)</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    configure_router()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;exit\n[Success] Configure finished&quot;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Computer_network</category>
      </categories>
  </entry>
  <entry>
    <title>史瓦西黑洞</title>
    <url>/posts/fe5450c6.html</url>
    <content><![CDATA[<h1 id="史瓦西黑洞"><a href="#史瓦西黑洞" class="headerlink" title="史瓦西黑洞"></a>史瓦西黑洞</h1><p>一个简单的黑洞模拟小网页</p>
<span id="more"></span>
<h2 id="功能以及注意点"><a href="#功能以及注意点" class="headerlink" title="功能以及注意点"></a>功能以及注意点</h2><p>模拟链接: <a href="https://feipiao594.github.io/html/blackhole.html">https://feipiao594.github.io/html/blackhole.html</a></p>
<p>你可以用鼠标拖动转动视角，也可以用滚轮控制远近</p>
<p>你可以在 nasa 的官网上拿到一张高清的天空盒照片(通常分辨率比例为2：1)，导入，会有不错的效果<br>官网如下，你可能需要使用使用一些格式转换工具转成 jpg<br><a href="https://svs.gsfc.nasa.gov/4851">https://svs.gsfc.nasa.gov/4851</a></p>
<p><img src="/images/史瓦西黑洞_图1.png" width="100%" height="100%"></p>
<blockquote>
<p><strong>WARNING</strong> 注意:<br>1、本程序只对 <strong>PC端</strong> 进行了适配<br>2、本程序需要使用 WebGL 调用 GPU，对设备有一定的要求<br>3、由于使用 GPU 有一些耗电（</p>
</blockquote>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Math_modeling</category>
      </categories>
  </entry>
  <entry>
    <title>含水滚筒的水平面</title>
    <url>/posts/6b2e6898.html</url>
    <content><![CDATA[<h1 id="含水滚筒的水平面"><a href="#含水滚筒的水平面" class="headerlink" title="含水滚筒的水平面"></a>含水滚筒的水平面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近看到一道我个人感觉挺感兴趣的一题，让我开始注意了物理当中微分相关的性质.</p>
<span id="more"></span>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果有一个装满水的滚筒，假设它以$ \omega $为角速度沿着它的中轴旋转，若其水不会被甩出，那么求证，水面为抛物面<br>其实这个题本身并没有什么大难度，而是要以曲面的思维去考虑，对于曲面上一小团水，数学里喜欢说<strong>xx元素</strong>，这里也可以被称为水元素，那这团水元素会受重力，其它水元素对它的力，总体合成出来可以提供向心力，如图。<br><img src="/images/含水滚筒的水平面_图1.jpg" width="30%" height="30%"><br>换作高中的我大抵是想不到下一步的，我会以为是知识不足，但是若我能注意到，模糊的那个力，也就是<strong>其它水元素对它的力</strong>，这个力的方向其实是由曲面切向来决定的，那问题就很好解决了</p>
<script type="math/tex; mode=display">y'(r) = \frac{mg}{m \frac{v^2}{r} } =\frac{g}{v^2}r</script><p>显然，这就是抛物面咯</p>
<h2 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h2><p>其实我也不是第一次见这种方法了，当时第一次接触悬链线的时候我就见过它，角度往往能和切线搭上关系，可是这究竟是为什么呢？<br>这也许就是微分学和物理能巧妙结合的原因吧。<br>(又水了一篇，感觉最近状态不太好，就想写水文，不过好在这里可以自由发挥，也无关紧要啦 ^_^ )</p>
]]></content>
      <categories>
        <category>Physics</category>
        <category>Mechanics</category>
      </categories>
  </entry>
  <entry>
    <title>圆盘摩擦力矩</title>
    <url>/posts/8a033795.html</url>
    <content><![CDATA[<h1 id="含水滚筒的水平面"><a href="#含水滚筒的水平面" class="headerlink" title="含水滚筒的水平面"></a>含水滚筒的水平面</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在计算一个圆盘的摩擦力矩的时候产生了一些困惑，写下来与大家共同探讨</p>
<span id="more"></span>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果一个质量为$m$，半径为$R$的均匀圆板平放在桌面上，圆环与桌面之间的动摩擦因数为$\mu$，若圆板绕通过圆心且垂直与桌面的转轴旋转，求在圆板转动过程中摩擦力对转轴的力矩</p>
<h2 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h2><p>显然对于这个问题，我能想到的最无脑的方式就是二重积分，实际上我也是这么做的</p>
<h3 id="法一"><a href="#法一" class="headerlink" title="法一"></a>法一</h3><script type="math/tex; mode=display">M = \int_{\Omega}\frac{\mu mg}{S}\cdot r \mathrm{d}S=\frac{2}{3}\mu mgR</script><p>但紧接着我就注意到了，老师用的方法是圆盘的分割无限加细，需要把圆盘分割成无限多个圆环</p>
<h3 id="法二"><a href="#法二" class="headerlink" title="法二"></a>法二</h3><p>将圆盘分割成无限多个圆环，则圆盘的质量面密度：</p>
<script type="math/tex; mode=display">\sigma = \frac{m}{\pi R^2}</script><p>圆环的质量为</p>
<script type="math/tex; mode=display">\mathrm{d}m = \sigma \mathrm{d}S = \sigma 2\pi r \mathrm{d}r</script><p>每个圆环产生的摩擦力矩</p>
<script type="math/tex; mode=display">\mathrm{d}M_{阻} = \mu gr \mathrm{d}m\\M_{阻}=\int \mathrm{d}M_{阻} =\int_{0}^{R} \mu gr\mathrm{d}m=\frac{2}{3}\mu mgR</script><p>这种方法其实并不显然，其实还是把问题转化为了求一个<strong>面积元素</strong>，在求圆环质量时就是再求一个<strong>面积元素</strong></p>
<h3 id="法三"><a href="#法三" class="headerlink" title="法三"></a>法三</h3><p>这就是我当时疑惑的点，因为在我看来，如果把它转化为一个圆环时成立的话，类似割圆法转化为好几个圆棒也自然是可以的，但结果算出来却是不同，以下是这种方法的错误计算结果</p>
<p>首先计算单个圆棒的</p>
<script type="math/tex; mode=display">M_{阻} = \int_0^{R} \mu r\frac{m_棒}{R}g \mathrm{d}r = \frac{1}{2}\mu m_棒gR</script><p>再计算整体的，即在原来基础上乘以$2\pi$，又把$m_棒$换成整体的质量，也就是$\frac{m_棒}{2\pi}$</p>
<script type="math/tex; mode=display">M_{阻} = \frac{1}{2}\mu mgR</script><p>发现问题了么，这里第一个积分计算的是一个线元素，而我们在上面的例子全部都是面积元素，而这边我们需要把面积分为线元素和面元素，但<strong>线元素和面元素本来就没有什么关系</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这点我们的微分学就能告诉我们，这绝对是错的</p>
<p>当我询问了老师同学之后，我得到了答案，在这里，我们根本不能分成棒，只能分成<strong>三角形</strong>，这点就是来源于面元素不能和线元素混为一谈，不能强行直观上凑一个式子出来，将他俩转化</p>
<p>而如果是<strong>三角形</strong>的话，整体的力的重心就到了$\frac{2}{3}$，瞧，这个神奇的分数就这么出来了</p>
<p>所以说，对于一个二维的问题，我们自然只能分为<strong>面元素</strong>来考虑，而不能降一级到线积分，否则必然会遇到其中的问题(什么雅可比方程组的缩放比例之类的事情)</p>
<blockquote>
<p>对于一个n维的分布问题，我们只能获得体积元素，也就是，立体只能得到体密度，面只能得到面密度，体只能用体积元素逼近，面只能用面积元素逼近。</p>
</blockquote>
<p>小小思考，如是而已，愿君共勉。</p>
]]></content>
      <categories>
        <category>Physics</category>
        <category>Mechanics</category>
      </categories>
  </entry>
  <entry>
    <title>复变函数的微积分的诠释</title>
    <url>/posts/d046a7c5.html</url>
    <content><![CDATA[<h1 id="复变函数的微积分的诠释"><a href="#复变函数的微积分的诠释" class="headerlink" title="复变函数的微积分的诠释"></a>复变函数的微积分的诠释</h1><p>作为电子类专业的学生，我从一开始就知道复变函数对我的重要性，原因是电路当中的知识会<strong>极大</strong>的使用到复变函数。而常用的傅里叶变换，也将在复平面上进行，所以这一部分其实我必须搞清楚。</p>
<span id="more"></span>
<h2 id="扯点别的"><a href="#扯点别的" class="headerlink" title="扯点别的"></a>扯点别的</h2><p>关于复变函数其实我接触的有够早的，原因是当时还小的时候，深受因式分解这一个操作的困扰，虽然从现在的视角来看，因式分解不再是一个奇幻的问题，但是其仍然是一个<strong>复杂</strong>的问题。<br>当时我看到了 $x^{11}+x^7+1$ 因式分解这个问题，我第一次看见了凑根法这一种神奇的方法，而且我第一次看见这种方法就给我上强度，直接进入复变函数的部分<br>还记得当时利用互联网搜索到欧拉公式，借由它推导出了目前我所学到的那些基本初等函数在复数上的延拓，已经过去好久了</p>
<blockquote>
<p>由于本人只是一个工科专业的学生，极度受限于视野的局限性，我的复变函数主要偏向工科，甚至是合并到了我的高数书中，我也没有特意去看理科的复分析，如有不严谨的地方，万望包涵</p>
</blockquote>
<h2 id="微分部分"><a href="#微分部分" class="headerlink" title="微分部分"></a>微分部分</h2><p>首先，要想函数能够微分，在课本上我们给出了高于微分条件的解析的一个充要条件:<br>设函数$f(z)=u(x,y)+iv(x,y)$在区域$D$内有定义，则$f(z)$在$D$内一点$z=x+iy$处可导的充要条件是:$u(x,y)$与$v(x,y)$在点$(x,y)$处可微，且在该点处满足柯西-黎曼方程:</p>
<script type="math/tex; mode=display">
\frac{\partial u}{\partial x}=\frac{\partial v}{\partial y}\quad-\frac{\partial u}{\partial y}=\frac{\partial v}{\partial x}</script><p>应该不只有我一个人觉得这个柯西-黎曼方程来路奇怪，因为根据前面我们学过的东西，这里的符号应该也有自洽性才对</p>
<p>实际上</p>
<script type="math/tex; mode=display">d\omega=du+idv\\
\frac{d\omega}{dz}=\frac{du+idv}{dx+idy}</script><p>将上面这个式子同除$dx$或者$dy$，可以得到下面的式子</p>
<script type="math/tex; mode=display">\frac{d\omega}{dz}=\frac{\frac{du}{dx}+i\frac{dv}{dx}}{1+i\frac{dy}{dx}}=\frac{\frac{du}{dy}+i\frac{dv}{dy}}{i+\frac{dx}{dy}}</script><p>根据变量的独立性，显然</p>
<script type="math/tex; mode=display">\frac{dx}{dy}=\frac{dy}{dx}=0</script><p>那么整体整理就能得到柯西-黎曼方程，但是这只说明了<strong>必要性</strong>，<strong>充分性</strong>仍旧是一个问题，<strong>不过确实是自然的导出了这个式子，我们便可以以此来假设并证明它的充分性了</strong></p>
<p>但也像二元函数一样</p>
<ul>
<li>偏导数存在<strong>不能</strong>推出方向导数存在</li>
<li>偏导数存在<strong>能</strong>推出全微分存在<strong>进而</strong>推出方向导数存在</li>
</ul>
<p>解析就是一个区域内偏导数连续的概念，可以推导出整个区域内全微分存在，也就是和解析性类似<br>而单独一个点即使满足柯西-黎曼方程，也不能推导出导数存在</p>
<p><strong>但是一个点实变函数可微且满足柯西-黎曼方程可以推导出函数复可微</strong></p>
<h3 id="微分部分后记"><a href="#微分部分后记" class="headerlink" title="微分部分后记"></a>微分部分后记</h3><p>从微分角度可以更好的理解这个式子的来路</p>
<script type="math/tex; mode=display">
\begin{aligned}df&=f'(z)dz=du+idv\\&=(u_x+iv_x)(dx+idy)\\&=(u_x+iv_x)dx+(-v_x+iu_x)dy\end{aligned}</script><p>而根据$f=u+iv$可得</p>
<script type="math/tex; mode=display">
df = (u_x+iv_x)dx+(u_y+iv_y)dy</script><p>为了满足上面的抽象出来的式子，所以硬构造了一个规则</p>
<blockquote>
<p>(下面是存疑部分)实际上对于多元复变函数也是如此，只不过多加几个和式而已(虽然我已经计算出来了，但我因为学识浅薄，不能保证其是否真的存在这样的概念，权当我在胡扯)</p>
</blockquote>
<h2 id="积分部分"><a href="#积分部分" class="headerlink" title="积分部分"></a>积分部分</h2><p>这个没什么好说的，复数的积分</p>
<script type="math/tex; mode=display">
\begin{aligned}\int_D\omega &= \int_Df(z)dz \\&= \int_D (u(x,y)+iv(x,y))(dx+idy)\end{aligned}</script><p>这可不是只是一种简单记忆的方法，这就是本质的定义，因而把它拆开变成两个普通的积分也是成立的，自然而然的，它也有stokes公式的那些性质，而这些性质就是书上所说的，<strong>积分基本定理</strong>，甚至看上去就和stokes定理毫无差别</p>
<h3 id="柯西定理"><a href="#柯西定理" class="headerlink" title="柯西定理"></a>柯西定理</h3><p>因为解析函数必然有原函数，所以求两次外微分显然为0，柯西定理显然是成立的</p>
<h3 id="其它定理"><a href="#其它定理" class="headerlink" title="其它定理"></a>其它定理</h3><p>根据柯西定理，显然其它定理，比如复合闭路定理也成立<br>唯一要注意的是方向问题，由于这个定理本质上就来自于stokes定理，所以方向取的其实和2维流形内方向的选取是完全一致的。</p>
<h2 id="关于其于普通流形相关的诠释"><a href="#关于其于普通流形相关的诠释" class="headerlink" title="关于其于普通流形相关的诠释"></a>关于其于普通流形相关的诠释</h2><blockquote>
<p>(下面是存疑部分，纯属胡扯)</p>
</blockquote>
<p>其实复平面稍微退化一下就是$\mathbb{R}^2$，或者说$dz$就是一种特殊的微分形式。所以环路积分为0是退化的结果<br>而复积分也许也有自己的这个层次的“stokes定理”，就是指它的“牛顿-莱布尼茨公式”<br>复微分也是一种复变函数上特殊的运算，虽然形式上和普通微分毫无差别，但它要求在复平面上每一个方向的微分其实都是一致的<br>在函数解析的前提之下，把$z$看作元，又可以得到复平面上整体的性质<br>这些复平面上的上级结论是和退化之前的应该是不一定能保证完全一致的</p>
<script type="math/tex; mode=display">
f(z)=g(x,y)=u(x,y)+iv(x,y)</script><p>这个式子即把复变函数退化为二元函数，但是这个式子要想成立得需要一系列的条件，而满足这些条件就可以用$z$为视角来看待积分<br>也就是说复积分是特化情况下可以把两个元看成同一个元的二元函数线积分，那么就是一种<strong>特殊化</strong>的stokes公式了，至少二元函数映射到$n$元其实也是$n$个毫不相干的实函数，当然可以满足stokes公式，区区复数$n=2$不在话下<br>对微分来说，直接变成其实微分也就是形式上直接对整体$z$微分和化为$n$元实函数进行微分没什么两样，对多元复变函数也是如此</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的讨论可以看出，复变函数真的是满足了更多更好性质的实变函数的一种更上层的抽象，<strong>也就是说复变函数研究的是一些“好函数”，而实变函数研究的是一些“坏函数”罢了</strong></p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Complex_function</category>
      </categories>
  </entry>
  <entry>
    <title>在Gentoo上用KVM玩Mac</title>
    <url>/posts/ebefb94c.html</url>
    <content><![CDATA[<h1 id="在Gentoo上用KVM玩Mac"><a href="#在Gentoo上用KVM玩Mac" class="headerlink" title="在Gentoo上用KVM玩Mac"></a>在Gentoo上用KVM玩Mac</h1><p>看起来大家都很喜欢 Mac，于是乎我也搞了一个虚拟机装 Mac，在这里记录一下安装过程希望能帮到大家</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>发现有些学弟学妹们买了 Mac，有些学长也全换了 Mac 搞开发，而我们的项目却常常由于缺少 Mac 导致适配不了这些设备，最后我还是启动了一个黑苹果</p>
<p>说起来这次装过 Mac 虚拟机之后，我基本上什么系统都装的七七八八了。之前因为学校学习用的各种专有软件也使用了很多虚拟机，最后让我在同学之中多了“虚拟机大神”的称号，这下是真的能算是对装虚拟机有不少经验了。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>我们使用到的项目是 OSX-KVM (<a href="https://github.com/kholia/OSX-KVM">https://github.com/kholia/OSX-KVM</a>)<br>官方的仓库只写了对 Ubuntu 的支持，但基本上只要变动一下第一步安装的各种包就能解决问题<br>安装你所需的软件，此处略去了对 kernel 的要求，详情请自行查询 Gentoo Wiki</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo emerge --ask --verbose </span><br><span class="line">        net-analyzer/openbsd-netcat \ </span><br><span class="line">        app-emulation/libguestfs \</span><br><span class="line">        app-emulation/virt-manager \</span><br><span class="line">        app-text/tesseract \</span><br><span class="line">        app-emulation/qemu \</span><br><span class="line">        app-misc/screen \</span><br><span class="line">        sys-apps/net-tools \</span><br><span class="line">        app-arch/p7zip</span><br></pre></td></tr></table></figure>
<p>注意上述没有包含 <code>vim</code> <code>git</code> <code>wget</code> 这种极其常用的软件包，以及一些软件需要 unmask 操作</p>
<p>对于 <code>qemu</code> 需要注意加上 <code>usbredir</code> 和 <code>spice</code> USE flags</p>
<blockquote>
<p><strong>NOTE</strong>: net-analyzer/openbsd-netcat 该包需要解决一些依赖问题，因为其和原有的 netcat 包不能共存，方法是 unemerge 原来的 netcat，参考 emerge 的报错即可</p>
</blockquote>
<p>顺带一提，关于 ArchLinux 在被关闭的 pr 中有需要安装包的相关说明 (<a href="https://github.com/kholia/OSX-KVM/pull/232/files">https://github.com/kholia/OSX-KVM/pull/232/files</a>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">git <span class="built_in">clone</span> --depth 1 --recursive https://github.com/kholia/OSX-KVM.git</span><br><span class="line"><span class="built_in">cd</span> OSX-KVM</span><br><span class="line"></span><br><span class="line">sudo modprobe kvm; <span class="built_in">echo</span> 1 | sudo <span class="built_in">tee</span> /sys/module/kvm/parameters/ignore_msrs</span><br><span class="line"></span><br><span class="line">sudo <span class="built_in">cp</span> kvm.conf /etc/modprobe.d/kvm.conf  <span class="comment"># for intel boxes only</span></span><br><span class="line">sudo <span class="built_in">cp</span> kvm_amd.conf /etc/modprobe.d/kvm.conf  <span class="comment"># for amd boxes only</span></span><br><span class="line"></span><br><span class="line">sudo usermod -aG kvm $(<span class="built_in">whoami</span>)</span><br><span class="line">sudo usermod -aG libvirt $(<span class="built_in">whoami</span>)</span><br><span class="line">sudo usermod -aG input $(<span class="built_in">whoami</span>) <span class="comment"># these 3 commands need reboot</span></span><br></pre></td></tr></table></figure>
<p>使用它的 python 脚本下载 Mac 官方镜像</p>
<blockquote>
<p><strong>WARNING</strong>: 经过实际测试 MacOS 13 官方推荐的版本是可用的，但 MacOS 14 15 不可用，即使在 python 文件中有标出能下载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./fetch-macOS-v2.py</span><br></pre></td></tr></table></figure>
<p>输入以下两条指令创建 MacOS 所使用的虚拟磁盘<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-img create -f qcow2 mac_hdd_ng.img 256G</span><br><span class="line"></span><br><span class="line">qemu-img convert BaseSystem.dmg -O raw BaseSystem.img</span><br><span class="line"></span><br><span class="line"><span class="comment"># for distribution with `dmg2img`, you can use command below</span></span><br><span class="line"><span class="comment"># dmg2img -i BaseSystem.dmg BaseSystem.img</span></span><br></pre></td></tr></table></figure></p>
<p>是时候启动了<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./OpenCore-Boot.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="进入系统"><a href="#进入系统" class="headerlink" title="进入系统"></a>进入系统</h2><p>首先启动 Install 的盘，将 256GB 大小的盘格式化为 APLS 文件系统，并安装，安装过程中涉及好几次重启，请注意别把自动重启当成出错了</p>
<h2 id="添加到-virt-manager-中"><a href="#添加到-virt-manager-中" class="headerlink" title="添加到 virt-manager 中"></a>添加到 <code>virt-manager</code> 中</h2><p>在做完了上面的这些操作之后我们要把虚拟机加入到 virt-manager 中进行管理<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&quot;s/CHANGEME/<span class="variable">$USER</span>/g&quot;</span> macOS-libvirt-Catalina.xml &gt; macOS.xml</span><br><span class="line">virt-xml-validate macOS.xml</span><br><span class="line">virsh --connect qemu:///system define macOS.xml</span><br></pre></td></tr></table></figure></p>
<p>注意这里有一个很坑的地方，你需要手动删除配置文件中的两个东西才能正常启动，如下图，一个是此处的串口，一个是 <code>qemu-ga</code></p>
<p><img src="/images/在Gentoo上用KVM玩Mac_图1.png" width="100%" height="100%"></p>
<blockquote>
<p><strong>NOTE</strong>: 由于我的独立显卡属于N卡，显卡直通缺少驱动，无法进行，所以这边我们就此略过</p>
</blockquote>
<p><strong>这是我已经安装完成的 Mac</strong><br><img src="/images/在Gentoo上用KVM玩Mac_图2.png" width="100%" height="100%"></p>
<h2 id="一键安装"><a href="#一键安装" class="headerlink" title="一键安装"></a>一键安装</h2><p>参考项目 ultimate-macOS-KVM: <a href="https://github.com/Coopydood/ultimate-macOS-KVM">https://github.com/Coopydood/ultimate-macOS-KVM</a></p>
<blockquote>
<p>注意该项目实测可以安装较新版本的 MacOS</p>
</blockquote>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Project_Tools</category>
        <category>Another</category>
      </categories>
  </entry>
  <entry>
    <title>对书本中狄拉克函数的诠释</title>
    <url>/posts/c4ebbeff.html</url>
    <content><![CDATA[<h1 id="对书本中狄拉克函数的诠释"><a href="#对书本中狄拉克函数的诠释" class="headerlink" title="对书本中狄拉克函数的诠释"></a>对书本中狄拉克函数的诠释</h1><p>当我第一次看见冲激函数的时候，我整个人是震惊的，你管这玩意叫函数，吃设定呢吧，但鉴于它的实际用处，只能对它进行一定的解释</p>
<span id="more"></span>
<h2 id="WARNING"><a href="#WARNING" class="headerlink" title="WARNING"></a>WARNING</h2><blockquote>
<p>前排提示:本文只是记录记录某一些定理，方便我进行理解，但不作为严谨的推导，所以看看就行，不必当真<br>文章的定义摘抄自<strong>知乎@我烂了 专栏</strong>:<a href="https://www.zhihu.com/column/c_1462378232960466945">广义函数论与函数空间</a><br>只是摘抄了些定义用作笔记应该不会有什么问题吧QAQ</p>
</blockquote>
<h2 id="写这篇文档的原因"><a href="#写这篇文档的原因" class="headerlink" title="写这篇文档的原因"></a>写这篇文档的原因</h2><p>主要是在看《信号与系统分析》这本书的时候发现了一个奇怪的东西，即$\int_{0^-}^{0^+}$这个积分符号，我们可以理解它其实是</p>
<script type="math/tex; mode=display">\lim_{a \to 0} \int_{a^-}^{a^+}</script><p>但我个人第一次看的时候觉得书中对线性系统的冲激响应求法说明不够正确(<strong>实质上还是挺对的</strong>)，于是就有了接下来的内容</p>
<h2 id="广义函数的定义"><a href="#广义函数的定义" class="headerlink" title="广义函数的定义"></a>广义函数的定义</h2><p>$(\mathcal{D}^{\prime}(\Omega)$<strong>广义函数</strong>)若$\Omega\subset\mathbb{R}^n$为一个非空开集，$\mathcal{D}^{\prime}(\Omega)$广义函数是 指$\mathcal{D}(\Omega)$ 上的有界连续线性泛函所组成的集合。亦即对于任意$T\in\mathcal{D}^{\prime}(\Omega)$，$T:\mathcal{D}^{\prime}(\Omega)\to\mathbb{C}$是$\mathcal{D}(\Omega)$上的线性泛函，且满足下面的连续性条件:</p>
<p>对任意$\{\varphi_\nu\}\subset\mathcal{D}(\Omega)$，$\varphi_\nu\to0\:(\mathcal{D}(\Omega))$，则成立$\lim_{\nu\to\infty}T[\varphi_\nu]=0$</p>
<p>注意这里的$\mathcal{D}(\Omega)$定义如下<br>(<strong>紧支集的光滑函数空间</strong>)若$\Omega\subset\mathbb{R}^n$为一个非空开集，则$\mathcal{D}(\Omega)$定义如下</p>
<script type="math/tex; mode=display">
\mathcal{D}(\Omega)\stackrel{\text{def}}{=}\begin{Bmatrix}\varphi\in C^\infty(\Omega),\text{supp}\varphi\text{ 是紧集}\end{Bmatrix}</script><p>需要注意的是，$\mathbb{R}^n$不是紧致的，这意味着如果$\Omega$就是$\mathbb{R}^n$，那么函数在无穷远处都是0<br>而$\mathcal{D}^{\prime}(\Omega)$指的则是构建在其上的泛函空间</p>
<h3 id="关于-Omega-subset-mathbb-R-n"><a href="#关于-Omega-subset-mathbb-R-n" class="headerlink" title="关于$\Omega\subset\mathbb{R}^n$"></a>关于$\Omega\subset\mathbb{R}^n$</h3><p>在这里$R^n$可以推广到任意<strong>光滑流形</strong>，这意味着闭集这种紧流形上的函数，在自己这个流形内讨论也可以把整个流形作为开集，也就符合了定义在闭区间上函数的定义，下面讨论的这些也就自然而然满足了闭集了</p>
<h3 id="Dirac函数"><a href="#Dirac函数" class="headerlink" title="Dirac函数"></a>Dirac函数</h3><p>任意试验函数$\varphi(x)$与它在$x=0$上的函数值$\varphi(0)$对应的广义函数称为$\delta$函数，即$\delta$函数满足</p>
<script type="math/tex; mode=display">
\langle \delta,\varphi\rangle = \varphi(0),\varphi(x)\in\mathcal{D}(\Omega)</script><p>注意这里的$\Omega$，这说明了其实如果写成积分形式(看下文)， 积分上下限可以不是无穷</p>
<p>考虑到书中有对Dirac的定积分，我理解为Dirac函数乘以除上下限包围的区域以外为1都为0的常义函数(广义函数是有更加广泛的乘法定义的，这样说明没有问题)，再对$f(x)=1$进行内积，虽然在奇异点上不能使用，不过除了这种无法讨论的情况，对于大部分情况都成立</p>
<h3 id="对于局部绝对可积函数"><a href="#对于局部绝对可积函数" class="headerlink" title="对于局部绝对可积函数"></a>对于局部绝对可积函数</h3><p>设$f(x)$是 $\mathbb{R}$上的局部绝对可积函数，即在任何有限区间$(a,b)$上积分$\int_{a}^{b}|f(x)|dx$均存在，则试验函数$\varphi(x)$与积分值 $\int_{-\infty}^{\infty}f(x)\varphi(x)dx$的对应是一个广义函数，即$f(x)$对应着一个广义函数</p>
<script type="math/tex; mode=display">
\langle f,\varphi\rangle = \int_{-\infty}^{\infty}f(x)\varphi(x)\mathrm{d}x</script><h2 id="广义函数的导数"><a href="#广义函数的导数" class="headerlink" title="广义函数的导数"></a>广义函数的导数</h2><p>(<strong>广义函数的导数</strong>)对 $T\in\mathcal{D}^{\prime}(\Omega)$，分布导数 $\frac{\partial T}{\partial x_k}\in\mathcal{D}’(\Omega)$ 定义为</p>
<script type="math/tex; mode=display">
\Big\langle\frac{\partial T}{\partial x_{k}},\varphi\Big\rangle\stackrel{\mathrm{def}}{=}-\Big\langle T,\frac{\partial\varphi}{\partial x_{k}}\Big\rangle,\quad\forall\:\varphi\in\mathcal{D}(\Omega).</script><p>由于广义导数的存在，使得含有广义函数的<strong>微分方程</strong>有了良好的定义，但也只是微分方程有定义，积分方程就不一定了</p>
<blockquote>
<p>显然，广义函数的导数和广义函数本身一般是不同的泛函</p>
</blockquote>
<h2 id="广义函数的乘法"><a href="#广义函数的乘法" class="headerlink" title="广义函数的乘法"></a>广义函数的乘法</h2><p>(<strong>广义函数的乘法</strong>)对$\psi\in C^{\infty}(\Omega)$，$f\in\mathcal{D}^{\prime}(\Omega)$，定义他俩的乘法$\psi f\in\mathcal{D}^{\prime}(\Omega)$为</p>
<script type="math/tex; mode=display">
\langle f\psi,\varphi\rangle=\langle\psi f,\varphi\rangle=\langle f,\psi\varphi\rangle,\quad(\forall\varphi\in\mathcal{D}(\Omega))</script><h3 id="定理-导数运算法则-乘法"><a href="#定理-导数运算法则-乘法" class="headerlink" title="定理_导数运算法则(乘法)"></a>定理_导数运算法则(乘法)</h3><p>广义函数满足导数的运算法则，即若$\psi\in C^{\infty}(\Omega)$，$f\in\mathcal{D}^{\prime}(\Omega)$，则</p>
<script type="math/tex; mode=display">
(\psi f)'=\psi'f+\psi f'</script><p><strong>proof.</strong><br>即证</p>
<script type="math/tex; mode=display">
\langle (\psi f)',\varphi\rangle=\langle\psi' f + \psi f',\varphi\rangle</script><p>首先</p>
<script type="math/tex; mode=display">
\langle (\psi f)',\varphi\rangle=-\langle \psi f,\varphi'\rangle=-\langle f,\psi\varphi'\rangle=\langle f,-\psi\varphi'\rangle</script><p>然后</p>
<script type="math/tex; mode=display">
\begin{aligned}\langle\psi' f + \psi f',\varphi\rangle &= \langle f,\psi'\varphi\rangle + \langle f',\psi\varphi\rangle \\&=\langle f,\psi'\varphi\rangle - \langle f,(\psi\varphi)'\rangle \\& = \langle f,\psi'\varphi\rangle - \langle f,\psi'\varphi + \psi\varphi'\rangle \\& = \langle f,\psi'\varphi-\psi'\varphi-\psi\varphi'\rangle\\& = \langle f,-\psi\varphi'\rangle\end{aligned}</script><p>最后</p>
<script type="math/tex; mode=display">
\langle (\psi f)',\varphi\rangle=\langle f,-\psi\varphi'\rangle=\langle\psi' f + \psi f',\varphi\rangle</script><p>得证，<strong>Q.E.D</strong></p>
<h2 id="关于-delta-函数"><a href="#关于-delta-函数" class="headerlink" title="关于$\delta$函数"></a>关于$\delta$函数</h2><p><strong>e.g</strong>.考虑Heaviside函数</p>
<script type="math/tex; mode=display">
H(x)=\left\{\begin{array}{ll}1,&\text{若 }x>0,\\0,&\text{若 }x<0.\end{array}\right.</script><p>则 $\frac{\mathrm{d}H(x)}{\mathrm{d}x}=\delta.$</p>
<p>证明，对任意$g\in\mathcal{D}(\Omega)$，成立</p>
<script type="math/tex; mode=display">
\Big\langle\frac{\mathrm{d}H}{\mathrm{d}x},\varphi\Big\rangle=-\Big\langle H,\frac{\mathrm{d}\varphi}{\mathrm{d}x}\Big\rangle=-\int_0^\infty\frac{\mathrm{d}\varphi(x)}{\mathrm{d}x}=\varphi(0)=\langle\delta,\varphi\rangle</script><p>证毕</p>
<p>由上述式子可以从逻辑上得到$\delta$函数的积分结果，但实际上，$\delta$函数的积分是得从它的定义来的，<strong>而广义函数应该并不能定义实际上的积分</strong></p>
<script type="math/tex; mode=display">
\langle \delta,\varphi\rangle = \varphi(0)</script><p>历史原因，使得其可以写成</p>
<script type="math/tex; mode=display">
\langle \delta,\varphi\rangle = \int_{-\infty}^{\infty}\delta(x)\varphi(x)\mathrm{d}x = \int_{-a}^{a}\delta(x)\varphi(x)\mathrm{d}x=\varphi(0)</script><p>那么取一个极限，也可以得到最开始的问题的解决方案</p>
<script type="math/tex; mode=display">
\begin{aligned}\langle \delta,\varphi\rangle &= \lim_{a\to\infty}\int_{-a}^{a}\delta(x)\varphi(x)\mathrm{d}x\\&=\int_{0^-}^{0^+}\delta(x)\varphi(x)\mathrm{d}x\\&=\varphi(0)\end{aligned}</script><p>假设$\varphi(x) = 1$，则$\varphi\in\mathcal{D}(\Omega)$，那么我们就可以得到</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty}\delta(x)\mathrm{d}x =\int_{0^-}^{0^+}\delta(x)\mathrm{d}x= 1</script><p>其实事实上对于$\delta$函数来说，<strong>根本就没有定义黎曼积分或勒贝格积分</strong>，这只是一种写法而已，完全可以不用这种写法，转而使用严格的泛函的写法</p>
<h2 id="关于-delta’-函数"><a href="#关于-delta’-函数" class="headerlink" title="关于$\delta’$函数"></a>关于$\delta’$函数</h2><p>根据上面的逻辑可以导出$\delta’$，即Dirac Delta函数的导函数，称为冲激偶函数</p>
<p>冲激偶$\delta’$函数是<strong>奇函数</strong>，即$-\delta’(x)=\delta’(-x)$</p>
<p>冲激偶函数是从正向逼近$0$为$-\infty$，从负向逼近$0$为$+\infty$的奇异函数，其定义的另一种形式如下</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty}f(x)\delta'(x-x_0)\mathrm{d}x = -f'(x_0)</script><p>如此也可以定义delta函数的任意n阶导函数</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{\infty}f(x)\delta^{(n)}(x-x_0)\mathrm{d}x = (-1)^nf^{(n)}(x_0)</script><p>根据定义、冲激函数$f(x)\delta(x)=f(0)$的性质与上面有提到的导数运算法则(乘法)和可以得到如下等式</p>
<script type="math/tex; mode=display">
f(t)\delta'(t)=f(0)\delta'(t)-f'(0)\delta(t)</script><p>从而</p>
<script type="math/tex; mode=display">
x\delta'(x)=-\delta(x)\qquad x^2\delta''(x)=2\delta(x)</script><h2 id="求解线性系统的冲激响应"><a href="#求解线性系统的冲激响应" class="headerlink" title="求解线性系统的冲激响应"></a>求解线性系统的冲激响应</h2><script type="math/tex; mode=display">
a_{n}h^{(n)}(t)+a_{n-1}h^{(n-1)}(t)+\cdots+a_{1}h^{\prime}(t)+a_{0}h(t)=\delta(t)</script><p>对于这个方程，我们观察到，从逻辑上讲，解得的$h(t)$一定是一个<strong>常义函数</strong>，根据冲激函数的物理意义是一个瞬间的无穷大信号而言，我也可以推得在小于0的时候信号一定为0，而在大于0的时候才是我们真正需要考量的函数，因此最终在<strong>物理意义的辅助</strong>下我们得到了微分方程解的形式，拆解为$h(x)=f(x)u(x)$(这里的$u(x)$就是上面说的<strong>Heaviside函数</strong>)，而因为$h(x)$在大于0上是连续可导的函数(在大于0的部分微分方程的基本要求，这是这里的特殊要求，原因是防止产生冲激偶，也正是因为这样，在这里$0^-$和$0$没啥区别)，那么在小于0的部分也可以延拓出一个连续的$f(x)$，所以$f(x)$是连续可导的</p>
<p>求解微分方程可以先把这个形式代入进去看看，我们来看看对$h(x)$求多次导的结果(用上面的那些公式就都可以计算出来了)</p>
<script type="math/tex; mode=display">
\begin{cases}
h(x)=f(x)u(x)\\\\
h'(x)=f'(x)u(x)+f(0)\delta(x)\\\\
h''(x)=f''(x)u(x)+f'(0)\delta(x)+f(0)\delta'(x)\\\\
h'''(x)=f'''(x)u(x)+f(0)''\delta(x)+f'(0)\delta'(x)+f(0)\delta''(x)\\\\
\cdots\cdots\cdots\cdots
\end{cases}</script><p>可以看到，对于上面这些式子乘以原本式子里$a_k$累加的结果，如下</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{n} a_kh^{(k)}(x)=(\sum_{k=0}^{n}a_kf^{(k)}(x))u(x)+(\sum_{k=0}^{n-1}a_{(k+1)}f^{(k)}(0))\delta(x)+\\(\sum_{k=0}^{n-2}a_{(k+2)}f^{(k)}(0))\delta'(x)+\cdots+a_nf(0)\delta^{(n-1)}(x)</script><p>好了，我们观察一下这个式子，这个就<strong>是微分方程等式的左端</strong>，而等式右端只是单独的一个$\delta(x)$，所以这个式子<strong>从第三项开始全是0</strong>，即第三项开始到最后那些大和式都是0<br>知道了这点，我们直接去看最后一项，这里只有一项 $a_nf(0)$，想要它为0，即$f(0)=0$，然后再看最后第二项$a_{(n-1)}f(0)+a_nf’(0)$，因为从后一项推得$f(0)=0$，要想$a_{(n-1)}f(0)+a_nf’(0)=0$，只需要$f’(0)=0$。同理再看前一项得到$f’’(x)=0$，<strong>以此类推</strong>，便得到了</p>
<script type="math/tex; mode=display">f^{(n-2)}(0)=f^{(n-3)}(0)=\cdots=f'(x)=f(x)=0</script><p>然后我们看第二项，和原微分方程等式右端组成式子如下</p>
<script type="math/tex; mode=display">
(\sum_{k=0}^{n-1}a_{(k+1)}f^{(k)}(0))\delta(x)=\delta(x)</script><p>由上面推导的等于0的等式就可以化简得</p>
<script type="math/tex; mode=display">
f^{(n-1)}(0)=\frac{1}{a_n}</script><p>剩下的第一个项也应该为0</p>
<script type="math/tex; mode=display">
\sum_{k=0}^{n}a_kf^{(k)}=0</script><p>综合起来就得到了和这个微分方程通解的式子，即</p>
<script type="math/tex; mode=display">
\begin{cases}
h(x)=f(x)u(x)\\\\
f^{(n)}(0)+f^{(n-1)}(0)+\cdots+f'(x)+f(x)=0\\\\
f^{(n-2)}(0)=f^{(n-3)}(0)=\cdots=f'(x)=f(x)=0\\\\
f^{(n-1)}(0)=\frac{1}{a_n}
\end{cases}</script><p>核心的等价的微分方程就是上面这个方程组的第二式，是一个<strong>高阶齐次线性微分方程</strong>，第三、四式是第二式的边界条件，由这三个式子可以唯一确定一个$f(x)$，进而唯一确定一个$h(x)$，从而求得我们所要的冲激响应</p>
<h2 id="另一种解释方法"><a href="#另一种解释方法" class="headerlink" title="另一种解释方法"></a>另一种解释方法</h2><p>关于Dirac函数本身，其具有的积分性质仍然是难以表达的，我们可以使用另一种方法去说明函数，即将极限解释成弱极限的方法</p>
<p>首先对于$\mathscr{D}’(\Omega)$来说，可以将广义函数的微商完全使用弱极限去书写<br>其中$h_i$为向量的第$i$个分量</p>
<script type="math/tex; mode=display">
\lim_{h_i\to0}\frac{f(x+h)-f(x)}{h_i} = \frac{\partial f}{\partial x_i}</script><p>围绕Dirac函数的积分的一切内容其实都是未定义的行为，上面已有的东西解释清楚了除了积分以外的东西，而积分我们可以给它补充定义，就像工科书中说的那样，但是光有定义不能保证其与原本积分的相容性，定义本身应该满足原有的积分性质</p>
<p>其实Dirac函数也有其它的定义，例如它是由函数列求极限得来(事实上，对于$f\in\mathscr{D}’(\Omega)$，其一定可以找到某种函数列$f_i\in C^\infty$弱收敛逼近的)，只要把原先的极限承认为弱极限。</p>
<script type="math/tex; mode=display">
f(x)=\lim_{i\to 0}f_i(x)</script><p>如果积分内部函数为广义函数，就定义为先算序列的积分再进行弱极限，即</p>
<script type="math/tex; mode=display">
\int_a^b f(x)dx=\int_a^b \lim_{i\to 0}f_i(x)dx:=\lim_{i\to 0}\int_a^b f_i(x)dx</script><p>这种记法天生支持原先积分的所有性质，因为极限随时可以先算，我完全可以把函数列当成逼近后的结果，反正随时都可以先算极限</p>
<p>而对于傅里叶变换这种积分变换当中也存在一个极限，是对于广义积分的上下限而言的，如果那个求极限也认为是弱极限的话，也可以得到算出来是广义函数的结果</p>
<blockquote>
<p>虽然弱极限很有用，但是普遍定义下的积分肯定是不存在的，对于课程而言，最根本的还是求解微分方程和本身被特化了的积分变换，我们要做的就是用泛函的语言去得到相同的结果罢了，而不应该注意它是否应该和原本的常规函数性质相同，这没有意义，因为我们并不能创造什么定义<br>事实上对冲激函数及其导数进行积分根本就不会在实际工程中遇到，特别赋予它含义只是工程感性说明的过程罢了，更多的讨论还是集中在$L^2$空间上<br>如果需要更加明确的定义，可以考虑将distribution视作被包含的特例的hyperfunction</p>
</blockquote>
]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>数字信号相关</category>
      </categories>
  </entry>
  <entry>
    <title>广义Fouier变换与Laplace变换</title>
    <url>/posts/f38b0ecb.html</url>
    <content><![CDATA[<h1 id="广义Fouier变换与Laplace变换"><a href="#广义Fouier变换与Laplace变换" class="headerlink" title="广义Fouier变换与Laplace变换"></a>广义Fouier变换与Laplace变换</h1><p>这一篇记录广义函数的Fouier变换与Laplace变换的定义</p>
<span id="more"></span>
<hr>
<h2 id="广义函数的卷积运算"><a href="#广义函数的卷积运算" class="headerlink" title="广义函数的卷积运算"></a>广义函数的卷积运算</h2><p>设$f$，$g$为$\mathcal{D}^{\prime}(\Omega)$，而且至少有一个具有紧致集(即$\mathcal{E}’$)，定义$f*g$为$\mathcal{D}^{\prime}(\Omega)$广义函数</p>
<script type="math/tex; mode=display">
\langle f*g,\varphi\rangle=\langle f(x),\langle g(y),\varphi(x+y)\rangle\rangle</script><blockquote>
<p>$\mathcal{E}^{\prime}(\Omega)$与 $\mathcal{D}^{\prime}(\Omega)$ 之间的联系：设 $T\in D^{\prime}(\Omega),$ 则 $T\in\mathcal{E}^{\prime}(\Omega)$ 当且仅当 $\mathrm{supp} T$是中紧集</p>
</blockquote>
<p>卷积运算满足结合律，交换律，分配律</p>
<script type="math/tex; mode=display">f*g*h=f*(g*h)\qquad f*g=g*f</script><p>且关于Dirac函数满足</p>
<script type="math/tex; mode=display">f*\delta=\delta*f=f</script><p>要注意的是，不存在一般情况下$f$，$g$为$\mathcal{D}^{\prime}(\Omega)$时候的卷积，不满足上面的定义时，只有一些特殊情况可以满足卷积存在</p>
<hr>
<h2 id="Fouier变换"><a href="#Fouier变换" class="headerlink" title="Fouier变换"></a>Fouier变换</h2><p>若$\varphi\in\mathscr{S}(\mathbb{R}^N)$，即速降函数(schwartz function)，定义$T\in\mathscr{S}’(\mathbb{R}^N)$的傅里叶变换如下</p>
<script type="math/tex; mode=display">\langle\mathscr{F}T,\varphi\rangle=\langle T,\mathscr{F}\varphi\rangle</script><p>同理</p>
<script type="math/tex; mode=display">\langle\mathscr{F}^{-1}T,\varphi\rangle=\langle T,\mathscr{F}^{-1}\varphi\rangle\\\langle\mathscr{F}^{-1}\mathscr{F}T,\varphi\rangle=\langle\mathscr{F}\mathscr{F}^{-1}T,\varphi\rangle=\langle T,\varphi\rangle</script><blockquote>
<p>广义函数没有常义函数那种定义域，它只有作为泛函的定义域，就是整个函数空间，那么那种定义域不在整个n维欧式空间上的函数其实也是这个特殊函数空间的泛函</p>
</blockquote>
<p>关于傅里叶变换，首先$\mathscr{F}$是$\mathscr{S}’\to\mathscr{S}’$的同构映射，而它的逆变换如下：</p>
<script type="math/tex; mode=display">\mathscr{F}^{-1}f=\frac{(\mathscr{F}f)(-x)}{2\pi}</script><p>我们能证明，对于$f,g\in\mathscr{S}’$，其中一个具有紧支集($\mathscr{E}’$)，那么满足下式</p>
<script type="math/tex; mode=display">\mathscr{F}(f*g)=\mathscr{F}f\cdot\mathscr{F}g</script><p>已知$ (f<em>g)(-x) = f(-x)</em>g(-x) $与卷积的<strong>线性性质</strong>得</p>
<script type="math/tex; mode=display">\begin{aligned}f*g&=\mathscr{F}^{-1}(\mathscr{F}f\cdot\mathscr{F}g)\\&\Downarrow\\\mathscr{F}^{-1}f*\mathscr{F}^{-1}g&=\mathscr{F}^{-1}(f\cdot g)\\&\Downarrow\\\frac{(\mathscr{F}f*\mathscr{F}g)(-x)}{4\pi^2}&=\frac{\mathscr{F}(f\cdot g)(-x)}{2\pi}\\&\Downarrow\\\frac{\mathscr{F}f*\mathscr{F}g}{2\pi}&=\mathscr{F}(f\cdot g)\\&\Downarrow\\\mathscr{F}(f\cdot g)&=\frac{\mathscr{F}f*\mathscr{F}g}{2\pi}\end{aligned}</script><p>要满足的条件是$f$，$g$中有一个为常义的光滑函数，假设是$g$，另一个$f\in\mathscr{S}’$，且$\mathscr{F}^{-1}g\in\mathscr{E}’$(或者说即$\mathscr{F}g\in\mathscr{E}’$)</p>
<h3 id="计算-delta-函数的傅里叶变换"><a href="#计算-delta-函数的傅里叶变换" class="headerlink" title="计算$\delta$函数的傅里叶变换"></a>计算$\delta$函数的傅里叶变换</h3><script type="math/tex; mode=display">\begin{aligned}
\langle\mathscr{F}\delta,\varphi\rangle&=\langle\delta,\mathscr{F}\varphi\rangle =\mathscr{F}\varphi(0)=\langle1,\varphi\rangle\end{aligned}</script><p>可得</p>
<script type="math/tex; mode=display">\mathscr{F}\delta=1</script><hr>
<h3 id="Laplace变换"><a href="#Laplace变换" class="headerlink" title="Laplace变换"></a>Laplace变换</h3><p>定义下面从$\mathbb{\Gamma}$到$\mathscr{S}_{\eta}^{\prime}$的映射$\xi\to\left(E(\xi)\right)_\eta $，被称为$T\in\mathscr{S}_x^{\prime}(\Gamma)$的Laplace变换记作$\left(\mathscr{L}T(\xi)\right)_n$或简记为$\mathscr{L}T$，其中$\mathscr{S}_x^{\prime}(\Gamma)=\left\{T\in\mathscr{D}_x^{\prime}\right.:\left.\exp(-\xi x)T\in\mathscr{S}_x^{\prime},\forall\xi\in\Gamma\right\}.$</p>
<script type="math/tex; mode=display">\begin{aligned}\left(\mathscr{L}T(\xi)\right)_{\eta}&=\mathscr{L}T=\left(E(\xi)\right)_{\eta}\\&=\left[{\mathscr F}_{(x)}\left(\exp(-\xi x)T_{x}\right)\right]_{\eta}\end{aligned}</script><p>这里的意义是先进行Fouier变换后再把它看作为$\eta$的广义函数，而我们所用的其实下面这个命题叙述得到的</p>
<p>若$\mathbb{\Gamma}$为凸开集，则$\mathscr{S}_{\eta}^{\prime}$的Laplace变换是一个从$\mathbb{\Gamma}$到$(\mathscr{O}_M)_\eta $的无穷可微映射，并且还有</p>
<script type="math/tex; mode=display">
\left(E(\xi)\right)_\eta=E(\xi,\eta)=F(\xi+i\eta)=F(p)</script><p>其中$F$为关于$p\in\Gamma+i\Xi^n$的全纯函数,也称为$T$的Laplace变换<br>反过来,定义在$\Gamma+i\Xi^n$上使得对于$\mathbb{\Gamma}$的任意紧子集$K$,在$K+i\Xi^n$上可被$\eta$的多项式界住的任意全纯函数$F$，均为唯一的广义函数$T\in\mathscr{S}_x^{\prime}(\Gamma)$的 Laplace变换</p>
<p>解读一下，只有支集在$[0,\infty)$上的广义函数，其具有普遍的拉普拉斯变换，定义为</p>
<script type="math/tex; mode=display">\mathscr{L}f=\langle f,e^{-st}\rangle</script><p>在工程中，有这么一个结论</p>
<script type="math/tex; mode=display">\mathscr{L}\frac{\mathrm{d}f}{dx}=pF(p)-f(0^-)</script><p>如果说拉普拉斯变换要求支集在$[0,\infty)$，那么这个式子不应该存在后面减去的常数项，对于求解微分方程来说，处理因果信号，假设响应也是单边的，对响应的微分也是单边的，那么确实可以对两边进行拉普拉斯变换，而且解出的解应当是特解，而零输入响应就是线性齐次微分方程的解，它是”自然存在的响应，不会被消除”，它不是某个信号造成的响应，因此对函数左半边极限的描述可以适用于此，早就了上述式子这样的一个语法糖</p>
]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>数字信号相关</category>
      </categories>
  </entry>
  <entry>
    <title>微分流形公式整理</title>
    <url>/posts/7391c17b.html</url>
    <content><![CDATA[<h1 id="微分流形公式整理"><a href="#微分流形公式整理" class="headerlink" title="微分流形公式整理"></a>微分流形公式整理</h1><p>其实一开始学微分流形就是单纯认为高等数学定义的积分模型实在是有点丑，想找更统一的公式去表达，但也没想到就这么稀里糊涂的学了不少东西，不过，确实也给我窥见了<strong>大一统的美丽</strong>。<br>在这里记录下一些重要定义和重要公式吧。</p>
<hr>
<p><strong>免责声明</strong>：不保证摘录的是完全正确的，自用，请<strong>谨慎阅览</strong></p>
<hr>
<span id="more"></span>
<h2 id="张量积"><a href="#张量积" class="headerlink" title="张量积"></a>张量积</h2><p>张量积的定义：</p>
<script type="math/tex; mode=display">\alpha \otimes \beta (v,w)=\alpha(v) \cdot \beta (w)</script><p>可以看到整个这个的定义和乘法几乎也没什么多大的区别，不过是符号用的奇特了些</p>
<p>张量积的结合律：</p>
<script type="math/tex; mode=display">(U\otimes V)\otimes W \cong U\otimes (V\otimes W)</script><p>张量积的分配律：</p>
<script type="math/tex; mode=display">U\otimes (V\oplus W)\cong (U\otimes V)\oplus (U\otimes W)</script><p>张量积的交换律：</p>
<script type="math/tex; mode=display">U\otimes V\cong V\otimes U</script><p>向量与张量积的结合：</p>
<script type="math/tex; mode=display">U\otimes (V\otimes W)\cong (U\otimes V)\otimes W \cong U\otimes V\otimes W</script><p>张量积的对偶：设$U$和$V$是有限维向量空间，${u_i}$和${v_j}$分别是$U$和$V$的一组基，则$u_i\otimes v_j$构成了$U\otimes V$的一组基，同时也可以证明$\mathrm{Hom}(U\otimes V, \mathbb{R})\cong \mathrm{Bil}(U,V)$，即$U\otimes V$的对偶空间和$U$和$V$的双线性函数空间同构。</p>
<p>由定义可得($C$为常数，<strong>0-tenser</strong>，等号右边的运算符是乘积)</p>
<script type="math/tex; mode=display">C\otimes V=CV</script><h2 id="楔积"><a href="#楔积" class="headerlink" title="楔积"></a>楔积</h2><p>对于任意$f\in A_k(V)$，$g\in A_l(V)$，定义楔积如下</p>
<script type="math/tex; mode=display">
\alpha\wedge\beta:= \frac{1}{k!l!}A(\alpha\otimes\beta)</script><p>楔积有如下的<strong>运算性质</strong><br>设$f\in A_k(V)$，$g\in A_l(V)$，$h\in A_m(V)$</p>
<ul>
<li>楔积$\wedge$关于$f$和$g$是双线性的</li>
<li>对于任意常数$c$，有$c\wedge f=cf$</li>
<li>反交换性：$f\wedge g=(-1)^{kl}g\wedge f$</li>
<li>结合性：$(f\wedge g)\wedge h=f\wedge (g\wedge h)$</li>
</ul>
<p>同理如果$f$为常数$c$，$c\wedge g = cg$</p>
<h2 id="切映射"><a href="#切映射" class="headerlink" title="切映射"></a>切映射</h2><p>在光滑流形$M$中取点$x_0$的局部坐标系$(U;x^i)$，在光滑流形$N$中取点$\varphi(x_0)$的局部坐标系$(V;y^a)$，则光滑映射$\varphi :M\to N$在局部上可表示为</p>
<script type="math/tex; mode=display">y^a=y^a(x^1,x^2,\cdots,x^m)</script><p>其中$y^a(x^1,x^2,\cdots,x^m)$是定义在$U\cap\varphi^{-1}\left(V\right)$上的光滑函数，在切空间$T_{x_0}M$和$T_{\varphi(x_0)}N$中分别有自然基底$\{\frac{\partial}{\partial x^i}\}$和$\{\frac{\partial}{\partial y^a}\}$，设</p>
<script type="math/tex; mode=display">\varphi_{* x_{0}}\left(\frac{\partial}{\partial x^{i}}\right)=\sum_{a=1}^{n}A_{a}^{i}\frac{\partial}{\partial y^{a}}</script><p>让上式两边都作用在坐标函数$y^\beta$上，得到</p>
<script type="math/tex; mode=display">A_{i}^{\beta}=\left(\varphi_{\circ x_{0}}\left(\frac{\partial}{\partial x^{i}}\right)\right)y^{\beta}\\ =\frac{\partial}{\partial x^{i}}\left(y^{\beta}\circ\varphi\right)\\ =\frac{\partial y^{\beta}\left(x^{i}\cdot\cdots\cdot x^{m}\right)}{\partial x^{i}}</script><p>其中$T_{x_0}M$中不同的自然基底之间的关系可以看作从光滑流形$M$到自身的恒通映射在点$x_0$的切映射(仍然是恒同映射)在这两个自然基底下的表示。设$(U,\varphi)$，$(V,\psi)$是光滑流形$M$在点$x_0$的两个容许坐标卡，记</p>
<script type="math/tex; mode=display">x^{i}\left(p\right)=\left(\varphi\left(p\right)\right)^{i},y^{i}\left(p\right)=\left(\varphi\left(p\right)\right)^{i},\forall p\in U\cap V</script><p>由上方式子得到</p>
<script type="math/tex; mode=display">\frac{\partial}{\partial y^{i}}=\left(i d\right)_*\left(\frac{\partial}{\partial y^{i}}\right)\\=\sum_{j=1}^{m}A^j_i \frac{\partial}{\partial x^j}</script><p>其中</p>
<script type="math/tex; mode=display">A_{i}^{j}=\frac{\partial x^{j}\left(y^{i}\cdot\cdots\cdot y^{m}\right)}{\partial y^{i}}|_{\psi(x_0)}</script><p>(《微分流形初步》p77)</p>
<h2 id="Christoffel符号"><a href="#Christoffel符号" class="headerlink" title="Christoffel符号"></a>Christoffel符号</h2><p>定义式如下</p>
<script type="math/tex; mode=display">\Gamma_{i j}^{k}=\frac{1}{2}g^{k l}\left(\frac{\partial g_{l j}}{\partial x^{i}}+\frac{\partial g_{i l}}{\partial x^{j}}-\frac{\partial g_{i j}}{\partial x^{l}}\right)</script><h2 id="度量张量场"><a href="#度量张量场" class="headerlink" title="度量张量场"></a>度量张量场</h2><p>光滑流形$M$上任意一个对称、正定的光滑2阶协变张量称为$M$上的一个黎曼结构，若在$M$上指定一个黎曼结构，及则称$(M,g)$为一个黎曼流形，此时称$g$为黎曼流形$M$上的基本张量场，或度规张量场</p>
<script type="math/tex; mode=display">
g_{ij}=g(\frac{\partial}{\partial x^i},\frac{\partial}{\partial x^j})</script><p>欧式空间自带一个自然的度规张量场，为一个单位矩阵，并且$g$为欧式内积</p>
<h2 id="积分的定义"><a href="#积分的定义" class="headerlink" title="积分的定义"></a>积分的定义</h2><p>设$M$是满足第二可数公理$m$维有向光滑流形，则对于任意的有紧致支撑集的$m$次外微分式$\omega$，取$M$的<strong>定向相符</strong>的坐标卡集$\{(U_a,\varphi_a)\}$使得$\{U_a\}$构成$M$的局部有限开覆盖，因此在$M$上有从属于$\{U_a\}$的单位分解$\{h_a\}$，故$Supph_{a}\subset U_{a}$，$h_{a}\in C\left(M\right)$，$h_{a}\geq0$，$\sum h_{a}=1$，在$M$上的积分定义如下</p>
<script type="math/tex; mode=display">
\begin{aligned}\int_{a_{1}}\omega&=\int_{a_{1}}h_{a}\cdot\omega=\sum_{a_{1}}\int_{a_{1}}^{}h_{a}\cdot\omega\\&=\sum_{a_{1}}\int_{a_{2}}^{i}\left(\left(h_{a}\cdot a_{a}\right)\cdot\varphi_{a}^{-1}\right)d x_{a}^{1}\cdots d x_{a}^{n}\end{aligned}</script><p>这里单位分解既是用一种巧妙的方法把函数分割到每个开集中，让他们在各自的局部坐标系里进行运算，最终得到结果的方法。<br>注意这里微分形式后面的${x^i}$是有顺序的，只有在顺序与<strong>定向完全相同</strong>的时候才是<strong>n重积分</strong>，才能进行计算，如果顺序和定向反了，需要把顺序调换回来，这才是<strong>符号的来源</strong>，其实和顺序无关</p>
<h2 id="长度元素"><a href="#长度元素" class="headerlink" title="长度元素"></a>长度元素</h2><p>在实际计算时，可以使用给定的局部坐标系下的度量分量来计算 $ds$，即</p>
<script type="math/tex; mode=display">ds=\sqrt{g_{ij}dx^i dx^j}</script><p>注意，$ds$原本的定义为</p>
<script type="math/tex; mode=display">ds^2=g_{ij}dx^i dx^j</script><p>注意这里隐藏的符号是张量积，显然要想求得$ds$，左右两式要同时代入相同的$v$，即</p>
<script type="math/tex; mode=display">ds^2(v,v)=g_{ij}dx^i dx^j(v,v)</script><p>在此基础上</p>
<script type="math/tex; mode=display">\begin{aligned}ds(v)&=\sqrt{g_{ij}dx^i dx^j}(v)\\&=\sqrt{(g_{ij}dx^i dx^j)(v,v)}\\&=\sqrt{g_{ij}dx^i(v) dx^j(v)}\end{aligned}</script><p>看上去根号就像有了，把一个参数变为两个参数的功能<br>由于张量积的定义上和乘积也没什么多大区别，所以类似欧氏空间当中的弧微分也就可以做到提出一个$dt$，凑出积分式子进行运算了</p>
<script type="math/tex; mode=display">ds=\sqrt{dx^2+dy^2}=\sqrt{1+\frac{dy^2}{dx^2}}dx=\sqrt{1+{y'}^2}dx</script><h2 id="体积元素"><a href="#体积元素" class="headerlink" title="体积元素"></a>体积元素</h2><p>设$(M,g)$是$n$维有向的黎曼流形，$(U;x^i)$是$M$的定向相符的局部坐标系，记</p>
<script type="math/tex; mode=display">g_{ij}=g(\frac{\partial}{\partial x^i},\frac{\partial}{\partial x^j})</script><p>则</p>
<script type="math/tex; mode=display">\Omega=\sqrt{G}dx^1\wedge\cdots\wedge dx^n</script><p>是在$M$上大范围定义的$n$次外微分式，其中$G=det(g_{ij})$。很明显，$\Omega$处处不为零，称为黎曼流形$(M,g)$的<strong>体积元素</strong></p>
<h2 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h2><p>设$f\in C^{\infty}\left(M\right)$，则$df$是$M$上的1次微分式,下面这个式子称为光滑函数$f$的<strong>梯度场</strong>，是与$df$<strong>对偶</strong>的光滑切向量场</p>
<script type="math/tex; mode=display">\nabla f = g^{ij} \frac{\partial f}{\partial x^i} \frac{\partial}{\partial x^j}</script><h2 id="散度"><a href="#散度" class="headerlink" title="散度"></a>散度</h2><p>设切向量场$X$，$G=det(g_{ij})$，散度公式如下</p>
<script type="math/tex; mode=display">divX=\frac{1}{\sqrt{G}}\frac{\partial}{\partial x^i}(\sqrt{G}X^i)</script><h2 id="旋度"><a href="#旋度" class="headerlink" title="旋度"></a>旋度</h2><p>在三维流形上(旋度一般只能定义在三维流形上)，设切向量场$X$，$G=det(g_{ij})$，旋度计算公式如下</p>
<script type="math/tex; mode=display">curl X=\frac{1}{\sqrt{G}}\begin{vmatrix}e_1&e_2&e_3\\ \frac{\partial}{\partial u^1}&\frac{\partial}{\partial u^2}&\frac{\partial}{\partial u^3}\\ X_1&X_2&X_3\end{vmatrix}\\=\frac{1}{\sqrt{G}}\begin{vmatrix}e_1&e_2&e_3\\ \frac{\partial}{\partial u^1}&\frac{\partial}{\partial u^2}&\frac{\partial}{\partial u^3}\\ g_{1j}X^1&g_{2j}X^2&g_{3j}X^3\end{vmatrix}</script><p>注意这里的$e^i$并非是<strong>单位</strong>的正交基，而是曲线坐标系里的$\{\frac{\partial}{\partial u^1}\}$但由于与下面的微分算子的记号相同，所以就写成$e^i$的格式<br>正是因为如此，所以真正计算时，要注意给出的向量场要<strong>先化为标准的形式</strong>再进行计算，这<strong>非常重要</strong></p>
<p>如果要计算二维下的旋度，计算公式如下</p>
<script type="math/tex; mode=display">curlX=\frac{1}{\sqrt{G}}(\frac{\partial g_{1j}X^1}{\partial u^1}-\frac{\partial g_{2j}X^2}{\partial u^2})</script><p>其实旋度还可以使用<strong>hodge星算子和外微分算子</strong>定义为</p>
<script type="math/tex; mode=display">curl X = (\star dX^\flat)^\sharp</script><p>这等价于上面推导出来的公式，同时从这里可以看出，三维旋度有意义，二维旋度好歹也能算个标量场，四维及以上这<strong>定义就不太好耍</strong>了，干脆就放弃定义吧(乐)</p>
<h2 id="Stokes公式"><a href="#Stokes公式" class="headerlink" title="Stokes公式"></a>Stokes公式</h2><p>对于 $n$ 维微分流形 $M$ ，$\Omega\subset M$ ，$\partial\Omega$ 是一个 $n-1$ 维微分流形，为 $M$ 的<strong>边界</strong>，其定向是$M$诱导的stokes定向，$\omega$ 为 $(n-1)$ -形式，$d\omega$ 为 $n$ -形式，可得</p>
<script type="math/tex; mode=display">\int_{\partial \Omega}\omega=\int_{\Omega}d\omega</script><h2 id="协变微分"><a href="#协变微分" class="headerlink" title="协变微分"></a>协变微分</h2><p>设$(M,g)$是一个$m$维黎曼流形，$v\in\mathscr{X}\left(M\right)$。在局部坐标系$(U;x^i)$下，设$v|_{v}=v^{i}\frac{\partial}{\partial x^{i}}$，命</p>
<script type="math/tex; mode=display">D v|_{U}=D v^{i}\otimes\frac{\partial}{\partial x^{i}}=\left(\frac{\partial v^{i}}{\partial x^{k}}+v^{i}\Gamma_{i k}^{i}\right)d x^{k}\otimes\frac{\partial}{\partial x^{i}},</script><p>则$D v$是在光滑流形$M$上大范围定义的$(1,1)$型光滑张量场，称为光滑切向量场$v$的<strong>协变微分</strong>。映射$D:\mathscr{X}\left(M\right)\rightarrow \mathscr{X}\left(M\right)$称为<strong>协变微分算子</strong><br>这个是欧式空间中全微分在流形上的版本，也就是说欧氏空间中的全微分是流形上的协变微分的特例。即可以完全把$d\overrightarrow{F}$看成是$D\overrightarrow{F}$，把$\frac{\partial\overrightarrow{F}}{\partial x^i}$看成是$D\overrightarrow{F}$的分量</p>
<h2 id="协变导数"><a href="#协变导数" class="headerlink" title="协变导数"></a>协变导数</h2><p>设$(M,g)$是一个$m$维黎曼流形，$v\in\mathscr{X}\left(M\right)$，$X\in T_pM$，则下式所定义的$D_Xv\in T_pM$称为光滑切向量场$v$关于切向量$X\in T_pM$的<strong>协变导数</strong></p>
<script type="math/tex; mode=display">D_{X}v=X^{k}\left(\frac{\partial v^{i}}{\partial x^{k}}+v^{j}\Gamma_{j k}^{i}\right)\frac{\partial}{\partial x^{i}}</script><p>这个是欧式空间中方向导数在流形上的版本，也就是说欧氏空间中的方向导数(偏导数)是流形上的协变微分的特例。</p>
<p>在 $ds = g_{ij} dx^i dx^j$ 中，$dx^i$ 和 $dx^j$ 之间的运算符是乘号 $\times$，表示 $dx^i$ 与 $dx^j$ 的乘积。这个乘法是指张量积，也就是向量的张量积。这个式子相当于对两个一阶协变张量 $dx^i$ 和 $dx^j$ 进行张量积得到一个二阶张量 $dx^i \otimes dx^j$，然后与度量张量 $g_{ij}$ 进行收缩。</p>
<h2 id="写这篇整理时遇到的各种问题"><a href="#写这篇整理时遇到的各种问题" class="headerlink" title="写这篇整理时遇到的各种问题"></a>写这篇整理时遇到的各种问题</h2><p>到目前为止(2023.4.11)，基本的公式已经整理完成，接下来就是碰见实际例子时候的具体问题具体分析了</p>
<h3 id="纠结动量定理是不是向量场的积分"><a href="#纠结动量定理是不是向量场的积分" class="headerlink" title="纠结动量定理是不是向量场的积分"></a>纠结动量定理是不是向量场的积分</h3><p>其实动量定理更本质应该是微分形式，写成积分形式纯粹是约定了欧式空间。其实最终形成了一个微分方程。</p>
<script type="math/tex; mode=display">\overrightarrow{F}=\frac{d\overrightarrow{I}}{dt}</script><p>可以看到这个式子右端最终结果是一个向量场，左端也是向量场，最终等式成为恒等式，只要取两端向量分量恒等就可以得到最终结果啦<br>确实可以反过来定义对于协变微分的逆运算，但是由于我们暂时用到的协变微分只定义了对向量场的微分，所以只是把协变位置高了一位，所以按照我们现在的知识，只能利用上面这种方法定义向量场的路径积分，所以换而言之，这些积分的全部可以用单一元替换，变成$dt$，进而两边对$t$求导，得到我们想要的微分式，也就类似上面的动量定理，且只有这种对向量场积分的形式，这样原本的积分式也不过就是微分式的额外拓展罢了</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/posts/a444b428.html</url>
    <content><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序算法是最经典的算法知识。其实现代码短，应用广<br>如下是几种常见的排序算法：冒泡排序、选择排序、插入排序、归并排序、快速排序、希尔排序、堆排序、计数排序、桶排序、基数排序</p>
<span id="more"></span>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//应用二分思想</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid=a[(l+r)/<span class="number">2</span>];<span class="comment">//中间数</span></span><br><span class="line">    <span class="type">int</span> i=l,j=r;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(a[i]&lt;mid) i++;<span class="comment">//查找左半部分比中间数大的数</span></span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;mid) j--;<span class="comment">//查找右半部分比中间数小的数</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;=j)<span class="comment">//如果有一组不满足排序条件（左小右大）的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(a[i],a[j]);<span class="comment">//交换</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(i&lt;=j);<span class="comment">//这里注意要有=</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;j) <span class="built_in">qsort</span>(l,j);<span class="comment">//递归搜索左半部分</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;r) <span class="built_in">qsort</span>(i,r);<span class="comment">//递归搜索右半部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>DSA</category>
      </categories>
  </entry>
  <entry>
    <title>数学实验综合练习</title>
    <url>/posts/93a8bfd0.html</url>
    <content><![CDATA[<h1 id="数学实验综合练习"><a href="#数学实验综合练习" class="headerlink" title="数学实验综合练习"></a>数学实验综合练习</h1><p>这里是我大一数学实验课的综合练习一的题解</p>
<h2 id="题目-新冠疫情预测"><a href="#题目-新冠疫情预测" class="headerlink" title="题目_新冠疫情预测"></a>题目_新冠疫情预测</h2><p>搜集全球新冠疫情的数据，选择全球数据或者某一个国家的数据，研究数据的<strong>函数类型</strong>，根据全球或者某一国家截止2022年5月底的数据，预测全球(或者该国家)感染的<strong>最终规模</strong>，判断全球(或者该国家)疫情何时结束。</p>
<span id="more"></span>
<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><p>我们小组将课题定为对全球新冠疫情的预测。小组将统计范围放在全球，以便对新冠疫情的分析更具全局性和准确性。实验主要分为三个步骤，首先由小组成员ds进行全球新冠疫情数据的收集整理和汇总，将其交由成员zxy，根据收集的数据研究分析其函数类型，并以此预测全球感染的最终规模和结束时间，最后由成员cj将本次实验过程、结果总结并撰写为报告。</p>
<h2 id="数据搜集阶段"><a href="#数据搜集阶段" class="headerlink" title="数据搜集阶段"></a>数据搜集阶段</h2><p>对于全球疫情数据的收集，由于数据的庞大及专业性，显然难以以线下的调查或者查阅资料获得，所以小组将目光投向网络。根据实验要求，所需的数据是全球范围内截止2022年5月的疫情病例人数。小组划定起始时间为2020年1月，以月为单位，收集了29个月的新冠感染数据。我们小组采用以ChatGPT收集数据为准。整理合并制作出数据表格，如下图<br><img src="/images/数学实验综合练习_图1.png" width="100%" height="100%"></p>
<h2 id="数据分析及疫情预测阶段"><a href="#数据分析及疫情预测阶段" class="headerlink" title="数据分析及疫情预测阶段"></a>数据分析及疫情预测阶段</h2><p>根据收集的全球病例数据，通过Matlab制作出了散点图，如下<br><img src="/images/数学实验综合练习_图2.png" width="70%" height="70%"><br>由图可见，感染总数从初始阶段开始便<strong>猛增</strong>，增长速率也在加快，而后半段呈现<strong>类线性的缓慢上升</strong>，显然这不符合书本上已给出的数学模型。经小组思考和讨论后，决定将其分为两段分别研究。<br>前半部分是J型曲线模型<br>模型公式如下</p>
<script type="math/tex; mode=display">
N(t)=N_0(1+e^{kt})</script><p><img src="/images/数学实验综合练习_图3.png" width="70%" height="70%"><br>代码如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line">y=[<span class="number">0.09</span>,<span class="number">0.85</span>,<span class="number">86.74</span>,<span class="number">682.41</span>,<span class="number">1795.69</span>,<span class="number">2717.62</span>,<span class="number">4174.10</span>,<span class="number">6735.730</span>,<span class="number">10001.90</span>...</span><br><span class="line">,<span class="number">12581.53</span>,<span class="number">16234.30</span>,<span class="number">20174.37</span>,<span class="number">22554.55</span>];</span><br><span class="line">x=<span class="number">1</span>:<span class="built_in">length</span>(y);</span><br><span class="line">a=[<span class="number">500</span>,<span class="number">2</span>];</span><br><span class="line">f = @(a,x)a(<span class="number">1</span>)*(<span class="number">1</span>+<span class="built_in">exp</span>(a(<span class="number">2</span>)*x));</span><br><span class="line">[A,resnorm] = lsqcurvefit(f,a,x,y);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">X=<span class="number">1</span>:<span class="number">13</span>;</span><br><span class="line">Y=A(<span class="number">1</span>).*(<span class="number">1</span>+<span class="built_in">exp</span>(A(<span class="number">2</span>)*X));</span><br><span class="line"><span class="built_in">plot</span>(X,Y,<span class="string">&#x27;r-&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p>后半部分为logist模型<br>模型公式如下</p>
<script type="math/tex; mode=display">
N(t)=\frac{c}{1+ae^{kt}}</script><p><img src="/images/数学实验综合练习_图4.png" width="70%" height="70%"><br>代码如下</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">clc;clear;</span><br><span class="line">y=[<span class="number">22911.44</span>,<span class="number">23250.81</span>,<span class="number">23594.19</span>,<span class="number">23923.71</span>,<span class="number">24156.30</span>,<span class="number">24395.02</span>,<span class="number">24703.13</span>...</span><br><span class="line">,<span class="number">25000.68</span>,<span class="number">25211.07</span>,<span class="number">25519.78</span>,<span class="number">25768.44</span>,<span class="number">25941.22</span>,<span class="number">26241.14</span>,<span class="number">26526.19</span>,<span class="number">26799.18</span>,<span class="number">27099.82</span>];</span><br><span class="line">x=<span class="number">1</span>:<span class="built_in">length</span>(y);</span><br><span class="line">a=[<span class="number">5000</span>,<span class="number">100</span>,<span class="number">1</span>];</span><br><span class="line">f = @(a,x)a(<span class="number">1</span>)./(<span class="number">1</span>+a(<span class="number">2</span>)*<span class="built_in">exp</span>(-a(<span class="number">3</span>)*x));</span><br><span class="line">[A,resnorm] = lsqcurvefit(f,a,x,(y<span class="number">-22911</span>));</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;b*&#x27;</span>);</span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line">X=<span class="number">1</span>:<span class="number">40</span>;</span><br><span class="line">Y=A(<span class="number">1</span>)./(<span class="number">1</span>+A(<span class="number">2</span>)*<span class="built_in">exp</span>(-A(<span class="number">3</span>)*X))+<span class="number">22911</span>;</span><br><span class="line"><span class="built_in">plot</span>(X,Y,<span class="string">&#x27;r-&#x27;</span>);</span><br><span class="line">grid on;</span><br></pre></td></tr></table></figure>
<p>分别利用lsqcurvefit拟合非线性函数，最终得到前者的系数组成的数组A为</p>
<script type="math/tex; mode=display">
A = \quad 1.0e+03\quad * \quad [4.4978 \quad 0.0128 \quad 0.0003]</script><p>后者的系数组成的数组A为</p>
<script type="math/tex; mode=display">
A = [576.7970 \quad 0.2883]</script><p>经小组共同研究，发现主要是前半段的模型与logist模型差异较大，观察其图形，与物种增长的<strong>J型曲线</strong>极为相似。小组推测出现这种曲线的原因是，新冠病毒爆发的初期，大多国家并没有采取有效的控制措施，对抗病毒的药物或是疫苗任然处于研制当中，此时的新冠病毒就处于没有任何威胁的环境中，因而其增长曲线与J型极为类似，而与logist模型相悖。</p>
<p>由后半段的拟合曲线图可看出，感染人数的变化趋势与书本上所给例子有相似之处。两段曲线的分界点为2021年12月，小组判断在此时疫情已经得到了一定的控制，同时病毒的致病能力也会有所下降，从而逐渐符合<strong>logist模型</strong>。</p>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>根据拟合模型预估(即第四张图中 X:28，Y:27350)，全球疫情将持续长达<strong>4年</strong>左右，最终感染规模为<strong>2.74亿人</strong>，预计在<strong>2023年5月</strong>彻底结束。</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Math_modeling</category>
      </categories>
  </entry>
  <entry>
    <title>日常困惑之梯度的换元</title>
    <url>/posts/10d711a6.html</url>
    <content><![CDATA[<h1 id="日常困惑之梯度的换元"><a href="#日常困惑之梯度的换元" class="headerlink" title="日常困惑之梯度的换元"></a>日常困惑之梯度的换元</h1><p>又是上物理课的突发奇想，造就了一些关于梯度的疑惑<br><span id="more"></span></p>
<hr>
<h2 id="疑惑来源"><a href="#疑惑来源" class="headerlink" title="疑惑来源"></a>疑惑来源</h2><p>首先我们考察在平面上的万有引力公式，在$ \mathbb{R^2} $上其实是一个向量场(vector field)，即在$ \mathbb{R^2} $上的每一个点都有一个向量与之一一对应。</p>
<script type="math/tex; mode=display">F = G\frac{Mm}{R^2}</script><p>而引力势能，其实就是这个向量场所对应的标量场，也即</p>
<script type="math/tex; mode=display">E_A=-G\frac{Mm}{R}</script><p>我们知道，对标量场求梯度可以得到向量场(梯度的几何意义就是等高线嘛)，但是课本上的梯度公式可是基于笛卡尔坐标系的，而我发现对引力势能对极坐标系下求梯度也能得到万有引力公式，那是不是说梯度满足以下的式子呢</p>
<script type="math/tex; mode=display">
\begin{cases}
    \nabla y=\frac{\partial \psi}{\partial x_1} \overrightarrow{x_1}+\frac{\partial \psi}{\partial x_2}\overrightarrow{x_2} \\
    \nabla y=\frac{\partial \phi}{\partial z_1} \overrightarrow{z_1}+\frac{\partial \phi}{\partial z_2}\overrightarrow{z_2}
\end{cases}</script><p>其中$\phi $,$ \psi $是同一个标量场在不同坐标系下的表达式，事实上，这个公式<strong>并不成立</strong></p>
<hr>
<h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>在任意坐标系下，梯度算符的表达式应该是：</p>
<p>$\nabla f = g^{ij} \frac{\partial f}{\partial x^i} \frac{\partial}{\partial x^j}$</p>
<p>其中 $g^{ij}$ 表示<strong>度规张量的逆矩阵</strong>。</p>
<p>在笛卡尔坐标系下，度规张量为单位矩阵，逆矩阵也是单位矩阵，因此 $g^{ij}$ 等于 $\delta_{ij}$，其中 $\delta_{ij}$ 表示克罗内克符号，它在 $i=j$ 时等于 1，在 $i\neq j$ 时等于 0，因此在笛卡尔坐标系下的梯度算符表达式就简化为了：</p>
<p>$\nabla f = \frac{\partial f}{\partial x^i} \frac{\partial}{\partial x^i}$</p>
<p>而在其他坐标系下，$g^{ij}$ 的值会发生变化，因此梯度算符的表达式也会有所不同</p>
<h2 id="关于度规的公式"><a href="#关于度规的公式" class="headerlink" title="关于度规的公式"></a>关于度规的公式</h2><script type="math/tex; mode=display">
g_{i j}=\langle r_{i},r_{j}\rangle=\sum_{k=1}^{n}\frac{\partial f^{k}}{\partial u^{i}}\frac{\partial f^{k}}{\partial u^{j}}.</script><p>其中$ x^{i}=f^{i}\left(u^{1},\cdots,u^{n}\right),1\leq i\leq n $，其中$ x^{i} $为单位正交标架，$ u^{i} $是曲纹坐标系诱导的自然标架</p>
<p>做一些个人的总结把，对于一个空间来说，度规是空间的属性，和空间里选取怎样的坐标系无关，不同的坐标系下度规是不同的，但是空间的属性是确定的，单位正交标架是欧氏空间中自然的产物，度规在这个参考系下就是单位矩阵，其它的坐标系便是在这个基础上转化而来的，要想研究例如四维时空下的坐标系，也需要找到一个最初的参考系，使得其它的坐标系能转化，不然度规就是一个游离在量化计算之外的数值，无法被具体化，毕竟参考系与参考系之间的关系也必须是比较得到的嘛</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先我们要知道我们现在研究的空间都是欧氏空间，而在欧式空间上取得一个坐标系，其中最基础最自然的就是笛卡尔坐标系<br>对于这样的一个流形来说，在一个<strong>区域</strong>内，我们可以选取到一个自然标架，自然标架构成<strong>分布在区域上</strong>的一个标架“场”<br>这样的标架是$ u^i $-曲线，即让$ u^i $变动，其余的不变所得到的曲线的<strong>切向量</strong>，这是本质，并且这样的切向量的长度如果嵌入欧式空间其实<strong>并不一定是1</strong>，需要除以其本身的长度才可以得到单位向量的长度，即<script type="math/tex">\overrightarrow{x_i}=\frac{1}{\sqrt{g_{ii}}}\frac{\partial}{\partial x_i}</script></p>
<h2 id="任意坐标系下的基向量"><a href="#任意坐标系下的基向量" class="headerlink" title="任意坐标系下的基向量"></a>任意坐标系下的基向量</h2><p>根据微分流形当中的知识可知，这样的切向量也是在欧式空间里的单位向量，是写成$\{\frac{\partial}{\partial x^1},\cdots,\frac{\partial}{\partial x^n}\}$这样的形式的，而这样<strong>偏导数的形式</strong>，我们自然就可以使用<strong>链式法则</strong>来进行单位向量的转化<br>如笛卡尔坐标系为极坐标系，求极坐标系下的单位向量，即:</p>
<script type="math/tex; mode=display">
 \begin{cases} 
    \frac{\partial}{\partial r} =\frac{\partial x}{\partial r}\frac{\partial}{\partial x} + \frac{\partial y}{\partial r}\frac{\partial}{\partial y} \\
    \frac{\partial}{\partial \theta} =\frac{\partial x}{\partial \theta}\frac{\partial}{\partial x} + \frac{\partial y}{\partial \theta}\frac{\partial}{\partial y} \end{cases}</script><p>或者换成向量的写法</p>
<script type="math/tex; mode=display">
 \begin{cases} 
    \overrightarrow{r_0}=\frac{\partial x}{\partial r}\overrightarrow{x_0} + \frac{\partial y}{\partial r}\overrightarrow{y_0} \\
    \overrightarrow{\theta_0}=\frac{\partial x}{\partial \theta}\overrightarrow{x_0} + \frac{\partial y}{\partial \theta}\overrightarrow{y_0} \end{cases}</script><p>这个式子也可以利用另外的方法进行证明，比如在同样的欧氏空间，取不同的坐标系，可以得到两个坐标函数(即输入两个数字，输出在空间上面对应的一个点)。<br>有这样的定义，坐标函数对$ x_i $求偏导，即是坐标分量</p>
<script type="math/tex; mode=display">
f(x,y)=x=g(p(x,y),\theta(x,y))</script><p>这里的$f$,$g$都是坐标函数，对等式两边求偏导并利用链式法则就可以得到上面的式子</p>
<p>那么把等式代入一开始的错误预期的一式，在处理$ \overrightarrow{\rho_0} $的时候就出现了问题</p>
<script type="math/tex; mode=display">
\frac{\partial\varphi}{\partial\rho}\frac{\partial\rho}{\partial x}\frac{\partial\rho}{\partial x}+\frac{\partial\varphi}{\partial\theta}\frac{\partial\theta}{\partial x}\frac{\partial\rho}{\partial x}+\frac{\partial\varphi}{\partial\rho}\frac{\partial\rho}{\partial y}\frac{\partial\rho}{\partial y}+\frac{\partial\varphi}{\partial\theta}\frac{\partial\theta}{\partial y}\frac{\partial\rho}{\partial y}\stackrel{?}{=}\frac{\partial\varphi}{\partial \rho}</script><p>好嘛，这根本就不等嘛，其实经过一次的<strong>合并同类项</strong>，会发现其中有好几项看起来像内积，仔细一看这不就是度规的分量嘛，于是就得到了上面说的那个用度规表达的形式啦</p>
<p>合并同类项如下</p>
<script type="math/tex; mode=display">
\frac{\partial\varphi}{\partial\rho}(\frac{\partial\rho}{\partial x}\frac{\partial\rho}{\partial x}+\frac{\partial\rho}{\partial y}\frac{\partial\rho}{\partial y})+\frac{\partial\varphi}{\partial\theta}(\frac{\partial\theta}{\partial x}\frac{\partial\rho}{\partial x}+\frac{\partial\theta}{\partial y}\frac{\partial\rho}{\partial y})</script><h2 id="对单位向量在标架上的导数"><a href="#对单位向量在标架上的导数" class="headerlink" title="对单位向量在标架上的导数"></a>对单位向量在标架上的导数</h2><p>这也是困惑我许久的问题，为什么极坐标的单位向量可以被$ r $求导，我发现自然标架完全不同，要想计算自然标架沿着坐标曲线的微商其实是很重要的<br>由于切向量关于坐标曲线的导数还是区域上的向量场，故可以待定系数设</p>
<script type="math/tex; mode=display">
\frac{\partial r_{i}}{\partial u^{l}}=\sum_{k=1}^{n}\Gamma_{il}^{k}r_{k}</script><p>已知($*$式)</p>
<script type="math/tex; mode=display">
g_{i j}=\langle r_{i},r_{j}\rangle=\sum_{k=1}^{n}\frac{\partial f^{k}}{\partial u^{i}}\frac{\partial f^{k}}{\partial u^{j}}.</script><p>由此可得</p>
<script type="math/tex; mode=display">
\langle\frac{\partial r_{i}}{\partial u^{i}},r_{j}\rangle=\sum_{k=1}^{n}\Gamma_{il}^{k}g_{k j}</script><p>因为</p>
<script type="math/tex; mode=display">
\frac{\partial r_{i}}{\partial u^{i}}=\frac{\partial r_{i}}{\partial u^{i}}=\frac{\partial^{2}r}{\partial u^{i}\partial u^{i}}=\sum_{k=1}^{n}\frac{\partial^{2}f^{k}}{\partial u^{i}\partial u^{i}}\partial_{k}</script><p>所以</p>
<script type="math/tex; mode=display">
\Gamma_{li}^k=\Gamma_{il}^k</script><p>对($*$式)求导得到</p>
<script type="math/tex; mode=display">
\frac{\partial g_{i}}{\partial u^{\prime}}=\sum_{i=1}^{n}\left\{\frac{\partial^{2}f^{k}}{\partial u^{i}\partial u^{l}}\frac{\partial f^{k}}{\partial u^{j}}+\frac{\partial f^{k}}{\partial u^{i}}\frac{\partial^{2}f^{k}}{\partial u^{j}\partial u^{l}}\right\}\\ =\left\langle\frac{\partial r_{i}}{\partial u^{l}}\cdot r_{j}\right\rangle+\left\langle r_{i},\frac{\partial r_{j}}{\partial u^{l}}\right\rangle\\=\Gamma_{i l}^{k}g_{k j}+\Gamma_{j l}^{k}g_{k i}</script><p>于是</p>
<script type="math/tex; mode=display">
\Gamma_{il}^{k}=\frac{1}{2}g^{k_{j}}\left(\frac{\partial g_{i j}}{\partial u^{i}}+\frac{\partial g_{j i}}{\partial u^{i}}-\frac{\partial g_{il}}{\partial u^{j}}\right)</script><p>$\Gamma^i_{jk}$ 称为Christoffel符号</p>
<p>所以以后，对区域$V$上的向量场，用自然标架场表示为</p>
<script type="math/tex; mode=display">v=\sum_{i=1}^{n}v^{i}r_{i}</script><p>那么</p>
<script type="math/tex; mode=display">\frac{\partial v}{\partial u^{l}}=\sum_{i=1}^{n}\left\{\frac{\partial v^{i}}{\partial u^{l}}r_{i}+v^{i}\frac{\partial r_{i}}{\partial u^{l}}\right\}\\=\sum_{i=1}^{n}\left\{\frac{\partial v^{i}}{\partial u^{l}}+\sum_{k=1}^{n}v^{k}\Gamma_{k l}^{i}\right\}r_{i}</script><p>也可以总结得到</p>
<script type="math/tex; mode=display">
dr_i=\sum_{l=1}^{n}(\sum_{k=1}^{n}\Gamma_{il}^{k}r_{k})du^l</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这玩意远远没有我想的那么简单，不过好在现在已经都清楚了，想了有一天左右吧，确实是很复杂<br>对于标量场的转化，只要把坐标的转换方程代入原式就可以改写标量场为新坐标系格式<br>如果是新坐标系的矢量场对就坐标系的坐标求导，可以灵活利用单位矢量的转换方程，把它转化为旧坐标系，算完再转化回去<br>举个例子，极坐标系下，速度是对位移的对t求导，里面会需要利用链式法则转换出对极坐标下坐标的求偏导<br>对于每一个用$n$个自由度来表示空间上一点，那一点都有诱导出的一个切向量，用那个切向量为标架可以求出很多东西，那个向量本身也有物理意义，而位矢，速度等其实是空间上的向量场，也是坐标系无关的，切换坐标系要用转化的式子做对应转化的，具体在下一次文章里会写到吧<br>$\partial\partial x_i$同时也是$\{xi\}$的函数<br>这些告诉我们，流形M上向量场在固定坐标系下的基有一个最基本的基，为$\frac{\partial}{\partial x_i}$，其他可以由这个线性组合得到<br>由此，对标量场求导，对矢量场求导，在另外的坐标系中对标量场求导，对矢量场求导这些全部统统可以利用坐标系间相互转换，单位矢量的转换，这样的转换可以把标量场和矢量场中字母和矢量完全转化为另一个参考系的，以便于导出所有相关的式子</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Analysis_theory</category>
      </categories>
  </entry>
  <entry>
    <title>日常碎碎念_1</title>
    <url>/posts/6b49fcb0.html</url>
    <content><![CDATA[<h1 id="日常碎碎念-1"><a href="#日常碎碎念-1" class="headerlink" title="日常碎碎念_1"></a>日常碎碎念_1</h1><p>日常碎碎念_1，日常碎碎念，生人勿进</p>
<span id="more"></span>
<ul>
<li>以后有什么想法全部发布在自己的Blog里啦，看到这些的大多都是很要好的朋友咯，像DaliyLife这个文件夹下的东西没有特殊原因几乎不会修改哦，发布日期就是当日的想法</li>
<li>今天总算把多元函数微积分搞到了一个满意的程度，把整个微分流形稍微过了一遍。买的书已经到手啦，《An Introduction to Manifolds》，但是全英文确实难啃，好在之前已经看过一本中文了。以后有个小梦想就是拥有自己的书架，上面摆着自己喜欢的书，从数理化到Coding，还有一些小说之类的</li>
<li>想要在一个下午，能透过阳光的窗边，拿着书，一杯咖啡，真好，但是有点太理想了</li>
<li>最近啥CS，EE都没学呢，怠惰了(其实不是，在学数学啦)</li>
<li>单片机稍微耍了耍，C51相比C语言添加的4个变量类型的语法好奇怪哦，有一种狗皮膏药的感觉(bushi)，应该是我太菜了QAQ</li>
<li>人和人的人际关系真是奇异</li>
<li>女生宿舍楼下不能多呆，要是除却有事之外应该走的远远的，狗粮会恰饱的，这对一个程序员(也许我还算不上)来说是莫大的打只因(楽)</li>
<li>后天要力学测验，有点小慌，找出了藏在文件夹里的高中力学竞赛书，发现自己看太少了根本没啥用HAHA</li>
<li>没了兴趣做不了课外的事情，因为是支线，不做也罢，但是如果主线是没兴趣的事情，那我定当Try my best</li>
</ul>
]]></content>
      <categories>
        <category>Life_生活</category>
      </categories>
  </entry>
  <entry>
    <title>日常碎碎念_2</title>
    <url>/posts/f52d6913.html</url>
    <content><![CDATA[<h1 id="日常碎碎念-2"><a href="#日常碎碎念-2" class="headerlink" title="日常碎碎念_2"></a>日常碎碎念_2</h1><p>日常碎碎念_2，日常碎碎念，生人勿进</p>
<span id="more"></span>
<p>记2023.1.19，一学期过完的回家路上，由于之前一直乘大巴，所以没去过南京南站，这次感受了一波南京南站的高铁，由此开启了一段时光倒流的路途。<br>要说整个过程也没什么，只是鬼使神差的坐完高铁回到市里，又去乘了公交，恰好那一路公交会经过我的高中母校和初中母校罢了。下车转了一辆公交，是曾经小学载我回家的那一路公交，顺带再经过我的幼儿园。挺感慨的，一次回家居然足以概括我的20年，最终回到我物理意义上因为寒冬不算特别温暖的小小的家。<br>旅途的意义是在路上的人赋予它的。经过高中的时候，我听见那个熟悉的学校名字，我几乎是条件反射式的抬头看上一眼，可惜雨天的傍晚天太暗，看不清什么，我知道那时候，里面还正在上课，可惜教学楼在学校的中间，从大门口看不见哪怕一丝光亮。和我朝夕相处的那些东西终究远去了，有意气风发，有自怨自艾，有暗生情愫，有埋头苦读。看起来现在都已经不重要了。在家乡的学习路，也随着离开这里彻底迈入终点站，我现在也不过只能回头撇一眼终点站，将理想国的信念置于其他人的梦想之上，继续下去寻找我自己而已。<br>下一站是我的初中，没想到恰逢初中放学，一群初中生涌上车，嗨，这是五年前的子弹击中了自己，我看到的都是曾经的我。还有一位小友对我说到”老哥，挤一挤”，不由分说把我从靠走道的座位挤到了靠窗的座位上。唉唉，我可是大你们起码五届的学长啊喂。该说不说，在我初中那堵车堵了半小时，有我当年回家的风范(悲)，现在的初中生比我当年中二，我的评价是，比我一带学生抽象。<br>遥想曾经听过2017年江苏卷高考语文有一道关于车的作文考题，想来不管当年有多少技巧与能力，心里的答卷也只有随着年龄的增长才能交出来吧。<br>(贴一张在社团的新年小祝福代表当前的精神状态)</p>
<p><img src="/images/日常碎碎念_2_图1.jpeg" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>Life_生活</category>
      </categories>
  </entry>
  <entry>
    <title>日常碎碎念_3</title>
    <url>/posts/85479d9c.html</url>
    <content><![CDATA[<h1 id="日常碎碎念-3"><a href="#日常碎碎念-3" class="headerlink" title="日常碎碎念_3"></a>日常碎碎念_3</h1><p>日常碎碎念_3，日常碎碎念，生人勿进</p>
<span id="more"></span>
<ul>
<li>重新整理了一下已经有的博客，标记了原本时间戳全部消失的文件，但是修改日期是回不来了</li>
<li>删除了原本有的加密功能，以及原本所有的加密博客，有的改成公开，有的直接删除了</li>
<li>打算把qblog这个工具重新改一改重写了，暂时这个博客就手动维护吧</li>
</ul>
<p><code>qblog.py</code> 这个说了好久的东西，咕咕咕了这么久也是终于搞定了，其实写一个脚本再正常不过了，我也没想到这个我居然因为这个东西停了这么久，可能是因为 bat 并不是一个很令人舒服的脚本吧，bash 要更舒服一点。不管怎么说，这下也可以继续愉快的写博客了</p>
<p>前段时间有同学找到我告诉我说，”我是看您博客长大的”，啊？这有点夸张了吧，其实我因为 qblog 以及 hexo 这个工具始终不合我心意，已经很少更新博客了，基本上只在 2022 年写的多一点，那时候我也才接触技术不久</p>
<p>不过我很感动的是，居然真的能有后人看我的博客，甚至能给他们带来一点点的作用，但是我好像确实也没写什么有用的东西啊喂</p>
<p>接下来也不知道能不能有空接着写下去，如果可以的话，一定会写出相对曾经更精彩的东西吧</p>
]]></content>
      <categories>
        <category>Life_生活</category>
      </categories>
  </entry>
  <entry>
    <title>日常碎碎念_4</title>
    <url>/posts/1b23083f.html</url>
    <content><![CDATA[<h1 id="日常碎碎念-4"><a href="#日常碎碎念-4" class="headerlink" title="日常碎碎念_4"></a>日常碎碎念_4</h1><p>好久没更新了，来写点近况吧</p>
<span id="more"></span>
<p>不知不觉，这个博客已经写了快三年了，近来看着学校里的毕业生在学校里各处采风，警觉自己成为下一个毕业离开的了，而更快的，在 20 天之后，我也要离开这个校区，前往另一个校区了。<br>正值高考时期，我写下这一篇文章，心情复杂。首先先祝高考的考生考试顺利，接着来谈我自己。写至此处，不得不做时常会做的事情，带着相同的心情重入当时的一段时光，我当时为什么做出了这样的选择，如果选择别的道路，比如换一个专业，换一个学校会不会有什么不同，但我的生命是完整的，即使无数次在梦里回到当时，我也会在纠结中做出相同的选择，所以我并没有后悔，只是感慨我们行走在昭昭天命之中。<br>又是一个三年，当我在与他人缔结关系，最终稳定的情况下，我又要回到孤身一人，说实话心里一定是有落差的。其中最舍不得的是最爱的社团(SAST)，社团到底给我带来了什么呢？在校的这段时间，基本上有很多的时间我都呆在社团，交友甚广，也全基于社团。作为技术社团的一员，我深知，如果不是我在这社团拥有了一席之地，大家也不会乐意来认识我。事实也确实，在自己的学院我并没有什么突出的地方，在自己的学院认识的同学很少，当我前往教室坐下，大概率也不会有人主动坐在我的旁边，有时候也会感到一丝落寞。而技术社团带给我的主要成长就是 CS/EE 技术上的进展，我所有的 CS 知识都来自于社团与自学，可以说社团直接影响了我的技术成长。在生活上，科协也帮到了我不少，还记得之前有一段时间肠胃不好，配了一些中药，在宿舍竟找不到一处能安防的，幸得社团有冰箱能放下，解我燃眉之急。<br>前些日子，看着社团里同届的同学一个接一个去往全国各地实习，越来越冷清的活动室终于还是让我按捺不住了，进行就业和考研之间的抉择是残酷的，在我思考了一个月后，最终得出的结论是，我无法在这两个选项中做出谁好谁坏的判断，但是我们必须做出抉择，于是我最终还是放不下我自己的爱好，自己在社团所学习的一切，抛开了我原本的专业，选择了在计算机行业就业。我不知道这个选择在未来是否正确，可就像是我在高考做出的不成熟的选择一样，无论重入多少回，我都会做出同样的选择。<br>社团见证了我面试的全过程，在此时此刻，我已经拿到了鹅厂的暑期实习 offer (WXG-移动端)，我个人认为这是非常幸运了，在我做出选择到准备面试到最后成功，我总共就只经过了一个月，就拿到了这样的一个机会，同期我还完成了期末考试，参与了另一个可以为我提供实习经历的项目。我的 5 月相当的充实。<br>有人说选择计算机挺好的，但我觉得并非，首先是家庭的道德阻力，计算机并不是一个稳定的职业，即使我能保证不停的学习新的东西，仍然会在年岁稍长的时候面临被辞退的风险，即使我自己能接受，家里也对此颇有微词，我是觉得其实人生最大的确定就是不确定，哪里来的稳定，况且很多时候，我们很难说清楚固执己见和坚定不移之间的差别吧。其次在当下社会里，对程序员的看法其实并没有那么正面，即使是在学校的社团里，我所在的群体也会被贴上不近人情，不懂风情的标签，即使说这些话的人有时候甚至都没见过我们，校内尚且如此，更别说在社会上是如何的了。我无法作为一个局外人来回答这样的事情，但是我觉得我周围也都是可爱的人，不应该被如此的对待。<br>说到底，还是孤单的久了，便会产生依赖。电子阳痿是越来越严重了，对各类电子娱乐方式也是越来越无感了，成天就是盯着聊天软件期盼有人能聊到我想看到的话题，却总是没有一声真正悦耳的提示音响起，或是来催 ddl 的。哪怕真的出现了，也如同泡沫一般一碰就碎，反而因为戒断反应徒增一些伤悲。<br>罢了，每年此刻必然多情，熬过这段时间也许就好了吧。</p>
]]></content>
      <categories>
        <category>Life_生活</category>
      </categories>
  </entry>
  <entry>
    <title>曼德勃罗集</title>
    <url>/posts/ebf347fe.html</url>
    <content><![CDATA[<h1 id="曼德勃罗集"><a href="#曼德勃罗集" class="headerlink" title="曼德勃罗集"></a>曼德勃罗集</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>曼德勃罗集是一个经典的分形图样，其是由迭代产生的。迭代就是不断重复某个过程。曼德勃罗集被迭代的是一些最简单的函数</p>
<span id="more"></span>
<script type="math/tex; mode=display">f(x) = x^2 + c</script><p>其中$ c $为常量。迭代前会给常量$ c $赋值。<br>迭代由初值即$ x_0 $开始，将$ x_0 $  代入$ x_0^2 + c $得到一个新数，前次计算结果作为下次迭代的输入。<br>如此类推，迭代生成的数值序列$ x0, x1, x2,…$是$ x0 $通过$ x^2 + c $迭代而产生的轨迹。</p>
<h2 id="图样"><a href="#图样" class="headerlink" title="图样"></a>图样</h2><p>如下是一个<strong>可交互</strong>的图样，支持鼠标拖动和滚轮放大<br>注意手机版<strong>暂不支持</strong>哦，只能当个图片咯</p>
<html>
<head>
    <meta charset="UTF-8">
    <title>Mandelbrot Set</title>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script type="text/javascript">
        // 获取画布和上下文
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        // 设置画布尺寸
        canvas.width = 400;
        canvas.height = 400;
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            canvas.height = 290;
            canvas.width = 290;
        }
        // 设置缩放参数
        let zoomFactor = 2.2;
        let centerX = -0.5;
        let centerY = 0;
        // 计算像素点对应的复数值
        function calculatePoint(x, y) {
            const real = centerX + (x - canvas.width / 2) / (canvas.width / 4) / zoomFactor;
            const imag = centerY + (y - canvas.height / 2) / (canvas.height / 4) / zoomFactor;
            return { real, imag };
        }
        // 绘制曼德勃罗集
        function drawMandelbrotSet() {
            // 创建图像数据
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            // 遍历每个像素点
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    // 计算像素点对应的复数值
                    const { real, imag } = calculatePoint(x, y);
                    // 计算曼德勃罗集的迭代次数
                    let zReal = 0;
                    let zImag = 0;
                    let i = 0;
                    for (; i < 300; i++) {
                        const zRealNew = zReal * zReal - zImag * zImag + real;
                        const zImagNew = 2 * zReal * zImag + imag;
                        if (zRealNew * zRealNew + zImagNew * zImagNew > 4) {
                            break;
                        }
                        zReal = zRealNew;
                        zImag = zImagNew;
                    }
                    // 将迭代次数映射到颜色值
                    const index = (y * canvas.width + x) * 4;
                    imageData.data[index] = i;
                    imageData.data[index + 1] = i;
                    imageData.data[index + 2] = i;
                    imageData.data[index + 3] = 255;
                }
            }
            // 绘制图像数据到画布上
            ctx.putImageData(imageData, 0, 0);
        }
        // 绘制初始曼德勃罗集
        drawMandelbrotSet();
        // 记录当前的鼠标状态
        let isDragging = false;
        let lastX, lastY;
                // 监听鼠标按下事件
        canvas.addEventListener('mousedown', event => {
            isDragging = true;
            lastX = event.clientX;
            lastY = event.clientY;
        });
        function moveCenter(deltaX, deltaY){
            centerX -= deltaX / (canvas.width / 4) / zoomFactor;
            centerY -= deltaY / (canvas.height / 4) / zoomFactor;
        };
        // 监听鼠标移动事件
        canvas.addEventListener('mousemove', event => {
            if (isDragging) {
                const deltaX = event.clientX - lastX;
                const deltaY = event.clientY - lastY;
                lastX = event.clientX;
                lastY = event.clientY;
                // 更新中心点坐标
                centerX -= deltaX / (canvas.width / 4) / zoomFactor;
                centerY -= deltaY / (canvas.height / 4) / zoomFactor;
                // 重新绘制曼德勃罗集
                drawMandelbrotSet();
            }
        });
        // 监听鼠标释放事件
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        // 监听鼠标滚轮事件
        canvas.addEventListener('wheel', event => {
            const delta = event.deltaY > 0 ? -0.1 : 0.1;
            zoomFactor *= 1 + delta;
            // 计算缩放中心点的复数值
            const { real, imag } = calculatePoint(canvas.width / 2, canvas.height / 2);
            centerX = real;
            centerY = imag;
            // 重新绘制曼德勃罗集
            drawMandelbrotSet();
            // 阻止默认滚动事件
            event.preventDefault();
        });
    </script>
</body>
</html>

<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>数学实验的这些天，我非常惊喜，数学实验课里居然有分形的存在，我直接来劲了。<br>看看这些分形图样，只能感叹数学的世界真是美丽，我们的路还有很长呢。我作为个体的能力有限，很难想象居然有人能在无计算机的前提下找到这些惊为天人的图样。<br>我还没有见识到真正的数学，我又怎么会被区区生活所击溃，忘掉我的真心呢？哪怕只能在门口探个头，也好过无知吧。</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Math_modeling</category>
      </categories>
  </entry>
  <entry>
    <title>深入异步通用概念</title>
    <url>/posts/9b424f3e.html</url>
    <content><![CDATA[<h1 id="深入异步通用概念"><a href="#深入异步通用概念" class="headerlink" title="深入异步通用概念"></a>深入异步通用概念</h1><p>协程是一个简单的概念，但它同时又没那么简单，因为其所代表的异步编程的思想具有一定的历史发展过程。这些东西曾经困扰了我许久，我饱读各种相关的资料却始终不得其解，因此我写下了这篇博客</p>
<span id="more"></span>
<blockquote>
<p> 前言: 本文所说的异步为单线程情况下的异步 IO。我将试图把 IO 多路复用、异步 IO、事件循环、协程、async/await 等分散的概念串联起来，方便理解其前因后果。注意其中涉及到的 syscall 以 Linux 为主。</p>
</blockquote>
<h2 id="在异步之旅开始之前"><a href="#在异步之旅开始之前" class="headerlink" title="在异步之旅开始之前"></a>在异步之旅开始之前</h2><p>相信任何一个朋友在一开始接触编程的时候都会编写类似下面这样的 C++ 代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> input;</span><br><span class="line">  std::cin &gt;&gt; input;</span><br><span class="line">  std::cout &lt;&lt; input &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作为一个 Hello world 级别的程序，大家都知道在第五行会阻塞起来等待输入，但等待输入的行为实际上并没有那么简单，在学习了操作系统之后，我们知道在这一段代码背后是调用了阻塞的 syscall <code>read()</code>，当你通过标准库对这个系统调用的封装调用到它时，会从用户态陷入内核态，等待内核将输入交给程序，才会继续下去。这是程序最简单的形态，以至于如果你参加任何算法竞赛的时候，要写的程序都是这样的形态。而这种系统调用因此被称为阻塞的，<strong>阻塞IO</strong>。而在等待内核将输入的信息传递给程序之前，程序处于一个休眠状态，对于操作系统来说，也就是不把运行的时间片分配给它，这种行为我们也称为把程序<strong>挂起</strong>了。</p>
<p>但这太简单了，初学者一定会好奇，这样一些从上到下顺序执行的代码，如何拼凑出一个带 UI 的程序。比如初学者可能会使用 Qt 去做一个贪吃蛇程序，在当下的这个年代，各种成熟的 UI 库层出不穷，很容易就能做到这一点。在做完这些刚刚入门编程的时候，他们略深入一些便会听说，他们所做的 Qt 程序运行在一个事件循环上，而 Qt 默认居然是单个线程就可以运行的。单线程怎么可能做到这个事情呢，它怎么能做到等待你输入，等待你点击 UI 的时候还能保证软件其他部分被渲染，动画似乎是完全与你的行为无关，一点也不像在 cli 中会阻塞，这种行为在多线程的前提下简直是个魔法嘛。</p>
<p>是的，我当年就是这么想的。在当时的我看来，阻塞完全是一个 debuff，应该需要一个不阻塞的接口。如果没有按下，也能正常执行后面的程序。那么我们就可以说，在这种情况下，我们的程序同操作系统实际做的事情一样，那就是创建一个巨大的 <code>while</code> 循环，不断询问操作系统对应的按钮是否被按下，这些询问本身并不花时间，只是问一问操作系统当前这个 IO 任务是否被完成。如果完成，我程序就可以从操作系统里取，如果没完成，那我就不管了，等到 while 下一次询问。这种类型的系统调用确实存在，他们被被称为非阻塞的，<strong>非阻塞IO</strong>，就像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设这里的isClickedButtonX()就是一个不阻塞的询问</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isClickedButtonW</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isClickedButtonA</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isClickedButtonS</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">isClickedButtonD</span>()) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以把所有的输入，包括这边代码中的 <code>isClickedButtonX()</code>，以及更为统一的鼠标指针，键盘输入，网络请求，甚至是外设(蓝牙，LED)这种在冯诺依曼结构里被称为输入输出设备向系统内部传递信息并交给操作系统，进而交由应用程序的所有信息称之为 <strong>IO</strong> 或者说 <strong>IO 事件</strong>。在上述的代码中，我们进行循环查询，并合理的把它们处理：也就是注释所说的 do something，不同的事件有不同处理，处理的方式在下文被称为<strong>任务</strong>，这是所谓的事件分发。这其实是最高效的处理这些 IO 事件的方式，事实上某些单片机程序就是这么做的，这种循环查询某个事件是否就绪的模式称为轮询(polling)。</p>
<blockquote>
<p>这样的方式可以进行的原因是：我们必须理解程序的运行，程序的信息来自于两处，一个是来自操作系统，一个是程序自身已经编入的信息，它在运行时的额外信息完全来自于操作系统，而操作系统的信息来自于硬件的交互。操作系统本身是异步的，因为硬件是并行处理的，操作系统通过中断以及各种调度算法处理并存储来自硬件的各种信息，本身 <strong>OS 就作为一个巨大 Buffer 为程序提供信息</strong>，所以程序本身无需在意数据是怎么被具体准备出来的，你只需要向操作系统注册需要的 IO 事件，操作系统就为你在缓冲区里准备好 IO 事件发生时拿到的数据，你自己去取，因此数据其实短期内不会丢失的，只等你的应用去响应并消费。</p>
</blockquote>
<p>但是这种方式最大的问题是，这样的行为意味着你的 while 代码块中的代码会一往无前的运行，每次循环都不带停的。当裸的 <code>while(1)</code> 出现在你的程序里，导致死循环，会大量占用 CPU 资源，使 CPU 占用率增高。</p>
<p>这里需要复习一下 CPU 占用率是什么。它的定义是通过对比忙碌时间和总时间得出的百分比，而总时间减去忙碌时间是空闲时间，其实操作系统完成了对 CPU 的调度，操作系统在运行时可以告诉 CPU，你要在某一个时间周期里工作多久，然后这个时间周期里的 CPU 还能休息一会，停止工作，而这段时间就是空闲时间。</p>
<p>而死循环程序会导致它试图最大程度请求 CPU 去做无用的轮询，操作系统为了最大满足它索要的计算资源，不允许 CPU 停止休息，因此占用率便提高了。</p>
<p>所以完全阻塞等待某个资源不行，开个循环询问所有任务的就绪状态也有问题，那应该怎么办呢?</p>
<h2 id="破局之法之多路复用"><a href="#破局之法之多路复用" class="headerlink" title="破局之法之多路复用"></a>破局之法之多路复用</h2><p>上文提到的阻塞 IO 并没有死循环的问题，你哪怕在一个 <code>while</code> 循环里写一个 <code>std::cin</code> 也不会出现占用超多 CPU 资源的问题，因为在你运行到的时候，系统就已经定在那了，程序被挂起了，不会走新的一轮 <code>while</code> 循环。但问题就在于程序此时此刻就只能做一件事情了。也许你会同早期的我一样，认为这个关键就在于 syscall 阻塞了线程的活动，应该彻底抛开可能导致阻塞的系统调用，也许存在一个可以天降信息的超级接口可以传递信息，很不幸，事实证明这样的接口并不存在。</p>
<p>让我们回看一下令我们困惑的例子：如果我们要做一个单线程的贪吃蛇的小程序，我们可能需要程序以一个固定的帧率去绘制，移动屏幕上的这条小蛇，那么我们就需要设定一个计时器来定时做一些渲染与计算的工作。但是我们在这个问题上往往忽略了一个事情，那就是计时器事件本身就也是一个 IO 事件，从更大的一个层次上，他和你等待一个按钮按下没有什么区别。</p>
<p>如果在 <code>while</code> 里将轮询事件能解决问题，但是没有阻塞导致占用率高，但阻塞的情况只会响应一个事件，那又不行。但如果我们能把这些个 <code>if</code> 扔给操作系统去考虑呢？于是 <strong>IO 多路复用</strong>出现了，它的核心原理是，<strong>在一个线程里通过有且仅有一个接口去获取所有 IO 事件，如果查询的时候存在准备好的数据，则立即返回并处理，如果查询时没有准备好的数据，则立即阻塞，等待操作系统准备好数据立即将其唤醒</strong>，这一类接口，比较常见的就是 Linux 下的 select/poll/epoll，将这样的接口置于while循环下，如果你处理 IO 事件的速度高于 IO 事件产生的速度，你就可以及时解决所有 IO 事件</p>
<p>看到了么，我特意强调了阻塞的字眼，为什么？需要强调的是，如我程序读写一个文件的时候，只是等在那，不会读取别的比如按钮点击事件等这样程序处理事件意义上的阻塞和接口的阻塞这两个阻塞说的并不是同样的概念。接口的阻塞是因为至少目前为止要想释放 CPU 的利用率，是必须要让用户态应用程序挂起的。所以从这个意义上来说，阻塞是必然的，所有这类要把 CPU 资源谦让出来的程序都应当是阻塞的程序。而只要有一个接口访问 IO 事件，等事件一出现，就立即响应，消费掉任务，然后挂起，就不算程序处理事件意义上的阻塞，因为你的程序仍然会高效的处理事件。</p>
<p><strong>是的，此阻塞非彼阻塞，所谓阻塞亦能实现非阻塞</strong></p>
<p>所以，我们的程序需要高效的处理或者说消费掉 IO 事件，这是保证任务不会堆起来，所有任务都能得到处理的前提。从具体参数上看就是处理 IO 事件的速度高于 IO 事件产生的速度，所以这个条件成立的程序，是为 <strong>IO 密集型程序</strong>，适合这种模式。而不满足这个条件的程序，一种是计算量特别大的程序，可能是执行某些科学计算，求解微分方程，处理图像，甚至是深度学习任务，这些程序是为<strong>计算密集型任务</strong>，一般选择多线程方式，还有一种是现代设备 IO 速度越来越快，此时可能直接轮询，试图达到速率上限能获得更高的收益(比如 io_uring 就是在做这里的极致优化)。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>最根本的问题解决了，接下来是要为这个简陋的 <code>while(1)</code> 循环加工一下了，我们需要一个在这个循环体进行一次时能够彻底消费掉这些操作系统里出现的数据的代码，其实这是一个调度器。在绝大部分的实现中，它都以一些我们刚刚提到的另一个耳熟能详的名字出现：事件驱动的模式，或者说事件循环。</p>
<p>来看下面这段给出的伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> *task_list = TaskList.<span class="built_in">getInstance</span>()-&gt;<span class="built_in">add</span>(InitTask);</span><br><span class="line"><span class="comment">//你需要在这里的InitTask注册监听的事件，否则程序立即退出</span></span><br><span class="line"><span class="keyword">auto</span> *event_fetcher = EventFetcher.<span class="built_in">getInstance</span>();</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> task: *task_list)</span><br><span class="line">        <span class="built_in">task</span>();</span><br><span class="line">    task_list.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">auto</span> events = EventFetcher.<span class="built_in">getInstance</span>()-&gt;<span class="built_in">getEvents</span>();</span><br><span class="line">    <span class="comment">// 这里如果获取不到会阻塞等待</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> event: events)</span><br><span class="line">        <span class="built_in">EventDispatcher</span>(event); </span><br><span class="line">    <span class="comment">// 分发后，后续任务也就是回调用闭包形式传入序列</span></span><br><span class="line">    <span class="comment">// 倘若监听的事件和任务队列全无，则程序退出</span></span><br><span class="line">    <span class="keyword">if</span>(!events.<span class="built_in">length</span>() &amp;&amp; task_list.<span class="built_in">length</span>())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，既然要监听事件，必须有一个监听器，在这里是 <code>EventFetcher</code>，你需要在 <code>initTask</code> 这个初始任务里完成注册，紧接着是事件发生后分发任务的函数 <code>EventDispatcher</code>，它将事件按照注册时留下的函数，将发生事件后处理事件的任务扔给 <code>taskList</code>，并一个一个跟着处理，<code>taskList</code> 这样的容器可能是按照优先级优先弹出的优先队列或者其他什么算法，用以高效的分配任务，这样的任务我们给它一个名字，叫做<strong>回调函数</strong></p>
<p>回调函数何时执行是由调度器决定的，原本把它放到 <code>taskList</code> 的函数大概率早就已经执行下去了，并不会管回调函数什么时候运行，或者说对于程序员来说，它何时运行逻辑都必须正确，这种逻辑上他俩执行没什么关系的行为就是所谓异步。</p>
<p>要注意的是，输入 <code>taskList</code> 的是一个闭包，如果假使说这个任务是一个计时器，也许你会需要循环往复的计时，此时你必须在回调函数里将计时器重新启动，启动的过程就是向 <code>EventFetcher</code> 再注册一遍计时器，向 <code>EventDispatcher</code> 再把自己的任务和自己当前正在执行的这个回调组成的一对数据再次传入，以此实现无限计时的效果</p>
<p>回调式的写法在现代的 UI 框架里相当常见，例如 Qt 的信号槽机制，本质上就是这样的东西，我们来看看下面 Dart 的事件循环实现</p>
<p><img src="/images/深入异步通用概念_图1.png" width="50%" height="50%"></p>
<p>哎哎，这不就是一模一样，所以说自 IO 多路复用出现后，事件循环也很自然的就出现了</p>
<p>然而大量使用回调引发了回调地狱的问题。异步最大的问题就是难以阅读。异步的行为导致无法定位事件的来源，所有的任务的调用栈将都被污染为事件循环所执行的，形成了可悲的厚障壁—— asynchronous gap，为程序员调试带来了极大的困难。为了缓解回调地狱，Javascript 带头引入了 promise 的概念，但仍然未脱离回调的意图，只是让回调写成链式调用更好看一点罢了，在此处我们按下不表，有兴趣的可以自行阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise - JavaScript | MDN</a></p>
<h2 id="横空出世的协程，async-await-的秘法"><a href="#横空出世的协程，async-await-的秘法" class="headerlink" title="横空出世的协程，async/await 的秘法"></a>横空出世的协程，async/await 的秘法</h2><p>想出协程，async/await 这套东西的人绝对是个天才，我无缘得见是什么样的心路历程能够想到这一套东西，但我们仍然可以看看它是怎么工作的，这里我们主要看看的是 async/await，协程的概念与其基本一致，想必聪明的读者看完下面这些，也就能理解协程了</p>
<p>当我们第一次接触 <code>async/await</code> 时，一个最直观的困惑就是：<code>await</code> 字面意思就是”等待”，等待一个任务完成，这听起来不就是<strong>阻塞</strong>吗？如果它阻塞了当前线程，那和我们直接用同步的 <code>thread.sleep()</code> 或等待一个锁有什么区别？这岂不是换汤不换药？</p>
<p>实则不然。这正是 <code>async/await</code> 的巧妙之处，也是理解其非阻塞本质的关键。<code>await</code> 的”等待”，是一种<strong>主动的让步，而非被动的阻塞</strong>。</p>
<h3 id="await-的”等待”是假象，状态机的”挂起”才是真相"><a href="#await-的”等待”是假象，状态机的”挂起”才是真相" class="headerlink" title="await 的”等待”是假象，状态机的”挂起”才是真相"></a>await 的”等待”是假象，状态机的”挂起”才是真相</h3><p>要理解这一点，我们必须揭开 <code>async</code> 函数的华丽外衣，直视其内核：<strong>一个由编译器自动生成的状态机</strong>。</p>
<p>一个普通的同步函数从开始到结束，其执行路径是唯一的、连续的。而一个 <code>async</code> 函数内部因为有了 <code>await</code> 点，它的执行可以被分割成多个阶段。每一个 <code>await</code> 都是一个潜在的中断点。</p>
<p>让我们用一个例子来将这个状态机可视化：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">fn</span> <span class="title function_">fetch_data_and_process</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url1</span> = <span class="string">&quot;http://example.com/data1&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">url2</span> = <span class="string">&quot;http://example.com/data2&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阶段 0: 开始</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data1</span> = <span class="title function_ invoke__">fetch_url</span>(url1).<span class="keyword">await</span>?; <span class="comment">// &lt;- 等待点 1 (await 1)</span></span><br><span class="line">    <span class="comment">// 阶段 1: 收到 data1 后继续</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Received data1: &#123;&#125;&quot;</span>, data1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data2</span> = <span class="title function_ invoke__">fetch_url</span>(url2).<span class="keyword">await</span>?; <span class="comment">// &lt;- 等待点 2 (await 2)</span></span><br><span class="line">    <span class="comment">// 阶段 2: 收到 data2 后继续</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Received data2: &#123;&#125;&quot;</span>, data2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阶段 3: 结束</span></span><br><span class="line">    <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125;&quot;</span>, data1, data2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会将这个 <code>async fn</code> 编译成一个实现了 <code>Future</code> trait 的状态机。这个状态机大致长这样：</p>
<ul>
<li><strong>基本概念</strong> 首先编译器会把 async 函数编译成状态机，在 await 发生的时候，状态机整个休眠，在外部，通过 <code>poll</code> 唤醒状态机，<code>poll</code> 的语义是<strong>尽可能催促状态机执行的更远</strong></li>
<li><strong>状态 0 (State 0):</strong> 刚被调用 <code>poll</code> 试图推动状态机时，启动 <code>fetch_url(url1)</code> 这个 Future，然后<strong>立即返回 <code>Poll::Pending</code></strong>。同时，它记录下自己的状态：”我现在正卡在 <code>await 1</code> 这里”。</li>
<li><strong>事件与唤醒：</strong> 当 <code>fetch_url(url1)</code> 的 I/O 操作在后台完成时（例如，通过操作系统的 epoll/kqueue 等机制通知），一个事件被触发。调度器会知道：”哦，<code>fetch_url(url1)</code> 这个 Future 准备好了”。然后，调度器会找到正在等待它的 <code>fetch_data_and_process</code> 状态机，并再次调用它的 <code>poll</code> 方法。</li>
<li><strong>状态 1 (State 1):</strong> 状态机从上次中断的地方恢复。它发现自己是处于”状态 1”，于是从 <code>fetch_url(url1)</code> 中拿到结果 <code>data1</code>，执行 <code>println!</code>，然后启动 <code>fetch_url(url2)</code>，接着再次返回 <code>Poll::Pending</code>，并将状态更新为”卡在 <code>await 2</code>“。</li>
<li><strong>状态 2 (State 2):</strong> 同理，当 <code>fetch_url(url2)</code> 完成时，调度器再次唤醒它。状态机恢复，拿到 <code>data2</code>，执行最后的逻辑，最终返回 <code>Poll::Ready(result)</code>，标志着整个异步任务的完成。</li>
</ul>
<p>哦？调度器，事件的概念又被提及了，是不是事件循环是 async/await 的重要实现方式之一呢？</p>
<p>你猜的没有错，事实上，你可以从事件循环上很容易的构建出一个 async/await 系统来：如果所有的 async 状态机都是一个对象，当某个 <code>async</code> 函数运行到 <code>await</code> 状态的时候，就是把一个任务注册到事件循环，这个任务是，监听到” await 等待的状态机运行完毕”这个事件时，事件循环的调度器回调 poll 函数来推动自己进行下一步。而正是因为回调函数都会坍缩为 poll ，这就使得在一定程度上事件循环的任务列表里基本都是相同的 poll 函数，简化一下可以省略调任务列表，直接把发送” await 等待的状态机运行完毕”事件改成 poll ，所以 async/await 实现也有可能不需要依赖事件循环。</p>
<p>所以，<code>await</code> 的关键在于：<strong>当任务需要等待（比如 I/O 未就绪）时，它不是傻傻地占着线程不放，而是通过返回 <code>Pending</code> 来释放线程的控制权。这个线程此时就可以掉头去执行其他已经就绪的任务（比如另一个完成的 HTTP 请求）。</strong> 这正是异步编程高并发能力的根源。</p>
<h3 id="异步任务树与调度器的工作流"><a href="#异步任务树与调度器的工作流" class="headerlink" title="异步任务树与调度器的工作流"></a>异步任务树与调度器的工作流</h3><p>想象一下，对于 ui 框架，显然要 await 的东西不可能只有一个按钮别的不等了，所以，async 需要能等待多个任务，因此你会在 rust 的宏里看见有实现这个功能的 await (<code>join_all(v).await</code>)，只有使用这种特制的 await，实际上是让事件循环用不同的监听模式来 poll，才能实现让一组任务异步进行。单个 <code>async</code> 函数是一个状态机，而一个复杂的异步程序则是由无数个 <code>async</code> 函数通过 <code>await</code> 组合而成的一棵<strong>异步任务树</strong>。</p>
<blockquote>
<p>注意：<strong>异步任务树</strong>实为本文自创的概念，实际上怎么称呼这样的结构我并不知道。同样的，可能存在更复杂的数据结构能更高效的解决这样的问题，但下面我所提及的应该是一种实现。</p>
</blockquote>
<p>其所有叶子节点都是 await 函数的尽头，即具体等待一个任务，树的下方是调度器，当事件发生时，调度器将会在事件列表中挑选一个事件，poll 这个事件对应的叶子节点，是一个 async 函数/协程，让它执行至挂起或结束，控制权回到调度器，处理下一个事件，如果事件消费完毕，则继续挂起，这样的循环构成了异步模式下，无栈协程组成程序的图景。</p>
<p>我们可以从刚刚那个 <code>fetch_data_and_process()</code> 为例子来画一下这棵树具体可以如何工作的其中一种样子：</p>
<p>首先是 <code>fetch_data_and_process()</code> 被 await 之前，先是有一棵树</p>
<p><img src="/images/深入异步通用概念_图2.png" width="100%" height="100%"></p>
<p>然后紧接着，调用者开始 await，实际上<strong>干了4件事情</strong></p>
<ol>
<li>初始化 <code>fetch_data_and_process</code> 的状态机，同时包括分配返回值所放置区域等行为</li>
<li>把推动 <code>fetch_data_and_process</code> 的状态机的 poll 函数放进事件循环的任务队列</li>
<li>把监听 <code>fetch_data_and_process</code> 的状态机完成的事件注册到事件循环，回调是 poll 调用者自己</li>
<li>调用者挂起自己</li>
</ol>
<p>于是便得到了</p>
<p><img src="/images/深入异步通用概念_图3.png" width="100%" height="100%"></p>
<p>记录一下此时此刻事件循环的状态(省略无关项，同时<strong>列表的内容是伪代码</strong>，下同)：</p>
<ul>
<li>任务列表：<code>fetch_data_and_process.poll()</code></li>
<li>注册的事件：<br><code>Event&lt;fetch_data_and_process.finish()&gt; -&gt; caller.poll()</code></li>
</ul>
<p>接着等待事件循环调度，直到调用 poll 推动<code>fetch_data_and_process</code> 的状态机，运行下来就到了 <code>let data1 = fetch_url(url1).await?;</code> 这一行了，也是同理，做这四件事情</p>
<p><img src="/images/深入异步通用概念_图4.png" width="100%" height="100%"></p>
<p>事件循环的状态：</p>
<ul>
<li>任务列表：<code>fetch_url.poll()</code></li>
<li>注册的事件：<br><code>Event&lt;fetch_data_and_process.finish()&gt; -&gt; caller.poll()</code>,<br><code>Event&lt;fetch_url.finish()&gt; -&gt; fetch_data_and_process.poll()</code></li>
</ul>
<p>我们假定 <code>fetch_url</code> 要直接做一个获取资源的基础 API，那么它和上述的 await 实际上理应是有差别的，因为它不能再把任务推给别人了自己只是等待了，必须自己处理，所以这个异步函数的函数体里只会干两件事</p>
<ol>
<li>创建获取 url 资源的事件，注册到事件循环，回调是 poll <code>fetch_url</code> 自己</li>
<li>挂起自己，等待数据完成</li>
</ol>
<p><img src="/images/深入异步通用概念_图5.png" width="100%" height="100%"></p>
<p>此时此刻事件循环的状态：</p>
<ul>
<li>任务列表：空</li>
<li>注册的事件：<br><code>Event&lt;fetch_data_and_process.finish()&gt; -&gt; caller.poll()</code>,<br><code>Event&lt;fetch_url.finish()&gt; -&gt; fetch_data_and_process.poll()</code>,<br><code>Event&lt;API_getUrl.finish()&gt; -&gt; fetch_url.poll()</code></li>
</ul>
<p>好了，接下来任务简单了，等待回调，<code>Event&lt;API_getUrl.finish()&gt;</code> 发生时，<code>fetch_url</code> 会被推动到结束，在结尾的时候，也会挂起自己这个状态机，运行过程回到调度器里，从而从这棵树上脱落。在此之前释放一个 <code>Event&lt;fetch_url.finish()&gt;</code> 的事件信息，告诉事件循环 <code>fetch_data_and_process.poll()</code> 该被放进队列里运行了。</p>
<p><img src="/images/深入异步通用概念_图6.png" width="100%" height="100%"></p>
<p>然后 <code>fetch_data_and_process.poll()</code> 让 async 函数 <code>fetch_data_and_process</code> 继续运行，碰到第二个 await <code>let data2 = fetch_url(url2).await?;</code>，逻辑是一样的。直到最后 <code>fetch_data_and_process</code> 也执行到最后，挂起自己交给调度器，脱落，也便回到 <code>caller</code> 了。</p>
<p><img src="/images/深入异步通用概念_图7.png" width="100%" height="100%"></p>
<p>这么看来实现这么一套异步的库也不是很麻烦嘛，虽然为 IO 事件包裹一层 API 是实打实的 dirty work</p>
<p>通过这个小例子你也可以自然的发现，如果你的应用只是普通的 await function 组合，没有特制的等待好几个任务的 await，那你的<strong>异步任务树</strong>就是<strong>异步任务链表</strong>，在这种情况下，实际上和同步毫无区别，而如果你可以同时 await 好几个任务，那由于任务是递交给事件循环穿插运行的，也便实现了所谓的异步：最简单的例子，你可以同时异步高效的 fetch 好几个 url 的内容了。</p>
<h3 id="无法逾越的鸿沟：异步的”传染性”"><a href="#无法逾越的鸿沟：异步的”传染性”" class="headerlink" title="无法逾越的鸿沟：异步的”传染性”"></a><strong>无法逾越的鸿沟：异步的”传染性”</strong></h3><p>理解了上述机制，我们也就能明白为什么说 <code>async</code> 函数具有”传染性”：一个函数内部如果使用了 <code>await</code>，它自身就必须被标记为 <code>async</code>。</p>
<p>这是因为，<code>await</code> 的语义依赖于其所在的上下文是一个可以被挂起和恢复的状态机。一个普通的同步函数不具备这种能力。它一旦开始执行，就必须运行到结束，中间无法被”挂起”并将线程控制权交还给调度器。</p>
<p>因此，<strong>异步模式是构建在同步模式之上的一种特殊环境</strong>。当你选择踏入这个环境（调用一个 <code>async</code> 函数），你就必须遵守它的规则。这种”鸿沟”是异步编程模型本身的性质所决定的，而非 Rust 或其他语言的设计缺陷。</p>
<blockquote>
<p>本节我们聚焦于单线程内的协程调度，揭示了 <code>async/await</code> 非阻塞的秘密。然而，协程的魅力远不止于此。它并不与异步强绑定，其本质只是一个可暂停、可恢复的代码块，是”程序是状态机”这一最本质概念的体现。在多线程的舞台上，协程还能演绎出更精彩的并发模式。</p>
</blockquote>
<h2 id="后日谈"><a href="#后日谈" class="headerlink" title="后日谈"></a>后日谈</h2><p>说真的，我觉得异步真的不是一个很好理解的东西，它和操作系统相关性不小，但你不能把它看作是操作系统的调度模式。因为操作系统作为一个具有最高权限的软件，它作为状态机，推动它的是硬件中断，在计算机模型里，它不需要考虑自己去实现这个”异步”的功能。但在实际的应用里，其实完全是同步模式，靠获取 os 的信息手动实现的推动状态机，才真正进入了异步。值得一提，我的朋友说：”其实直到在单片机里应用这些行为才真正理解了什么是异步。” 我想这正是轮询，非阻塞 IO 启发了他吧。<br>本人愚钝，这个概念确是想了不少时间才得以理解，中间甚至有过很久的错误理解，如有谬误，还请多多包涵</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Computer_composition</category>
      </categories>
  </entry>
  <entry>
    <title>离散与连续傅里叶变换之间的联系</title>
    <url>/posts/f1193ad8.html</url>
    <content><![CDATA[<h1 id="离散与连续傅里叶变换之间的联系"><a href="#离散与连续傅里叶变换之间的联系" class="headerlink" title="离散与连续傅里叶变换之间的联系"></a>离散与连续傅里叶变换之间的联系</h1><p>在复习这学期的数字信号处理的时候，发现我的数字信号处理书对此的解释我完全看不懂啊，所以就花了几天时间自己推了一点公式，通过了解这些离散啊，连续啊什么的傅里叶变换的数学性质能比较直观的帮助我理解这科目到底在干什么，具体为什么要这么干</p>
<span id="more"></span>
<blockquote>
<p>我用到的这本书上说，DTFT在信号与系统中有学，所以略讲，信号与系统里提都没提DTFT 而且我觉得DTFT还非常容易和DFT混，如果不是真去尝试证明真不清楚其中是什么含义</p>
</blockquote>
<h2 id="DTFT"><a href="#DTFT" class="headerlink" title="DTFT"></a>DTFT</h2><p>想要理解DTFT得先从实际的采样开始，采样就是每隔采样周期T取一个值，就是把一个连续的信号在时间域上离散化，或者用数学一点的说法，用这种方法把一个定义在$\mathbb{R}$(时间是实数)上的函数映射成一个数列(定义在$\mathbb{Z}$上的函数)</p>
<blockquote>
<p>所以这里的连续信号中的连续并不是说的数学上的函数连续，而是指定义域不是$\mathbb{R}$)</p>
</blockquote>
<p>其表达式为</p>
<script type="math/tex; mode=display">x[n]=x_a(nT)</script><p>​很容易就会想知道对$x[n]$进行DTFT和对$x_a(t)$进行CTFT(连续傅里叶变换)之后的结果有什么关系</p>
<p>我们把两个变换的定义的式子写出来</p>
<script type="math/tex; mode=display">\mathrm{CTFT}[x(t)]=\int_{-\infty}^{+\infty}x(t)e^{-j\omega t}dt</script><script type="math/tex; mode=display">\mathrm{DTFT}[x[n]]=\sum_{n=-\infty}^{+\infty}x[n]e^{-j\omega n}</script><p>首先要说明一下我这边的符号，比如$\mathrm{DTFT}[x[n]] (\omega)$的含义是先对$x[n]$进行离散时间的傅里叶变换后的频域函数代入$\omega$，比如$\mathrm{DTFT}[x[n]] (\pi)$就是$x[n]$的频域函数代入$\pi$，这里之所以不使用$X(e^{j\omega})$这种符号是我觉得在数学上不够直观，虽然书上会说写成这种复合函数的形式有工程上的好处，但其实不方便从理论的角度去考虑，多一层不如少一层</p>
<p>可以看出他俩其实很相似，所以我们很容易就能联想到下面这个等式</p>
<p><strong>Lemma 1:</strong></p>
<script type="math/tex; mode=display">\mathrm{CTFT}[x(t)\cdot \delta_T(t)]=\mathrm{DTFT}[x[n]](T\omega)</script><p>其中<script type="math/tex">\delta_T(t)=\sum_{n=-\infty}^{+\infty}\delta(t-nT)</script>，这是采样函数，画成图像就是在坐标轴上从原点出发每隔时间T就是一个冲激</p>
<p><strong>Proof:</strong></p>
<script type="math/tex; mode=display">\begin{aligned}
\mathrm{CTFT}[x(t)\cdot \delta_T(t)]
&=\int_{-\infty}^{+\infty}x(t) \delta_T(t)e^{-j\omega t}dt\\
&=\int_{-\infty}^{+\infty}x(t)\sum_{n=-\infty}^{+\infty}\delta(t-nT)e^{-j\omega t}dt\\
&=\sum_{n=-\infty}^{+\infty}\int_{-\infty}^{+\infty}x(t)\delta(t-nT)e^{-j\omega t}dt\\
&=\sum_{n=-\infty}^{+\infty}x(nT)e^{-j\omega nT}\\
&=\sum_{n=-\infty}^{+\infty}x[n]e^{-jT\omega n}\\
&=\mathrm{DTFT}[x[n]](T\omega)
\end{aligned}</script><p>那么输入的函数关系怎么样已经找出来了，输出的频域函数两个变换又有什么关系呢?<br>首先再来算一个东西</p>
<p><strong>Lemma 2:</strong></p>
<script type="math/tex; mode=display">\mathrm{CTFT}[x(t)\cdot \delta_T(t)]=\frac{1}{T}\sum_{n=-\infty}^{+\infty}\mathrm{CTFT}[x(t)](\omega-\frac{2\pi n}{T})</script><p><strong>Proof:</strong></p>
<p>首先对<script type="math/tex">\delta_T(t)=\sum_{n=-\infty}^{+\infty}\delta(t-nT)</script>进行傅里叶级数展开，得到</p>
<script type="math/tex; mode=display">\delta_T(t)=\frac{1}{T}\sum_{n=-\infty}^{+\infty}e^{j\frac{2\pi n}{T}t}</script><p>将这个式子代入连续傅里叶变换的定义式，得到</p>
<script type="math/tex; mode=display">\begin{aligned}
\mathrm{CTFT}[x(t)\cdot \delta_T(t)]
&=\int_{-\infty}^{+\infty}x(t) \delta_T(t)e^{-j\omega t}dt\\
&=\frac{1}{T}\int_{-\infty}^{+\infty}x(t)\sum_{n=-\infty}^{+\infty}e^{jn\omega t}e^{-j\omega t}dt\\
&=\frac{1}{T}\sum_{n=-\infty}^{+\infty}\int_{-\infty}^{+\infty}x(t)e^{j(\frac{2\pi n}{T}-\omega) t}dt\\
&=\frac{1}{T}\sum_{n=-\infty}^{+\infty}\mathrm{CTFT}[x(t)](\frac{2\pi n}{T}-\omega)
\end{aligned}</script><p>可以看到，对原本的连续信号的采样进行连续傅里叶变换得到的结果是原本信号的傅里叶变换的结果在频率轴上移动$\frac{2\pi}{T}$的整数倍得到的所有函数的和的$\frac{1}{T}$倍，这就是所谓的周期延拓</p>
<p>好了，由上面得到的两个小等式联立一下可以证明我们需要的东西了</p>
<p><strong>Equation:</strong> </p>
<script type="math/tex; mode=display">\mathrm{DTFT}[x[n]](T\omega)=\frac{1}{T}\sum_{n=-\infty}^{+\infty}\mathrm{CTFT}[x(t)](\omega-\frac{2\pi n}{T})</script><p>将两边的$\omega$同时换元成$\frac{\omega}{T}$，再把换元后左式多余的$(\omega)$删掉，就是，就能得到最终的式子了</p>
<script type="math/tex; mode=display">\mathrm{DTFT}[x[n]]=\frac{1}{T}\sum_{n=-\infty}^{+\infty}\mathrm{CTFT}[x(t)](\frac{\omega-2\pi n}{T})</script><ul>
<li>用人话翻译一下这个句子，对一个离散信号进行DTFT，等价于对它采样前的连续信号进行周期延拓(连续傅里叶变换后的结果在频率轴上移动$\frac{2\pi}{T}$的整数倍得到的所有的无穷多个函数的叠加的$\frac{1}{T}$倍)后再把整个频谱函数沿着频率轴放大T倍</li>
<li>或者说你也可以理解为采样前的连续信号先沿频率轴放大T倍在进行周期延拓</li>
<li>再或者你还能理解为原连续信号的周期延拓完了之后把他沿频率轴放缩到以$2\pi$为周期(DTFT它是关于$2\pi$成周期的，你可以从这个等式里一目了然的看见，也能从DTFT的定义式中证明这个)</li>
</ul>
<p>那么你就可以理解DTFT诞生的原因了，本质上它也是一种近似获得连续信号的傅里叶变换的手段，只不过算出来的结果是原本连续傅里叶变换的移位之后又压缩了一下再叠加嘛。</p>
<p>从这里你就知道什么叫混叠了，在一些比较良好的情况下，比如去DTFT一个带限信号的采样，带限信号是在频率上截止频率为$\omega_c$的信号，就是说$|\omega|\ge\omega_c$时，$X(\omega)=0$，那么，既然DTFT是原函数的周期延拓，对于带限的信号来说，根据上面的等式，你可以看到下图中一个小尖坡的影响范围是$\omega_cT$，而每$2\pi$的范围内，就有两个小尖坡在影响，要想他们不重叠，自然就要求$\omega_c T \le \frac{2 \pi}{2}$，把采样周期写成采样频率即$T=\frac{1}{\omega_s}$，代入就得到了$\omega_s \ge 2\omega_c$，这不就是奈奎斯特采样定律么，在满足这个条件的情况下，DTFT结果的$[-\pi,\pi]$的部分完全就是CTFT做了一些就简单的变换，换言之，你可以通过计算DTFT，在只存储采样后的离散的数据的情况下计算出原本信号的CTFT，这就是DTFT存在的目的，如果不满足这个条件，小尖坡就会变粗，接着叠起来，就不能从DTFT获得CTFT的信息了<br><img src="/images/离散与连续傅里叶变换之间的联系_图1.png" width="100%" height="100%"></p>
<p>所以你现在明白了所谓奈奎斯特采样定律就是从采样后离散信号的DTFT能约等于看作是原本连续信号的CTFT的”约等于”能成立的需要的条件</p>
<h2 id="DFT-FFT"><a href="#DFT-FFT" class="headerlink" title="DFT/FFT"></a>DFT/FFT</h2><p>FFT本质就是一个DFT的快速算法，就是另一种计算DFT的方法，和DFT完全没有区别，唯一需要注意的是要会用就行了，简单来说就是背下来那个蝶形图是怎么个画法</p>
<p>而DFT就更有趣了，先看看它的定义式</p>
<script type="math/tex; mode=display">\mathrm{DFT}[x[n]]=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}，0\le k\le N-1</script><p>这里没有写成$W^{-j(2\pi/N)}$也是出于这样能更加好的看出其原本的数学性质的目的</p>
<p>它和DTFT只有一点点差别，首先它对$x[n]$有要求，它必须是一个有限长序列，长度为N，在这样的情况下，这个序列进行DTFT，其实求和号上的差别就没了，那剩下的就只有指数上的差别了，那么其实完全满足这样的式子</p>
<script type="math/tex; mode=display">\begin{aligned}\mathrm{DFT}[x[n]](k)&=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N}kn}\\
&=\mathrm{DTFT}[x[n]](\frac{2\pi}{N}k)，0\le k\le N-1
\end{aligned}</script><p>这下看懂了，对一个有限长序列进行DFT就是在对它进行DTFT后$[0,2\pi]$的部分再采样N个点呢</p>
<p>还没完，如果你给这个长度为N的有限长序列$x[n]$后面再填M个0，让他变成长度为N+M的有限长序列$x’[n]$呢？表达式就变成了如下</p>
<script type="math/tex; mode=display">\begin{aligned}\mathrm{DFT}[x'[n]](k)&=\sum_{n=0}^{N+M-1}x[n]e^{-j\frac{2\pi}{N+M}kn}\\
&=\sum_{n=0}^{N-1}x[n]e^{-j\frac{2\pi}{N+M}kn}\\
&=\mathrm{DTFT}[x[n]](\frac{2\pi}{N+M}k)，0\le k\le N+M-1
\end{aligned}</script><p>好嘛，就是没添加0之前的结果采样的更加密集了一点，只要你M取特别特别大，你就可以用DFT完全逼近这个有限长序列的DTFT了，例子如下</p>
<p><img src="/images/离散与连续傅里叶变换之间的联系_图2.gif" width="100%" height="100%"></p>
<p>上图的matlab代码如下<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">pic_num = <span class="number">1</span>;   </span><br><span class="line"><span class="keyword">for</span> k=<span class="number">0</span>:<span class="number">4</span>:<span class="number">240</span></span><br><span class="line">    s=<span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line">    N=<span class="number">32</span>;</span><br><span class="line">    n=<span class="number">0</span>:N<span class="number">-1</span>;</span><br><span class="line">    x=<span class="built_in">sin</span>(<span class="number">5</span>*n*<span class="built_in">pi</span>/N);<span class="comment">% 取样计算持续0到pi的sin(5t)信号</span></span><br><span class="line">    x=[x,<span class="built_in">zeros</span>(<span class="number">1</span>,k)];</span><br><span class="line">    n=<span class="number">0</span>:N<span class="number">-1</span>+k;</span><br><span class="line">    w=<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">2</span>*<span class="built_in">pi</span>,<span class="number">10000</span>);</span><br><span class="line">    y1=x*<span class="built_in">exp</span>(-<span class="built_in">j</span>*n&#x27;*w)/N*<span class="built_in">pi</span>;<span class="comment">% DFT</span></span><br><span class="line">    y2=<span class="built_in">j</span>*<span class="built_in">pi</span>*((<span class="number">1</span>-<span class="built_in">exp</span>(-<span class="built_in">j</span>*(w/<span class="built_in">pi</span>*N+<span class="number">5</span>)*<span class="built_in">pi</span>))./(<span class="built_in">j</span>*(w/<span class="built_in">pi</span>*N+<span class="number">5</span>))-(<span class="number">1</span>-<span class="built_in">exp</span>(-<span class="built_in">j</span>*(w/<span class="built_in">pi</span>*N<span class="number">-5</span>)*<span class="built_in">pi</span>))./(<span class="built_in">j</span>*(w/<span class="built_in">pi</span>*N<span class="number">-5</span>)))/(<span class="number">2</span>*<span class="built_in">pi</span>);<span class="comment">% DTFT</span></span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>);stem(n,x,<span class="string">&#x27;.&#x27;</span>);ylabel(<span class="string">&#x27;$x(n)$&#x27;</span>,<span class="string">&#x27;interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">12</span>);xlim([<span class="number">0</span> N<span class="number">-1</span>+k]);</span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>);<span class="built_in">plot</span>(w/<span class="built_in">pi</span>,<span class="built_in">abs</span>(y1));<span class="built_in">hold</span> on;</span><br><span class="line">    stem(n*<span class="number">2</span>*(N<span class="number">-2</span>+k)/(N<span class="number">-1</span>+k)/(N<span class="number">-1</span>+k),<span class="built_in">abs</span>(fft(x)/N*<span class="built_in">pi</span>),<span class="string">&#x27;.&#x27;</span>);xlabel(<span class="string">&#x27;$k \&amp; \omega$&#x27;</span>,<span class="string">&#x27;interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">12</span>);ylabel(<span class="string">&#x27;$|X[k]| \&amp; |X(e^&#123;j\omega&#125;)|$&#x27;</span>,<span class="string">&#x27;interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">12</span>);xlim([<span class="number">0</span> <span class="number">2</span>]);<span class="built_in">hold</span> off;</span><br><span class="line">    subplot(<span class="number">3</span>,<span class="number">1</span>,<span class="number">3</span>);<span class="built_in">plot</span>(w/<span class="built_in">pi</span>,<span class="built_in">abs</span>(y2));xlabel(<span class="string">&#x27;$\omega/\pi$&#x27;</span>,<span class="string">&#x27;interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">12</span>);ylabel(<span class="string">&#x27;$|\mathrm&#123;FT&#125;[X]|$&#x27;</span>,<span class="string">&#x27;interpreter&#x27;</span>,<span class="string">&#x27;latex&#x27;</span>,<span class="string">&#x27;fontsize&#x27;</span>,<span class="number">12</span>);</span><br><span class="line">    drawnow;F=getframe(s);I=frame2im(F);[I,map]=rgb2ind(I,<span class="number">256</span>);</span><br><span class="line">    <span class="keyword">if</span> pic_num == <span class="number">1</span></span><br><span class="line">        imwrite(I,map,<span class="string">&#x27;test.gif&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>, <span class="string">&#x27;Loopcount&#x27;</span>,<span class="built_in">inf</span>,<span class="string">&#x27;DelayTime&#x27;</span>,<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        imwrite(I,map,<span class="string">&#x27;test.gif&#x27;</span>,<span class="string">&#x27;gif&#x27;</span>,<span class="string">&#x27;WriteMode&#x27;</span>,<span class="string">&#x27;append&#x27;</span>,<span class="string">&#x27;DelayTime&#x27;</span>,<span class="number">0.1</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    pic_num = pic_num + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>所以，求有限长序列的DFT也是约等于求它的DTFT，这样做的优势就是，DFT还能让结果也变得离散化，方便存储的同时还有FFT这种神奇的算法能给计算加速</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当带限信号满足奈奎斯特采样定律时，从采样后离散信号的DTFT能约等于看作是原本连续信号的CTFT</li>
<li>对于有限长序列，计算DFT就是在逼近计算DTFT函数的一部分值<br>所以综上，我所使用的这本教材前三章的核心目的就是告诉我，可以使用某种手段(比如滤波器等等)，利用FFT就能近似计算一个连续函数的CTFT，至于其他的都是具体的计算时的分支任务。比如设计数字滤波器，本质上就是在给采样后的信号去干连续信号一样的事情</li>
</ul>
]]></content>
      <categories>
        <category>EE_电子工程</category>
        <category>数字信号相关</category>
      </categories>
  </entry>
  <entry>
    <title>移动端开发初探_1</title>
    <url>/posts/9b96febe.html</url>
    <content><![CDATA[<h1 id="移动端开发初探-1"><a href="#移动端开发初探-1" class="headerlink" title="移动端开发初探_1"></a>移动端开发初探_1</h1><p>因为一些巧合，现在一直接触 C++ 的我开始了移动端的学习与开发，这篇文档稍微记录一下自己的学习过程，但其实这不是一个笔记记录，算是一点小小感悟吧</p>
<span id="more"></span>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>早就听闻 Flutter 的大名，没想到我也会有一天有理由去学习这样一个框架，其实在很久以前我也曾是从 Android 开发过来的，不过现在回头看一眼，Android 的结构还是太过复杂了，以当时我的基础，基本上完全不能够理解相关的内容</p>
<blockquote>
<p>免责声明：仅由于我暂时没有鸿蒙开发所使用的设备(我穷喵)，目前我不考虑鸿蒙的开发，下文就只考虑 Android 与 iOS</p>
</blockquote>
<h2 id="学习的-Bootstrap-时期"><a href="#学习的-Bootstrap-时期" class="headerlink" title="学习的 Bootstrap 时期"></a>学习的 Bootstrap 时期</h2><p>虽然学习移动端开发，最基本的任务就是去具体尝试一下 Android 和 iOS 上的原生开发，但我的学习路径有一些不同，我使用 Android 也有一段时间了，在大佬云集的许多群聊里听玩机，虽是当时无法理解，但潜移默化之中也知道 Android 里 activity 的概念，知道 apk 是一个压缩包。但同时我也曾玩过很多平台上的 Linux，同为 arm 的树莓派也可以使用 C/C++ 进行愉快的代码编写，那凭什么 Android 那么特殊，封装成了这样呢？</p>
<p>不管如何，让我先来写一些简单的 hello world 吧。在环境安装上纠结了一小段时间后( gradle 坏 )，我成功安装好了 Android Studio，跑通了一些基本的 example，我发现 Android 有个特点，首先，Android 原生开发中，你没有办法在项目里找到 main 函数，而是在 <code>AndroidManifest.xml</code> 里需要注册 <code>MainActivity</code>，如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着在软件打开的时候 MainActivity 的 <code>onCreate()</code> 函数就会被运行，也许这里就是函数的入口点？只能说如今看来，我感觉背后一定有我不知道的隐藏机制，比如 UI 程序常见的事件循环在哪，Android 的 API 库的实现原理是几何，听说 Android 的内核仍然是 Linux，那么 syscall 以及 C 库都怎么样了，OpenGL 库怎么作用的，函数的入口点如何…一口气可以说好多萦绕在我心头的问题，我当然可以选择先放下他们，直接接着学习原生开发，摆弄那些常见的组件，前端的知识，但如今的我终于知道我该以什么切入点查看这个问题了：1.安卓的系统架构，在过去的时间里面我们见过 Linux 发行版的系统架构，比如 wayland 的运行机制，kde 这样的桌面环境是怎么实现的，所以我们也要由此看一眼安卓的，2.app 具体运行是怎么被启动的，那可是 Java/Kotlin 啊，虚拟机又是在什么时候启动的呢？3.安卓本身系统是怎么被启动的</p>
<h2 id="深入一点"><a href="#深入一点" class="headerlink" title="深入一点"></a>深入一点</h2><p>我们都知道 Android 的内核就是 Linux，哪怕它对此进行了一些修改，也不会绕到哪去。那我们就先从安卓本身系统启动来看看，安卓的内核启动了一个类似 systemd 的东西，<code>init</code> 进程，这个是读取 <code>init.rc</code> 配置文件运行一些系统级进程(就是有 root 权限的进程)，比如各种硬件服务：如显示服务、音频服务、Wi-Fi服务等，各种系统守护进程：包括 zygote 和 surfaceflinger 等。其中 zygote 进程相当重要，我们知道在 Linux 上，启动一个进程其实是使用 fork + exec syscall 的，而最开始执行 fork syscall 的，在使用 systemd 的情况下就是这个进程执行的，那么其实在这里，zygote 是被 <code>init</code> fork 出来的，但 zygote 翻译过来本意是受精卵，从寓意上看，他就是负责生成一些其它进程的，事实上也确实如此，在 app 启动时，正是它 fork 出新的进程，新进程是一个 JVM，它可以加载 apk 里的 dex 字节码并开始运行。<br>zygote 会 fork 出其它 Java 的系统级服务，比如 <code>SystemServer</code>，这个进程具有高权限，那么它具体起到什么作用呢，这里先按下不表，请看下文。<br>最终通过这样的方式 launcher 也就是桌面最终会被启动，整个系统便启动完成。</p>
<p>可以看到 zygote 负责了所有 Java 应用的启动，事实上它自己与之前的一些系统进程并非 Java，肯定是原生的代码，而它开始负责所有 Java 程序的启动，因为它直接复制自己这个虚拟机，从 app 的 <code>AndroidManifest.xml</code> 读取 MainActivity 这个类的然后启动，这里要说明的是启动的时候它直接加载 dex，这个只有一些分散的类实现的字节码。而真实的入口函数，则是被藏在系统的代码中，<code>ActivityThread.main()</code></p>
<h2 id="细究-app-的启动"><a href="#细究-app-的启动" class="headerlink" title="细究 app 的启动"></a>细究 app 的启动</h2><p>当你安装一个 apk 文件的时候，其实做的事情并不多，首先 <code>AndroidManifest.xml</code> 会被系统解析变成系统全局的元数据，一般也会在桌面上留下图标，而当你点击这么一个图标的时候，launcher 通过 startActivity() 发送一个 Intent，包含目标应用的包名和入口 Activity 信息。ActivityManagerService (AMS) 会接受这样的信息，接着，如果应用本身并不存在，则会通过进程间通信(IPC) 告诉 zygote 让他生成应用，然后 <code>ActivityThread.main()</code> 执行：初始化主线程的 Looper 和 Handler（消息循环）,调用 attach() 向 AMS 注册当前进程。启动 <code>Looper.loop()</code> 进入消息循环，等待 AMS 的后续指令。这验证了我们的猜想，确实事件循环和入口函数是存在的</p>
<h2 id="Binder-神秘的IPC"><a href="#Binder-神秘的IPC" class="headerlink" title="Binder - 神秘的IPC"></a>Binder - 神秘的IPC</h2><p>Android 有一个很神奇的东西，它有一个 IPC 的驱动，上文提到的 <code>SystemServer</code> 与此有关，用户的应用可以通过 syscall 调用 Binder，与 <code>SystemServer</code> 进行进程间通信，并通过反射机制获取到其中一些全局的类信息与功能，由于 <code>SystemServer</code> 本身具有比较高的权限，它作为系统应用就可以控制向其通信的用户应用的请求，以确保安全性<br>我个人学习到此处的时候觉得，这其实是把一些系统的库变成了一个运行时的东西，也就是通过客户端/服务器模型，让服务器占用高权限，强迫用户进程在低权限，以此保障安全性，而其本质，实质上和 wayland compositor 没什么区别。<br>所以 Android SDK 里的那些库，底层不出意外，除了一些 linux 自己的常用的 read/write 之类的 syscall，如比较上层的电话服务，应该是一个对 IPC 的封装罢了</p>
<h2 id="iOS上呢"><a href="#iOS上呢" class="headerlink" title="iOS上呢"></a>iOS上呢</h2><p>iOS 相对来说比较花哨， SwiftUI 我暂时还没有细看，但是 Objective-C 稍微看了一点，与 Android 不同的是，在书写 oc 程序时，有明显的 main 函数，以及用于启动事件循环的类 <code>UIApplication</code>，其机制与 Qt 十分相似，因此我特意去看了一眼 Qt 的实现，确实 Qt 本身的事件循环只是稍稍对 <code>UIApplication</code> 进行了一层包装，而不是像别的平台真要实现一个事件循环。<br>同时，iOS 本身也有一堆系统进程，出于闭源的原因，只能根据公开的材料猜测，其应当也如同这样，是通过进程间通信来调用通话服务，UI服务等一系列有点高层，但又很底层的东西<br>iOS 没有跑一个虚拟机，oc 会被直接编译成平台代码，所以我觉得 iOS 应该确实要比 Android 快，即使 Android 引入了 aot，应当也不能完全弥补速度差距</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>感觉将有些功能变成高权限进程，通过进程间通信来调用这种动态的”库”，而不是直接一个 glibc 静态的库只调用 syscall 实现是常见的，毕竟后者什么都可以写，但是权限要求相当之高了。似乎这与微内核的想法也是相关的，总之还挺有意思，即使是简单的 hello world 背后也有如此复杂的事情，但所有平台的客户端具体实现又具有统一性，这也许就是软件与系统分层架构之间带来的魅力吧。</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Mobile_device</category>
      </categories>
  </entry>
  <entry>
    <title>行列式</title>
    <url>/posts/336095f8.html</url>
    <content><![CDATA[<h1 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h1><h2 id="1-1-行列式的定义"><a href="#1-1-行列式的定义" class="headerlink" title="1.1 行列式的定义"></a>1.1 行列式的定义</h2><p>我并不是很喜欢我们教材的知识点分布，因为上来就讲行列式是一个很尴尬的事情<br><span id="more"></span></p>
<p>这里的行列式是直接作为一种计算出现在此的，前面用克莱姆法则引入的有些牵强，最关键的定义就是那个公式(那个写成两个逆序数合的我就不写了，本质上就是同一个东西)</p>
<script type="math/tex; mode=display">
\begin{vmatrix}  
  a_{11}& a_{12}& \cdots  & a_{1n} \\  
  a_{21}& a_{22}& \cdots  & a_{2n} \\  
  \vdots & \vdots & \ddots & \vdots \\  
  a_{m1}& a_{m2}& \cdots  & a_{mn}  
\end{vmatrix}  
=\sum_{j_1j_2\cdots jn} (-1)^{\tau(j_1j_2\cdots jn)}a_{1j_1}a_{2j_2}\cdots a_{nj_n}</script><p>这公式很有意思，原因在于其实它是一个加权和，权是一个-1的逆序数的幂次，每个元素则是<strong>每一行(列)取一个数字的所有排序之乘积</strong>，后面有好一些简便运算的结论其实都来自于一个所有排序的和这一个观点。比如通过初等行列变换变为三角形行列式的时候，正是利用了这一观点，你会发现每一行取一个，要想不为0，唯一一个可能就是对角线乘起来</p>
<p>其实系数才是不好求的东西，原定义逆序数是：在一个排序中，如果一个较大的数排在了较小的数的前面，就称这两个数构成一个逆序。一个排列逆序的总数称为该排列的逆序数<br>判定一个排列是奇(偶)排列，这边我找到了一种很好的方法</p>
<h3 id="快速判定排序的奇偶性"><a href="#快速判定排序的奇偶性" class="headerlink" title="快速判定排序的奇偶性"></a>快速判定排序的奇偶性</h3><p>具体查看这种<a href="https://max.book118.com/html/2017/0606/111985347.shtm">神奇的方法</a></p>
<p>在解题之前我们约定：划去两个<strong>连续逆序</strong>的数码或<strong>作一次对换</strong>都记做“-1”，划去两个连续顺序的数码记做“+1”也可以省略不记；<strong>→(i,j)→</strong>表示对换i，j数码一次，数码下加下划线表示要划去的数码。<br>(1)4267351-→42 <u>67</u>351→4 <u>23</u>51-→<u>45</u>1→(+1)→偶排列<br>(2)213486795→<u>21</u> <u>34</u> 8 <u>67</u> 95-→(-1)<u>8 9</u> 5→(-1)→奇排列<br>(3) 513792684 <strong>→(3,6)→</strong> (-1)51<u>67</u>9 <u>23</u>84→(-1)51 <u>98</u>4 <strong>→(1,4)→</strong> (-1)(-1)(-1)<u>54</u>1→&gt;(-1)(-1)(-1)(-1)→+1→偶排列</p>
<p>以此，通过将数字对换，把连续的数字移到一起，以消去剩下常数的方法，最后剩下很小的<strong>原定义</strong>的计算量，在人工手算当中将会大大降低计算量，就是这个其实也不常用罢了。</p>
<h2 id="1-2-行列式的性质"><a href="#1-2-行列式的性质" class="headerlink" title="1.2 行列式的性质"></a>1.2 行列式的性质</h2><p>行列式的计算定理利用它的定义易得，在此不多赘述。几个计算的定理关键点如下：</p>
<ul>
<li>转置最后结果不变</li>
<li>行列交换一次，加一个负号</li>
<li>数乘只算在一行(列)上</li>
<li>如果有两行(列)整体成比例，则值为0</li>
<li>单个行列式的某行可以拆成加法，分别分配到两个其它部分相同的行列式中</li>
</ul>
<p>由此可以推导出最关键的，对<strong>行列式进行初等变换，行列式的值不变。</strong></p>
<p>我这边的习题这一章的技巧很多都是把<em>所有的行加到同一行</em>诶。当然<em>拆成多个行列式相加</em>也是一种化简的手段。</p>
<p>我自己的易错计算点：<br>1.注意把行列式计算，初等行变换结束后，系数要拿出来，于此同时，这个性质矩阵也有相当的不同，因为矩阵的数乘式相对<br>2…</p>
<h2 id="1-3-行列式依行-列-展开"><a href="#1-3-行列式依行-列-展开" class="headerlink" title="1.3 行列式依行(列)展开"></a>1.3 行列式依行(列)展开</h2><p>这里介绍了余子式和代数余子式是什么东西，划去元素 $a_{ij}$ 所在的行与列，剩下的元素按原来的顺序构成的 $n-1$阶行列式，称为元素 $a_{ij}$ 的余子式。</p>
<p>而代数余子式的定义就说明了自己<strong>易错</strong>的特性<br>记 $A_{ij}:=(-1)^{i+j}M_{ij}$ ，元素 $A_{ij}$ 称为元素 $a_{ij}$ 的<strong>代数</strong>余子式。需要很仔细的注意符号的问题</p>
<p>余子项展开的公式没什么好说的，证明也就是纯纯计算而已，很trival。</p>
]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Linear_algebra</category>
      </categories>
  </entry>
  <entry>
    <title>行星运动方程</title>
    <url>/posts/d11d8f41.html</url>
    <content><![CDATA[<h1 id="行星运动方程"><a href="#行星运动方程" class="headerlink" title="行星运动方程"></a>行星运动方程</h1><p>这其实是我高中很早时候好奇算过的一个东西，现在就顺手写出来吧</p>
<span id="more"></span>
<p>在高中学习万有引力定律时，我们采用的是一种简化的模型：将其考虑为匀速圆周运动，但我们仍对现实中行星运动真实的运动轨迹产生了浓厚的兴趣，因此我们小组对此开始了研究。<br>高中课本上使用的模型为,把一个大质量行星看做是固定的，另一个小质量天体是运动的，它们之间存在作用力：</p>
<script type="math/tex; mode=display">F = \frac{GMm}{R^2}</script><p>因此由匀速圆周运动模型得到：</p>
<script type="math/tex; mode=display">m\frac{v^2}{R}=\frac{GMm}{R^2}</script><p>现在我们不引入匀速圆周模型，尝试只用万有引力公式导出运动方程。<br>设大质量天体质量为 $M$，小质量天体质量为 $m$，以大质量天体为参考系，小质量天体的初速度为$v_0=\begin{bmatrix}v_x\\v_y\end{bmatrix}$，初位置为$r_0=\begin{bmatrix}x_0\\y_0\end{bmatrix}$ ，求小质量天体的运动轨迹。</p>
<p>大雾中的万有引力公式：</p>
<script type="math/tex; mode=display">\mathbf{F} = \frac{GMm}{\mathbf{r}^2}\hat{\mathbf{r}}</script><p>计算拉氏量并代入欧拉-拉格朗日方程</p>
<script type="math/tex; mode=display">
T = \frac{1}{2}m(\dot{r}^2+(r\dot{\theta})^2)</script><script type="math/tex; mode=display">
U = -\frac{G(M+m)m}{r}</script><script type="math/tex; mode=display">
L = \frac{1}{2}m(\dot{r}^2+(r\dot{\theta})^2)-\frac{G(M+m)m}{r}</script><p>得到微分方程组：</p>
<script type="math/tex; mode=display">
\left\{\begin{array}{c}
\ddot{\mathrm{r}}-\mathrm{r} \ddot{\theta}^{2}=-\frac{\mathrm{G}(\mathrm{M}+\mathrm{m})}{\mathrm{r}^{2}}\\
\mathrm{r} \ddot{\theta}+2 \dot{\mathrm{r}} \dot{\theta}=0
\end{array}\right.</script><p>设 $l=mr^2\dot{\theta}$，则求导后 $\dot{l}=mr(r\ddot{\theta}+2\dot{r}\dot{\theta})=0$，显然角动量守恒</p>
<p>下面求解方程组，令 $u=\frac{1}{r}$ 换元得到</p>
<script type="math/tex; mode=display">\frac{\mathrm{d}^{2} u}{\mathrm{d} x^{2}}+u=\frac{G(M+m) m^{2}}{l^{2}}</script><p>这是常系数非齐次线性微分方程，解之得：</p>
<script type="math/tex; mode=display">
u=\frac{G(M+m) m^{2}}{l^{2}}+\varepsilon \cos \left(\theta-\theta_{0}\right)</script><script type="math/tex; mode=display">
r=\frac{1}{\frac{G(M+m) m^{2}}{l^{2}}+\varepsilon \cos \left(\theta-\theta_{0}\right)}</script><p>其中 $\varepsilon$，$\theta_0$ 均为任意常数。所以运动轨迹是圆锥曲线。设:</p>
<script type="math/tex; mode=display">c=\frac{G(M+m) m^{2}}{l^{2}}</script><script type="math/tex; mode=display">
r_{0}=\sqrt{x_{0}^{2}+y_{0}^{2}}</script><p>将所有初值带入得到：</p>
<script type="math/tex; mode=display">
\theta_{0}=\arctan \left(-\frac{\left(\frac{1}{r_{0}}-c\right)v_x+c\left(v_{y} \frac{x_{0} y_{0}}{r_{0}{ }^{2}}+v_{x} \frac{x_{0}{ }^{2}}{r_{0}{ }^{2}}\right)}{\left(\frac{1}{r_{0}}-c\right)v_y+c\left(v_{x} \frac{x_{0} y_{0}}{r_{0}{ }^{2}}+v_{y} \frac{y_{0}{ }^{2}}{r_{0}{ }^{2}}\right)}\right)</script><script type="math/tex; mode=display">
\varepsilon=\frac{1-c r_{0}}{x_{0} \cos \theta_{0}+y_{0} \sin \theta_{0}}</script><p>整理得到最后的式子：</p>
<script type="math/tex; mode=display">
\rho=\frac{1}{\frac{G(M+m) m^{2}}{l^{2}}+\varepsilon \cos \left(\theta-\theta_{0}\right)}</script><p>其中</p>
<script type="math/tex; mode=display">
\theta_{0}=\arctan \left(-\frac{\left(\frac{1}{r_{0}}-\frac{G(M+m) m^{2}}{l^{2}}\right)v_x+\frac{G(M+m) m^{2}}{l^{2}}\left(v_{y} \frac{x_{0} y_{0}}{r_{0}{ }^{2}}+v_{x} \frac{x_{0}{ }^{2}}{r_{0}{ }^{2}}\right)}{\left(\frac{1}{r_{0}}-\frac{G(M+m) m^{2}}{l^{2}}\right)v_y+\frac{G(M+m) m^{2}}{l^{2}}\left(v_{x} \frac{x_{0} y_{0}}{r_{0}{ }^{2}}+v_{y} \frac{y_{0}{ }^{2}}{r_{0}{ }^{2}}\right)}\right)</script><script type="math/tex; mode=display">
\varepsilon=\frac{1-\frac{G(M+m) m^{2}}{l^{2}} r_{0}}{x_{0} \cos \theta_{0}+y_{0} \sin \theta_{0}}</script><p>在其中的其中</p>
<ul>
<li>当$|\varepsilon| &gt; | \frac{G(M+m) m^{2}}{l^{2}} |$，轨迹为双曲线</li>
<li>当$|\varepsilon| = | \frac{G(M+m) m^{2}}{l^{2}} |$，轨迹为抛物线</li>
<li>当$|\varepsilon| &lt; | \frac{G(M+m) m^{2}}{l^{2}} |$，轨迹为椭圆</li>
</ul>
<p>使用如下的仓库中的代码可以模拟及验证行星运动时的轨迹</p>
<p><a href="https://github.com/feipiao594/Simple-Planet-Orbit">https://github.com/feipiao594/Simple-Planet-Orbit</a></p>
<p><strong>显示双曲线</strong><br><img src="/images/行星运动方程_图1.png" width="100%" height="100%"></p>
<p><strong>显示椭圆</strong><br><img src="/images/行星运动方程_图2.png" width="100%" height="100%"></p>
]]></content>
      <categories>
        <category>Physics</category>
        <category>Mechanics</category>
      </categories>
  </entry>
  <entry>
    <title>贝塞尔曲线</title>
    <url>/posts/cc351245.html</url>
    <content><![CDATA[<h1 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h1><p>平滑的曲线，计算机图形学的天堂，线性代数的产物<br>同时这篇文章也是关于嵌入html与js的测试</p>
<span id="more"></span>
<p><strong>贝塞尔曲线方程</strong></p>
<p>$ P(t)= {\textstyle \sum_{i=0}^{n}} P_iB_{i,n}(t),t\in [0,1] $</p>
<p>对于$ i\in N^* $</p>
<p>$ B_{i,n}(t)=C_n^it^i(1-t)^{n-i}=\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i} $</p>
<h2 id="推导过程"><a href="#推导过程" class="headerlink" title="推导过程"></a>推导过程</h2><p>To be continue</p>
<h2 id="演示程序"><a href="#演示程序" class="headerlink" title="演示程序"></a>演示程序</h2><p>搬运自知乎id 何方<br>原地址<a href="https://zhuanlan.zhihu.com/p/180508343">https://zhuanlan.zhihu.com/p/180508343</a><br>侵权删，等博主学习了一些前端后，会自己重写</p>
<body>
    <style>
        .buttonContainer button {
            border-radius: 5px;
            border: none;
            background-color: #66ccff31;
            height: 30px;
            width: 54px;
            box-shadow: 2px 2px 2px 2px rgba(0 0 0 / 0.4);
            margin-right: 10px;
        }
    </style>
    <canvas id="canvas" style="border: 1px solid" width="500%" height="500%"></canvas>
    <div class="buttonContainer">
        <div>
            <button id="draw">画图</button>
            <button id="reDraw">重画</button>
            <button id="clear">清空</button>
            <button id="radom">随机</button>
        </div>
    </div>
    <script>
        const cv = document.getElementById("canvas");
        const draw = document.getElementById("draw");
        const clear = document.getElementById("clear");
        const reDraw = document.getElementById("reDraw");
        if (/Mobi|Android|iPhone/i.test(navigator.userAgent)) {
            cv.height = 290;
            cv.width = 290;
        }
        let points = [];
        const ctx = cv.getContext("2d");
        let offset = 0;
        let timer;
        function calcMiddlePoint(p1, p2) {
            return { x: (p2.x - p1.x) * offset + p1.x, y: (p2.y - p1.y) * offset + p1.y };
        }
        let finalPoints = [];
        function drawLine() {
            let last = {}
            ctx.strokeStyle = "red";
            ctx.lineWidth = 3;
            ctx.beginPath();
            finalPoints.forEach(({ x, y }, index) => {
                if (index === 0) {
                    ctx.moveTo(x, y)
                } else {
                    ctx.lineTo(x, y)
                }
            });
            ctx.stroke();
        }
        function drawLines(ps, color) {
            if (ps.length < 2) {
                const { x, y } = ps[0];
                finalPoints.push({ x, y });
                drawLine();
                return;
            }
            ctx.lineWidth = 1;
            ctx.strokeStyle = color || "green";
            ctx.beginPath();
            for (let i = 0; i < ps.length; i++) {
                const { x, y } = ps[i];
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            const pps = [];
            for (let i = 0; i < ps.length - 1; i++) {
                pps.push(calcMiddlePoint(ps[i], ps[i + 1], .5));
            }
            drawLines(pps)
        }
        function doDraw() {
            if (points.length < 2) {
                alert(`无法画图，请至少指定2个点`);
                return;
            }
            timer && clearInterval(timer);
            drawLines(points, 'blue');
            timer = setInterval(() => {
                offset += 0.001;
                window.requestAnimationFrame(() => {
                    ctx.clearRect(0, 0, cv.width, cv.height);
                    drawLines(points, 'blue');
                });
                if (offset >= 1) {
                    clearInterval(timer);
                }
            }, 1);
        }
        reDraw.addEventListener("click", function () {
            finalPoints = [];
            offset = 0;
            ctx.clearRect(0, 0, cv.width, cv.height);
            doDraw();
        });
        draw.addEventListener("click", doDraw);
        clear.addEventListener("click", () => {
            points = [];
            finalPoints = [];
            offset = 0;
            ctx.clearRect(0, 0, cv.width, cv.height);
        });
        cv.addEventListener("click", function (e) {
            points.push({ x: e.offsetX, y: e.offsetY });
            console.log("point:", { x: e.offsetX, y: e.offsetY });
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.arc(e.offsetX, e.offsetY, 2, 0, Math.PI * 2);
            ctx.fill();
        });
        radom.addEventListener("click", () => {
            points = [];
            finalPoints = [];
            offset = 0;
            ctx.clearRect(0, 0, cv.width, cv.height);
            for (let i = 0; i < 10; i++) {
                points.push({ x: Math.random() * cv.width, y: Math.random() * cv.height })
            }
            doDraw();
        });
    </script>
</body>]]></content>
      <categories>
        <category>Mathematic</category>
        <category>Linear_algebra</category>
      </categories>
  </entry>
  <entry>
    <title>遨游在内存中的硬件启动过程</title>
    <url>/posts/42db1e6.html</url>
    <content><![CDATA[<h1 id="遨游在内存中的硬件启动过程"><a href="#遨游在内存中的硬件启动过程" class="headerlink" title="遨游在内存中的硬件启动过程"></a>遨游在内存中的硬件启动过程</h1><p>2024.9.28 <code>.NET Conf</code> 介绍话题，话题来自我之前对硬件启动过程的好奇</p>
<span id="more"></span>
<h2 id="叠甲"><a href="#叠甲" class="headerlink" title="叠甲"></a>叠甲</h2><blockquote>
<p><strong>NOTE</strong>: 我并非一个专于底层设计的开发者，对计算机的底层结构仍然有很多的不解与困惑，因而本文可能包含不少问题，如果发现了错误，请一定要在联系我/评论区发送你的修改意见</p>
</blockquote>
<h2 id="一时兴起"><a href="#一时兴起" class="headerlink" title="一时兴起"></a>一时兴起</h2><p>相比大家学习计算机时可能会产生这样的困惑：计算机是怎么被拉起启动的，也许学习”计算机组成原理”能回答你的一部分问题，它会告诉你计算机上电后会进行一系列的检查，接着调用 BIOS，进入 Bootloader 阶段，最终拉起 OS ，进入熟悉的页面</p>
<p>但是在这之中仍然有很多未知的事情，例如，计算机进行的这一系列检查的过程理论上讲也是一种过程，这种检查的逻辑在没有软件的阶段是谁来解决的？在内存被初始化前，其无法存储信息，此时此刻 BIOS 是怎么被执行的？</p>
<p>接下来的文章内容会对解决这些<del>对你们毫无用处的</del>问题提供一些<del>可能解释不清楚的</del>帮助</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>照顾到大家有些同学可能对 计算机组成原理/体系结构 并没有太多的了解，我们来简单讲一讲计算机的基础概念</p>
<p>CPU在加电后，它首先会调用 BIOS/UEFI 会进行一系列操作，比如 上电检查，切换保护模式等等。这些操作目的是检查硬件，训练内存，为下一阶段提供环境，最后会调用你磁盘上的下一段程序，一般是 Bootloader 常见的有 Windows 下的 Windows Boot Manager ，Linux 下的 SystemBoot/Grub 等等，而 Bootloader 会拉起 OS ，OS 在启动阶段将接过 BIOS/UEFI 与 Bootloader 为你准备的所有前置环境，由操作系统掌管权力开启新的天地</p>
<p>通常我们简单讲讲就会这么解释。对于开发者来说，再底层也不过就是 Bootloader 级别的，在裸机上写 OS 等等的操作。但其实这个裸机一点都不”裸”，它具有相当完善的环境，以至于你可以进一步开天辟地，从而有了 OS。</p>
<p>我们今天就讨论一些比 Bootloader/OS 还要底层的 BIOS</p>
<h2 id="RAM-amp-ROM-在-CPU-看来都是-Memory"><a href="#RAM-amp-ROM-在-CPU-看来都是-Memory" class="headerlink" title="RAM &amp; ROM 在 CPU 看来都是 Memory"></a>RAM &amp; ROM 在 CPU 看来都是 Memory</h2><p>如果说大家写代码写多了，会时常觉得 Memory 貌似是一种可读可写的东西，但是我们要指出 Memory 并不是那么简单的东西，事实上 ROM 也是一种 Memory</p>
<p>我们常说 BIOS/UEFI 是 ROM ，所以它也是内存，内存要怎么访问？当然是通过地址，CPU 才不管你是内存条还是一个 BIOS 芯片，CPU 只是需要像读取普通的 DRAM 一样读取数据就行了，而作为从属于 CPU 完全听从其指导的芯片就考虑的多了</p>
<p>也许大家很难理解，但是事实上是，存储器前都不是直连 CPU 的地址总线的，而是通过了一个 <strong>内存控制器</strong>(Memory Controller，简称 MC)的东西，它的真身本体是在北桥当中的。而在现在的 CPU 中，北桥已经被完全封装在 CPU 内部的，内存控制器会将 地址总线 分别映射到输出总线，连接到实际的设备上(比较常见的是通过PCIe总线)</p>
<blockquote>
<p>但上古时期的 8086 确实是通过地址总线直连内存颗粒的</p>
</blockquote>
<h2 id="揭秘启动过程"><a href="#揭秘启动过程" class="headerlink" title="揭秘启动过程"></a>揭秘启动过程</h2><p>在计算机启动到 Reset Vector 所指向的第一条指令被 CPU 运行之间的各种硬件安全检查这些纯硬件的专业部分我们先按下不表，我们来看计算机怎么获取到 BIOS 里的信息的</p>
<h3 id="第一条指令"><a href="#第一条指令" class="headerlink" title="第一条指令"></a>第一条指令</h3><p>首先，CPU 核会发出一个取指的指令，这个指令会传递给北桥，北桥此时此刻也是一个被 reset ，北桥内有一个被成为 PAM 的寄存器，每个 PAM 寄存器分为两个半字节，半字节有两个保留位，一个读使能和写使能位。每个半字节对应 16k 的 内存空间，但 PAM[0] 对应的是 32k。</p>
<p>通过设置 PAM 寄存器的值可以规定某一块 CPU 核的内存空间所对应的是实际真正的 RAM ，还是转发到 PCI 域中，Reset Vector 所在的地址空间对应的 PAM 寄存器缺省的值就是将 CPU 取指的指令转发到 PCI 域中，那么取指的信号就从 DMI 总线(这其实是基于 PCIe 总线的)，发送到南桥，南桥芯片组又会把这个取指信号处理发给下一级，最终到达 BIOS ROM 芯片上，原路返回，这样 CPU 就能获取到第一条命令了，接下来的事情就都简单起来了</p>
<p>顺带一提，在 BIOS ROM 是一种支持在线运行的存储器，这意味着指令直接读取就运行，但是对 BIOS ROM 的一切写指令都将被中间过程给拒绝掉</p>
<p>在 BIOS ROM 运行的同时，机器会将 BIOS ROM 的内容复制到 RAM 中，在内存控制器给与这一块 RAM 只读的属性，更改 PAM 的值，让它从转发到 PCI 域的状态切换成直接访问 RAM，提高 ROM 运行的效率</p>
<h3 id="简单认识一下-UEFI"><a href="#简单认识一下-UEFI" class="headerlink" title="简单认识一下 UEFI"></a>简单认识一下 UEFI</h3><p>UEFI 的七个阶段</p>
<ol>
<li>SEC(安全验证)</li>
<li>PEI(EFI前期初始化)</li>
<li>DXE(驱动执行环境)</li>
<li>BDS(启动设备选择)</li>
<li>TSL(操作系统加载前期)</li>
<li>RT(Run Time)</li>
<li>AL(系统灾难恢复期)</li>
</ol>
<p>我们不会对此进行详细的介绍，UEFI 提供了一种统一的方式，它所干的事情就是做安全检查，为操作系统启动准备环境</p>
<p>UEFI 时期已经完成了对文件系统的支持，他会读取即 EFI 系统分区中的 <code>*.efi</code> 文件，并且启动它，通常来说这个程序是一个 Bootloader ，但是其实也能是其他任何东西，总之这就是我们常说的裸机程序了</p>
<h2 id="好用的工具推荐"><a href="#好用的工具推荐" class="headerlink" title="好用的工具推荐"></a>好用的工具推荐</h2><p><strong>RW-Everything</strong> <a href="https://rweverything.com/">https://rweverything.com/</a><br>奇妙的小工具，能让你的内存旋转</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Computer_composition</category>
      </categories>
  </entry>
  <entry>
    <title>链接、装载与库</title>
    <url>/posts/8525127.html</url>
    <content><![CDATA[<h1 id="链接、装载与库"><a href="#链接、装载与库" class="headerlink" title="链接、装载与库"></a>链接、装载与库</h1><p>对于多文件的开发过程来说，关于这一些东西我确实是欠缺的，正好有机会接触《程序员的自我修养——链接、装载与库》一书，初读也是感受颇深。就随着认知增长一点一点记录一些东西吧</p>
<span id="more"></span>
<h2 id="一、关于Extern"><a href="#一、关于Extern" class="headerlink" title="一、关于Extern"></a>一、关于Extern</h2><p>在C/C++中声明一个外部变量需要用到extern关键字，而外部函数声明却是可以省略extern的，不需要额外添加关键字，在动态链接当中，将cpp编译为ELF/PE格式后将其置于调用其的cpp文件相同的路径之下，并保留头文件，利用编译器进行编译，以我不成熟的理解，可以想象它仍然是cpp文件，只不过先被处理成了二进制而已<br>了解了头文件的作用，其实动态链接的时候不用头文件也是可以的，可以将其内容直接加到，所以那些头文件里的函数声明其实是一个外部函数的声明，故而不应该在那个为止将函数定义出来。<br>假设有如下一种情况代码如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*------myfun.h------*/</span></span><br><span class="line"><span class="type">int</span> exa = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------myfun.cpp------*/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myfun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*------main.cpp------*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myfun.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在myfun.cpp成为so库的时候，其实int是被声明成这so的模块的全局变量，但当我们拿myfun.h使用的时候，它就变成了main.cpp这个模块里再次定义的东西了(没有extern)，需要改。另外建议别在头文件里定义什么东西，否则会出现一些重复定义的问题。其实头文件对计算机而言没什么作用，她只是在<strong>预编译</strong>时在#include的地方<strong>展开</strong>一下，没别的意义了，其实头文件主要是给别人看的。</p>
<h2 id="二、神奇的强弱符号"><a href="#二、神奇的强弱符号" class="headerlink" title="二、神奇的强弱符号"></a>二、神奇的强弱符号</h2><p>我们经常在编程中碰到一种情况叫符号重复定义。多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。通常对于全局变量来说，初始化后均为强符号，未初始化为弱符号，弱符号在链接时候会被强符号替代，我们可以通过GCC的<code>__attribute__((weak))</code>来定义任何一个强符号为弱符号。<br>对于它们，下列三条规则使用：</p>
<ul>
<li>同名的强符号只能有一个，否则编译器报”重复定义”错误。</li>
<li>允许一个强符号和多个弱符号，但定义会选择强符号的。</li>
<li>当有多个弱符号相同时，链接器选择内存占用最大的那个。<br>所以说，我们可以通过定义自己的库函数是强符号，而用户使用的时候定义弱符号，以此来观察是否能够调用库函数，或者用户函数。太神奇了。<br>但是弱函数也不能胡乱使用，第三点规则已经说明了问题。</li>
</ul>
<h2 id="三、argc和argv"><a href="#三、argc和argv" class="headerlink" title="三、argc和argv[ ]"></a>三、argc和argv[ ]</h2><p>其中<code>argc</code>是外部输入的参数个数，<code>argv[ ]</code>是参数的字符串数组。即在命令行执行时后面跟着的参数。</p>
]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>Computer_composition</category>
      </categories>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/posts/49c1fbdc.html</url>
    <content><![CDATA[<h1 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h1><p>以下给出高精度加法与高精度乘法的模板</p>
<span id="more"></span>
<h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 520</span></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string A, B;</span><br><span class="line">	cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="type">int</span> len = A.<span class="built_in">length</span>() &gt; B.<span class="built_in">length</span>() ? A.<span class="built_in">length</span>() : B.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">length</span>() - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">		a[j] = A[i] - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//必须从低位到高位进行处理，故而j=1，i=l-1；char转int要减0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = B.<span class="built_in">length</span>() - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++) &#123;</span><br><span class="line">		b[j] = B[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">		c[i] += a[i] + b[i];</span><br><span class="line">		c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">		c[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;<span class="comment">//for循环不够熟练</span></span><br><span class="line">	<span class="keyword">if</span> (c[len])len++;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 520</span></span><br><span class="line"><span class="type">int</span> a[N], b[N], c[N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	string A, B;</span><br><span class="line">	cin &gt;&gt; A &gt;&gt; B;</span><br><span class="line">	<span class="type">int</span> len = A.<span class="built_in">length</span>() + B.<span class="built_in">length</span>();</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = A.<span class="built_in">length</span>() - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)a[j] = A[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = B.<span class="built_in">length</span>() - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--, j++)b[j] = B[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= A.<span class="built_in">length</span>() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= B.<span class="built_in">length</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			c[j + i] += a[j] * b[i];<span class="comment">//计算贡献，位于i+j上，注意这里的i和j后面都有数组所带的-1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="comment">//for循环不够熟练</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len - <span class="number">1</span>; i++) &#123;<span class="comment">//转换到加法就是把贡献放到这里算</span></span><br><span class="line">		c[i + <span class="number">1</span>] += c[i] / <span class="number">10</span>;</span><br><span class="line">		c[i] %= <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (; !c[len - <span class="number">1</span>] &amp;&amp; len &gt; <span class="number">1</span>; len--);<span class="comment">//加法里只需考虑一次，无需循环</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">		cout &lt;&lt; c[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CS_计算机</category>
        <category>Basic_principles</category>
        <category>DSA</category>
      </categories>
  </entry>
</search>
