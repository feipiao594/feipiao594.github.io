<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"feipiao594.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="引用本篇介绍C++相比于C语言特有的引用语法，包含c++11特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++引用">
<meta property="og:url" content="https://feipiao594.github.io/posts/101de459.html">
<meta property="og:site_name" content="594飞飘的个人博客">
<meta property="og:description" content="引用本篇介绍C++相比于C语言特有的引用语法，包含c++11特性。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-12-07T16:00:00.000Z">
<meta property="article:modified_time" content="2024-10-27T07:57:38.592Z">
<meta property="article:author" content="594飞飘">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://feipiao594.github.io/posts/101de459.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++引用 | 594飞飘的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="594飞飘的个人博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">594飞飘的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学习笔记与生活记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页 | Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于 | About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类 | Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时轴 | Timeline</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链 | Links</a>

  </li>
        <li class="menu-item menu-item-rss">

    <a href="/atom.xml" rel="section"><i class="fa fa-rss fa-fw"></i>订阅 | Rss</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索 | Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://feipiao594.github.io/posts/101de459.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/feipiao.gif">
      <meta itemprop="name" content="594飞飘">
      <meta itemprop="description" content="Pray to take back the sunflower that was given out from the bottom of my heart.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="594飞飘的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++引用
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-12-08 00:00:00" itemprop="dateCreated datePublished" datetime="2022-12-08T00:00:00+08:00">2022-12-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-10-27 15:57:38" itemprop="dateModified" datetime="2024-10-27T15:57:38+08:00">2024-10-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">CS_计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-%E8%AE%A1%E7%AE%97%E6%9C%BA/Programming-Language/" itemprop="url" rel="index"><span itemprop="name">Programming_Language</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS-%E8%AE%A1%E7%AE%97%E6%9C%BA/Programming-Language/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>本篇介绍C++相比于C语言特有的引用语法，包含c++11特性。<br><span id="more"></span></p>
<h2 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h2><p>在C++11前，只有一种引用，那就是左值引用。在C++11中新加入了右值引用并且添加了许多实用的新特性。</p>
<ul>
<li>在该小标题下指的引用均为左值引用</li>
</ul>
<hr>
<p>引用变量是一个别名，也就是说，它是某个已存在变量的<strong>另一个名字</strong>。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> d = <span class="number">321.0</span>;</span><br><span class="line"><span class="type">int</span>&amp;  r = i;</span><br><span class="line"><span class="type">double</span>&amp; s = d;</span><br><span class="line"><span class="comment">//创建了两个引用，即别名</span></span><br></pre></td></tr></table></figure>
<p>引用其实本身的类型等价于<code>const typename *</code><br>这就导致了它有如下的特点：</p>
<ul>
<li>一个变量可取多个别名。</li>
<li>引用必须初始化。</li>
<li>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量。</li>
</ul>
<p>每次调用左值引用其实都<strong>暗含了一步取地址</strong>的过程<br>因为左值引用本质上<strong>存储的是地址</strong>，着意味着可以把<strong>引用当成是一种特殊的指针</strong>，但并不是说其本质就是指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典例子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">   temp = x; <span class="comment">/* 保存地址 x 的值 */</span></span><br><span class="line">   x = y;    <span class="comment">/* 把 y 赋值给 x */</span></span><br><span class="line">   y = temp; <span class="comment">/* 把 x 赋值给 y  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>返回左值引用的函数可以作为左值</strong>，但引用可以看作指针，故而要<strong>当心引用空悬</strong>的问题，例子如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">get_val</span><span class="params">(string &amp;str, string::size_type ix)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">       <span class="built_in">get_val</span>(s, <span class="number">0</span>) = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//返回左值引用的函数作为左值</span></span><br><span class="line">       cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="值传递和引用传递的差别"><a href="#值传递和引用传递的差别" class="headerlink" title="值传递和引用传递的差别"></a>值传递和引用传递的差别</h2><p>值传递是指参数列表里的类型不是引用的，在这种情况下，如果类型是类的话，其实在传递参数时是会调用拷贝构造，而引用在传递参数的时候则不会。</p>
<p>因而拷贝构造函数不能使用值传递，若拷贝构造函数采用传值传参，用<code>date1</code>去初始化<code>date2</code>，会调用<code>Date (Date d)</code>，当<code>Date d = date1</code>时，相当于<code>Date d (d1)</code>，此时又会调用拷贝构造函数，如此循环导致无穷递归。</p>
<hr>
<h2 id="左值-amp-右值"><a href="#左值-amp-右值" class="headerlink" title="左值&amp;右值"></a>左值&amp;右值</h2><p>也许上面的左值引用完全不怎么需要在意左值右值的差别，但要想进一步区分左值引用和右值引用之间的差别，必须先了解C++11中左右值，将亡值的区分</p>
<ul>
<li>C++11中将右值拓展为 <strong>纯右值 <em>(prvalue)</em></strong> 和 <strong>将亡值 <em>(xvalue)</em></strong><ul>
<li><strong>纯右值</strong>：非引用返回的临时变量，运算表达式的结果，字面常量</li>
<li><strong>字符串字面量</strong>是左值，而且是不可被更改的左值。字符串字面量并不具名，但是可以用&amp;取地址所以也是左值。<br><strong>(a+1)，a为int[10]</strong>，这种状态下也是左值<br><strong>返回左值引用的函数</strong>可以作为左值</li>
<li><strong>将亡值</strong>：与右值引用相关的表达式 如：将要被移动的对象，<code>T&amp;&amp;</code>函数返回的值，<code>std::move()</code>的返回值，转换成<code>T&amp;&amp;</code>的类型的转换函数的返回值</li>
</ul>
</li>
</ul>
<p>左值右值判断方法精简：</p>
<ul>
<li>如果你可以对一个表达式取地址，那这个表达式就是个左值。</li>
<li>如果一个表达式的类型是一个左值引用 (例如, <code>T&amp;</code> 或 <code>const T&amp;</code>, 等.)，那这个表达式就是一个左值。如:返回左值引用的函数</li>
<li>其它情况，这个表达式就是一个右值。从概念上来讲(通常实际上也是这样)，右值对应于临时对象，例如函数返回值或者通过隐式类型转换得到的对象，大部分字面值(e.g.<code>10</code>和<code>5.3</code>)也是右值。</li>
</ul>
<hr>
<h2 id="右值引用-rvalue-reference"><a href="#右值引用-rvalue-reference" class="headerlink" title="右值引用 (rvalue reference)"></a>右值引用 <em>(rvalue reference)</em></h2><p>C++11中增加右值引用，在C++98中的引用都称为<strong>左值引用 (lvalue reference)</strong><br>右值引用就是给右值取别名，新名字就是左值。如果一个prvalue被绑定到一个引用上，它的<strong>生命周期则会延长到跟这个引用变量一样长</strong>。也正因为如此，右值引用不用担心引用空悬的问题。(反正你也解绑不了，寿命延长了我也杀不掉你)<br>右值引用本身是不可修改绑定的左值，但<strong>可以通过它修改右值</strong><br>右值引用本身也仍然是一个指针，只是指向的值是匿名的罢了<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov   dword ptr [rbp+0A4h],0Ah</span><br><span class="line">lea   rax,[rbp+0A4h]</span><br><span class="line">mov   qword ptr [c],rax</span><br></pre></td></tr></table></figure><br>这里在语法中所谓不能寻址的右值，它的位置其实也是栈上(rbp+0A4h)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = <span class="number">10</span>; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = num;<span class="comment">//错误，左值不能赋给右值引用</span></span><br><span class="line">c+=<span class="number">1</span>; <span class="comment">//正确，右值10变为11</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="常量左值引用-const-lvalue-reference"><a href="#常量左值引用-const-lvalue-reference" class="headerlink" title="常量左值引用 (const lvalue reference)"></a>常量左值引用 <em>(const lvalue reference)</em></h2><ul>
<li>常量左值引用，可以绑定左值和右值，但不能更改引用的值，<strong>常量左值引用</strong>绑定右值时如同右值引用，也可以<strong>延长右值的生命周期</strong>与自身相同。可以把绑定右值的常量左值引用看作不可修改<code>其绑定的右值</code>的右值引用。(注意一下语序)</li>
<li>非常量左值引用只能绑定左值，右值引用只能绑定右值。</li>
<li>常量右值引用目前暂无作用。据我测试就是个只能传入右值的常量左值引用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;              <span class="comment">//非常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a1=<span class="number">10</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a2=<span class="number">20</span>;       <span class="comment">//常量左值（有确定存储地址，也有变量名）</span></span><br><span class="line"><span class="comment">//非常量左值引用</span></span><br><span class="line"><span class="type">int</span> &amp;b1=a;            <span class="comment">//正确，a是一个非常量左值，可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b2=a1;           <span class="comment">//错误,a1是一个常量左值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b3=<span class="number">10</span>;           <span class="comment">//错误，10是一个非常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="type">int</span> &amp;b4=a1+a2;        <span class="comment">//错误,（a1+a2）是一个常量右值，不可以被非常量左值引用绑定</span></span><br><span class="line"><span class="comment">//常量左值引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c1=a;      <span class="comment">//正确，a是一个非常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c2=a1;     <span class="comment">//正确,a1是一个常量左值，可以被非常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c3=a+a1;   <span class="comment">//正确，（a+a1）是一个非常量右值，可以被常量右值引用绑定</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c4=a1+a2;  <span class="comment">//正确,（a1+a2）是一个常量右值，可以被非常量右值引用绑定</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="当函数和引用打架的时候-误"><a href="#当函数和引用打架的时候-误" class="headerlink" title="当函数和引用打架的时候(误)"></a>当函数和引用打架的时候(误)</h2><p>引用之所以难，因为其与许多东西扯上了关系，模板，传参等等。<br>直接开始把<em>移动语义</em>，<em>完美转发</em>，<em>万能引用</em>分开来看比较分立，我也是看的头疼，如果从函数角度入手，叙述这些概念会更清晰些。</p>
<h3 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h3><ul>
<li>返回一般简单类型或者返回类类型的函数，如<code>int fun1(int a)</code>或者<code>char* fun2()</code>这种函数，返回值为纯右值</li>
<li>返回值为左值引用的函数，上方讨论过，返回值为左值。</li>
<li>返回值为右值引用的函数，返回值为将亡值</li>
</ul>
<p>对于<strong>底层</strong>来说，无论是用右值引用还是普通变量保存返回值，最终在函数返回时都是通过eax寄存器保存的。区别在于：</p>
<ul>
<li>普通变量：就直接将eax赋值给普通变量</li>
<li>右值引用：就将eax的值放到另一个位置（临时变量），然后再将这个位置的地址赋值到右值引用上。</li>
<li>常量左值引用： 和右值引用是一样的效果，只是常量左值引用就不可以修改这个临时变量而已<br>（所以函数返回值的临时变量不是一直存在的，要看返回时用什么类型的变量来接收）</li>
</ul>
<h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>正如正常的函数一般，函数可以被重载为如参数分别为<code>int&amp; a</code> <code>int&amp;&amp; a</code>,那样将会对左右值属性不同的参数编译器调用不同的函数。</p>
<h2 id="移动语义-std-move"><a href="#移动语义-std-move" class="headerlink" title="移动语义 std::move()"></a>移动语义 <code>std::move()</code></h2><p>首先来讲讲我们为什么需要移动语义，很多时候我们只是单纯创建一些右值，然后赋给某个对象用作构造函数。<br>这时候会出现的情况是，我们首先需要在main函数里创建这个右值对象，然后复制给这个对象相应的成员变量。<br>如果我们可以直接把这个右值变量移动到这个成员变量而不需要做一个额外的复制行为，程序性能就这样提高了。<br>而这些操作正是通过右值引用这个类型的诞生，才使得拷贝和移动语义的分离。<br>可以说引入右值引用的目的就是为了引入移动语义。</p>
<ul>
<li>拷贝堆区对象需要重写拷贝构造函数和赋值函数，实现深拷贝</li>
<li>如果堆区源对象是临时对象（右值），深拷贝会造成无意义的内存申请和释放操作</li>
<li>C++11的移动语义可以直接使用源对象，可以提高效率。</li>
</ul>
<p>例如把指针指向已经生成的堆区上对象，把传入参数的指针设置为nullptr，这样就可以减少无谓的new与delete，减少拷贝花费的时间。</p>
<p>移动语义需要的两个函数</p>
<ul>
<li>移动构造函数<br><code>className(className&amp;&amp; object) &#123;&#125;</code></li>
<li>移动赋值函数<br><code>className&amp; operator=(className&amp;&amp; object) &#123;&#125;</code></li>
</ul>
<p>举个例子<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//特别注意，这里有可能会导致内存泄漏，实际应用需要改写析构函数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">demo&amp;&amp; <span class="title">new_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">   demo a = <span class="keyword">new</span> <span class="built_in">demo</span>();</span><br><span class="line">   demo&amp;&amp; b = a;</span><br><span class="line">   <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在这里<code>get_demo()</code>返回纯右值，被移动构造函数捕获。<br><strong>output</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">construct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">move construct!</span><br><span class="line">class destruct!</span><br><span class="line">class destruct!</span><br></pre></td></tr></table></figure></p>
<h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move()"></a>std::move()</h2><p>可以将左值变为右值的函数，用于左值的移动语义。<br>我们可以用std::move实现高效的swap函数<br>在不使用 Move 语义的情况下<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(A &amp;a1, A &amp;a2)&#123;</span><br><span class="line">    <span class="function">A <span class="title">tmp</span><span class="params">(a1)</span></span>; <span class="comment">// 拷贝构造函数一次，涉及大量数据的拷贝</span></span><br><span class="line">    a1 = a2;   <span class="comment">// 拷贝赋值函数调用，涉及大量数据的拷贝</span></span><br><span class="line">    a2 = tmp;  <span class="comment">// 拷贝赋值函数调用，涉及大量数据的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果使用Move语义，即加上移动构造函数和移动赋值函数：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap_A</span><span class="params">(A &amp;a1, A &amp;a2)</span></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">tmp</span><span class="params">(std::move(a1))</span></span>; <span class="comment">// a1 转为右值，移动构造函数调用，低成本</span></span><br><span class="line">    a1 = std::<span class="built_in">move</span>(a2);   <span class="comment">// a2 转为右值，移动赋值函数调用，低成本</span></span><br><span class="line">    a2 = std::<span class="built_in">move</span>(tmp);  <span class="comment">// tmp 转为右值移动给a2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="引用折叠-reference-collapsing"><a href="#引用折叠-reference-collapsing" class="headerlink" title="引用折叠 (reference collapsing)"></a>引用折叠 <em>(reference collapsing)</em></h2><p>引用折叠是指在<strong>模板</strong>函数进行类型推导的时候，发生的编译器解决矛盾的事件，而这个矛盾就是推导得到了引用的引用，这在是C++不被允许的。<br>引用折叠发生在函数和模板参数传递的过程中。另外，由于编译器优化的存在使得特定条件下非引用对象会自动转换为引用对象。<br>下面是一个小例子：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意在参数传递的时候由于传递的是引用，其实是不会引起复制的，值传递的话是会引起复制的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">const</span> T&amp; a)</span></span>;</span><br><span class="line">std::string&amp; str = std::<span class="built_in">string</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="built_in">fun</span>(str);</span><br></pre></td></tr></table></figure><br>上面代码中实参str的类型为std::string&amp;, 形参a被标记为<code>std::string &amp; const &amp;</code> = <code>const std::string&amp;</code><br>具体的折叠规则如下</p>
<blockquote>
<p>T&amp;&amp; &amp;&amp;  -&gt; T&amp;&amp;<br> T&amp;&amp; &amp;   -&gt; T&amp;<br> T&amp; &amp;&amp;   -&gt; T&amp;<br> T&amp; &amp;    -&gt; T&amp;</p>
</blockquote>
<p>即左值引用具有传染性，右值引用是万能引用。<br>万能引用指可以接受一切引用非引用形式的参数。<br>而前者则不能传递纯右值，将亡值<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; t)</span></span>;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 <code>std::forward</code></h2><p>在函数模板中，可以将自己的参数“完美地”转发给其他函数，即准确转发参数的值和左右值属性</p>
<ul>
<li>能否实现完美转发，决定了该参数在传递过程中用的是拷贝语义还是移动语义</li>
</ul>
<p>以下实现方式中，<code>func2()</code>可以调用两个重载版本，<code>func1()</code>无法调用rvalue重载版本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;         <span class="comment">// 参数为lvalue</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;lvalue&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;rvalue&quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;          <span class="comment">// 参数为lvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">func2</span>(i);                   <span class="comment">// 调用lvalue</span></span><br><span class="line">  <span class="built_in">func2</span>(<span class="number">8</span>);                   <span class="comment">// 调用rvalue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>output</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">lvalue</span><br></pre></td></tr></table></figure><br>怎么解决<code>func2</code>无法调用重载版本的问题呢</p>
<ul>
<li><p>在<code>func2(int&amp;&amp; i)</code>中添加<code>std::move()</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;         <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(std::<span class="built_in">move</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>func2()</code>改成模板参数写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp; i)</span> </span>&#123;            <span class="comment">// 参数为lvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(T&amp;&amp; i)</span> </span>&#123;           <span class="comment">// 参数为rvalue</span></span><br><span class="line">  <span class="built_in">func1</span>(std::<span class="built_in">move</span>(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>C++11支持完美转发，提供以下方案<ul>
<li>如果类模板中（包括类模板和函数模板）函数的参数为<code>T&amp;&amp;</code>类型，则为万能引用（既可以接受左值引用，又可以接受右值引用）</li>
<li>提供模板函数<code>std::forward&lt;T&gt;()</code>，用于转发参数，转发后保留参数的左右值类型<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">func1</span>(std::forward&lt;T&gt;(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">func</span>(i);</span><br><span class="line">  <span class="built_in">func</span>(<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<strong>output</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lvalue</span><br><span class="line">rvalue</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/6b49fcb0.html" rel="prev" title="日常碎碎念_1">
      <i class="fa fa-chevron-left"></i> 日常碎碎念_1
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/f52d6913.html" rel="next" title="日常碎碎念_2">
      日常碎碎念_2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.</span> <span class="nav-text">左值引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%B7%AE%E5%88%AB"><span class="nav-number">1.2.</span> <span class="nav-text">值传递和引用传递的差别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC-amp-%E5%8F%B3%E5%80%BC"><span class="nav-number">1.3.</span> <span class="nav-text">左值&amp;右值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8-rvalue-reference"><span class="nav-number">1.4.</span> <span class="nav-text">右值引用 (rvalue reference)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8-const-lvalue-reference"><span class="nav-number">1.5.</span> <span class="nav-text">常量左值引用 (const lvalue reference)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BD%93%E5%87%BD%E6%95%B0%E5%92%8C%E5%BC%95%E7%94%A8%E6%89%93%E6%9E%B6%E7%9A%84%E6%97%B6%E5%80%99-%E8%AF%AF"><span class="nav-number">1.6.</span> <span class="nav-text">当函数和引用打架的时候(误)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="nav-number">1.6.1.</span> <span class="nav-text">函数返回值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">1.6.2.</span> <span class="nav-text">函数参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89-std-move"><span class="nav-number">1.7.</span> <span class="nav-text">移动语义 std::move()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#std-move"><span class="nav-number">1.8.</span> <span class="nav-text">std::move()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0-reference-collapsing"><span class="nav-number">1.9.</span> <span class="nav-text">引用折叠 (reference collapsing)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91-std-forward"><span class="nav-number">1.10.</span> <span class="nav-text">完美转发 std::forward</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="594飞飘"
      src="/images/feipiao.gif">
  <p class="site-author-name" itemprop="name">594飞飘</p>
  <div class="site-description" itemprop="description">Pray to take back the sunflower that was given out from the bottom of my heart.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/feipiao594" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;feipiao594" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://space.bilibili.com/95951563" title="BiliBili → https:&#x2F;&#x2F;space.bilibili.com&#x2F;95951563" rel="noopener" target="_blank"><i class="fab bilibili fa-fw"></i>BiliBili</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">594飞飘</span>
</div>
  <div class="symbols_count_time">
      <span class="post-meta-item-icon">
        <i class="fa fa-chart-area"></i>
      </span>
      站点总字数：<span title="站点总字数">150k</span>

    <span class="post-meta-divider">|</span>
      <span class="post-meta-item-icon">
        <i class="fa fa-coffee"></i>
      </span>
      站点阅读时长：<span title="站点阅读时长">4:33</span>
</div>


<script async src="https://umami.love98.net/script.js" data-website-id="6b8acd05-1687-459d-b789-220ab3d934d6"></script>

        








      </div>
    </footer>
  </div>

  
  <script color='' opacity='' zIndex='' count='' src="/lib/canvas-nest/canvas-nest-nomobile.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'f5e8376ff81aa630f399',
      clientSecret: '222629233c179d38e453587fdc8828ac5ae8d831',
      repo        : 'feipiao594.github.io',
      owner       : 'feipiao594',
      admin       : ['feipiao594'],
      id          : '561b352c2dcbf658688bbf7063e6222a',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script type="text/javascript" src="/js/category.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300,"hOffset":50,"vOffset":-15},"mobile":{"show":false},"react":{"opacity":0.7},"log":false});</script></body>
</html>
